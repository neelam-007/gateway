<!--
  Common build file for all modules
-->
<project name="common"
         xmlns:ivy="antlib:org.apache.ivy.ant" xmlns:jacoco="antlib:org.jacoco.ant">

    <!-- Get any user properties -->
    <property file="${user.home}/build.properties"/>

    <!--
      Set global properties
    -->
    <property name="build.dir" value="${basedir}/build"/>
    <property name="build.etc.dir" value="${build.dir}/etc"/>
    <property name="classes.main.dir" value="${build.dir}/classes"/>
    <property name="classes.test.dir" value="${build.dir}/test-classes"/>
    <property name="classes.obf.dir" value="${build.dir}/obf-classes"/>
    <property name="deps.dir" value="${build.dir}/dependency"/>
    <property name="deps.alt.dir" value="${build.dir}/dependency/alt"/>
    <property name="src.main.java.dir" value="${basedir}/src/main/java"/>
    <property name="src.main.res.dir" value="${basedir}/src/main/resources"/>
    <property name="src.test.java.dir" value="${basedir}/src/test/java"/>
    <property name="src.test.res.dir" value="${basedir}/src/test/resources"/>
    <property name="report.dir" value="${build.dir}/reports"/>
    <property name="report.test.dir" value="${build.dir}/reports/tests"/>

    <property name="ivy.settings.filepath" value="${src.root}/etc/build/ivysettings.xml"/>
    <property name="ivy.file" value="${basedir}/ivy.xml"/>

	<property name="file.extension" value="jar"/>
    <property name="jar.sign.pattern" value="unsigned/*.${file.extension}"/>
    <property name="jar.file" value="${build.dir}/jar/${ant.project.name}.${file.extension}"/>
    <property name="jar.file.unsigned" value="${build.dir}/unsigned/${ant.project.name}.${file.extension}"/>
    <property name="jar.file.test" value="${build.dir}/test/${ant.project.name}.${file.extension}"/>
    <property name="main.class.name" value="${ant.project.name}.Main"/>

    <property name="module.version.default.target" value="1.0"/>
    <property name="module.version.target" value="${module.version.default.target}"/>
    <property name="module.classpath.prefix" value="lib/"/>
    <property name="module.compile.source" value="1.8"/>
    <property name="module.compile.target" value="1.8"/>
    <property name="module.compile.optimize" value="off"/>
    <property name="module.compile.verbose" value="no"/>
    <property name="module.compile.xlint" value=":none"/> <!-- redefine as "" if you want to enable warnings -->
    <property name="module.compile.excludes" value=""/>
    <property name="module.forms.excludes" value=""/>
    <property name="module.jar.index" value="false"/>
    <property name="module.package.root" value="."/>
    <property name="module.source.allow.properties" value="false"/>
    <property name="module.resources.allow.forms" value="false"/>
    <property name="module.official.build" value="true"/> <!-- Remove for dev Jar versioning -->
    <property name="module.idea.configurations" value="default,test"/>
    <property name="module.idea.dependencies.scope" value=""/>

    <!--
      Classpath for Idea form compiler
    -->
    <path id="uidesigner.classpath">
        <fileset dir="${src.root}/lib/tools">
            <include name="jdom.jar"/>
            <include name="asm-all.jar"/>
            <include name="javac2.jar"/>
        </fileset>
    </path>

    <!--
      Classpath for Jasper Reports compiler
    -->
    <path id="jasperreports.classpath">
        <file file="${src.root}/lib/repository/net.sf.jasperreports/jasperreports-6.1.0-p1.jar"/>
        <file file="${src.root}/lib/repository/jfree/jcommon-1.0.17.jar"/>
        <file file="${src.root}/lib/repository/jfree/jfreechart-1.0.14.jar"/>
        <file file="${src.root}/lib/repository/org.eclipse.jdt.core.compiler/ecj-4.3.1.jar"/>
        <file file="${src.root}/lib/repository/commons-digester/commons-digester-2.1.jar"/>
        <file file="${src.root}/lib/repository/commons-collections/commons-collections-3.2.2.jar"/>
        <file file="${src.root}/lib/repository/commons-logging/commons-logging-1.1.1.jar"/>
        <file file="${src.root}/lib/repository/commons-beanutils/commons-beanutils-1.9.0.jar"/>
        <file file="${src.root}/lib/repository/com.lowawgie/iText-2.1.7.js2.jar"/>
    </path>

    <target name="task-init">
        <!--
          Task definition defaults for ivy resolve
        -->
        <presetdef name="ivy-resolve">
            <ivy:resolve file="${ivy.file}"
                         showprogress="false"
                         log="quiet"
                         checkIfChanged="false"/>
        </presetdef>

        <!--
          Task definition for Idea form compiler
        -->
        <taskdef name="javac2t"
                 classname="com.intellij.ant.Javac2"
                 classpathref="uidesigner.classpath"/>

        <!--
          Modules JAVAC definition with some presets
        -->
        <presetdef name="module-javac">
            <javac debug="on"
                   optimize="${module.compile.optimize}"
                   verbose="${module.compile.verbose}"
                   source="${module.compile.source}"
                   target="${module.compile.target}"
                   excludes="${module.compile.excludes}"
                   encoding="UTF-8"
                   includeAntRuntime="no"
                    >
                <compilerarg value="-Xlint${module.compile.xlint}" compiler="modern"/>
                <compilerarg value="-Xlint:-serial" compiler="modern"/>
                <compilerarg value="-Xlint:-path" compiler="modern"/>
                <classpath >
					<path>
						<fileset dir="${java.home}/lib" includes="javaws.jar" />
					</path>
                    <path refid="lib.path.id"/>
				</classpath>
            </javac>
        </presetdef>


        <!--
          Task definition for Jasper Report compiler
        -->
        <taskdef name="jrc" classname="net.sf.jasperreports.ant.JRAntCompileTask">
            <classpath refid="jasperreports.classpath"/>
        </taskdef>

        <!--
          Modules Jasper Reports compiler definition with presets
        -->
        <macrodef name="module-jrc">
            <attribute name="srcdir"/>
            <attribute name="destdir"/>
            <attribute name="classpathref"/>
            <sequential>
                <jrc destdir="@{destdir}">
                    <src>
                        <fileset dir="@{srcdir}">
                            <include name="**/*.jrxml"/>
                            <exclude name="**/*.pom"/>
                        </fileset>
                    </src>
                    <classpath>
                        <pathelement path="@{destdir}"/>
                        <path refid="@{classpathref}"/>
                    </classpath>
                </jrc>
            </sequential>
        </macrodef>

        <!--
          Modules IDEA form compiler definition with some presets
        -->
        <presetdef name="module-javac2">
            <javac2t
                    debug="on"
                    source="${module.compile.source}"
                    target="${module.compile.target}"
                    failonerror="true"
                    optimize="on"
                    includeAntRuntime="no"
                    >
                <include name="**/*.form"/>
                <exclude name="${module.forms.excludes}"/>
            </javac2t>
        </presetdef>

        <!--
          Task to run a ZKM with convention for subdirs, library names, etc
        -->
        <macrodef name="obfuscate-classes">
            <attribute name="zkmFilePath" default="${src.root}/etc/obfuscation/genjarobf.zkm"/>
            <sequential>
                <echo>Generating script for ${ant.project.name} obfuscation.</echo>
                <ivy-resolve conf="optional,runtime,compile"/>
                <ivy:cachepath pathid="lib.obfuscate.path.id" conf="compile"/>
                <path id="full.obfuscate.path.id">
                    <pathelement path="${sun.boot.class.path}"/>
                    <fileset dir="${java.home}/lib/ext">
                        <include name="*.jar"/>
                    </fileset>
					<fileset dir="${java.home}/lib" includes="javaws.jar" />
                    <path refid="lib.obfuscate.path.id"/>
                </path>
                <pathconvert property="lib.obfuscate.path.text" targetos="unix" pathsep="&quot;${line.separator}&quot;" refid="full.obfuscate.path.id"/>
                <copy file="@{zkmFilePath}" tofile="${build.dir}/etc/obfuscation.zkm" overwrite="true">
                    <filterset>
                        <filter token="CP" value="${lib.obfuscate.path.text}"/>
                        <filter token="JAR" value="${classes.main.dir}/*"/>
                        <filter token="CHANGELOG" value="${build.dir}/obfuscation/change.log"/>
                        <filter token="OUT" value="${classes.obf.dir}"/>
                    </filterset>
                </copy>

                <echo>Obfuscating ${ant.project.name}.</echo>
                <Zelix scriptFileName="${build.dir}/etc/obfuscation.zkm"
                       logFileName="${build.dir}/obfuscation/obfuscation.log"
                       trimLogFileName="${build.dir}/obfuscation/obfuscation_trim.log"
                       isParseOnly="false"
                       isVerbose="true"/>

                <echo>Copying resources for obfuscated classes.</echo>
                <copy todir="${classes.obf.dir}">
                    <fileset dir="${classes.main.dir}" excludes="**/*.class"/>
                </copy>

                <echo>Obfuscation completed for ${ant.project.name}.</echo>
            </sequential>
        </macrodef>

        <!--
          Modules JAR signing task with presets
        -->
        <presetdef name="sign-jar">
            <signjar keystore="${src.root}/etc/ssgKeyStore" alias="signer7" storepass="password" jar="${jar.file}">
                <path>
                    <fileset dir="${build.dir}" includes="${jar.sign.pattern}" />
                </path>
            </signjar>
        </presetdef>
		
		<!--
		Macrodef for signing aars/jars using SkarSigner
		-->
		<macrodef name="skarsigner-sign-archive">
			<!-- Defaults that could be overridden -->
			<attribute name="keystore" default="${src.root}/etc/signer/gatewayKeyStore.p12"/>
			<attribute name="access.password" default="szN3UvJzG-E.vddYvZ1L9WThnMe4D2ijVw"/>
			<attribute name="load.password" default="szN3UvJzG-E.vddYvZ1L9WThnMe4D2ijVw"/>
			<attribute name="skarSigner" default="${src.root}/modules/internal/build/SkarSigner.jar"/>
			<attribute name="input" default="${build.dir}/${file.extension}/${ant.project.name}.${file.extension}"/>
			<attribute name="output" default="${build.dir}/s${file.extension}/${ant.project.name}.s${file.extension}"/>
			<sequential>
				<echo level="info">Signing @{input} as @{output} using key @{keystore}</echo>
                <mkdir dir="${build.dir}/s${file.extension}" />
                <java jar="@{skarSigner}" fork="true" failonerror="true">
					<arg line="sign"/>
					<arg line="-f &quot;@{keystore}&quot;"/>
					<arg line="-p &quot;@{access.password}&quot;"/>
					<arg line="-k &quot;@{load.password}&quot;"/>
					<arg line="-s &quot;@{input}&quot;"/>
					<arg line="-o &quot;@{output}&quot;"/>
				</java>
			</sequential>
		</macrodef>
		
		<!--
		Macrodef for signing aars/jars using SkarSigner
		-->
		<macrodef name="skarsigner-generate-restman-xml">
			<!-- Defaults that could be overridden -->
			<attribute name="skarSigner" default="${src.root}/modules/internal/build/SkarSigner.jar"/>
			<attribute name="assertion" default="${ant.project.name}"/>
			<attribute name="input" default="${build.dir}/s${file.extension}/${ant.project.name}.s${file.extension}"/>
			<attribute name="output" default="${build.dir}/s${file.extension}.xml/${ant.project.name}.s${file.extension}.xml"/>
			<sequential>
				<echo level="info">Generate RESTman XML for @{input} as @{output}</echo>
                <mkdir dir="${build.dir}/s${file.extension}.xml" />
				<java jar="@{skarSigner}" fork="true" failonerror="true">
					<arg line="genSmfXml"/>
					<arg line="-n &quot;@{assertion}&quot;"/>
					<arg line="-f &quot;@{input}&quot;"/>
					<arg line="-o &quot;@{output}&quot;"/>
				</java>
			</sequential>
		</macrodef>
	
        <!--
          Module task to unpack an artifact into this modules classes directory (useful to combine JARs for Applets, etc)
        -->
        <macrodef name="jar-include">
            <attribute name="name"/>
            <attribute name="conf" default="master"/>
            <attribute name="organisation" default="com.l7tech"/>
            <attribute name="dir" default="${classes.main.dir}"/>
            <sequential>
                <ivy:cachepath
                        pathid="jar.include.@{name}.classpath"
                        inline="true"
                        organisation="@{organisation}"
                        module="@{name}"
                        conf="@{conf}"
                        type="jar"
                        transitive="false"
                        log="quiet"/>

                <pathconvert property="jar.include.@{name}.text" targetos="unix" pathsep=":" refid="jar.include.@{name}.classpath"/>
                <echo level="info">Including JAR: ${jar.include.@{name}.text}</echo>

                <mkdir dir="${classes.main.dir}"/>
                <unjar src="${jar.include.@{name}.text}" dest="@{dir}">
                    <patternset>
                        <exclude name="META-INF/*"/>
                        <exclude name="META-INF"/>
                        <exclude name="com/l7tech/config.properties"/>
                        <exclude name="com/l7tech/EntityTypes.properties"/>
                    </patternset>
                </unjar>
                <delete file="@{dir}/config.properties" quiet="true"/>
                <delete file="@{dir}/EntityTypes.properties" quiet="true"/>
                <unjar src="${jar.include.@{name}.text}" dest="@{dir}">
                    <patternset>
                        <include name="com/l7tech/config.properties"/>
                        <include name="com/l7tech/EntityTypes.properties"/>
                    </patternset>
                    <mapper type="flatten"/>
                </unjar>
                <concat destfile="@{dir}/com/l7tech/config.properties" append="yes">
                    <fileset dir="@{dir}" includes="config.properties"/>
                </concat>
                <delete file="@{dir}/config.properties" quiet="true"/>
                <concat destfile="@{dir}/com/l7tech/EntityTypes.properties" append="yes" fixlastline="yes">
                    <fileset dir="@{dir}" includes="EntityTypes.properties"/>
                </concat>
                <delete file="@{dir}/EntityTypes.properties" quiet="true"/>
            </sequential>
        </macrodef>

        <!--
          Module task to verify dependencies against a whitelist.
        -->
        <macrodef name="jar-include-verify">
            <attribute name="file"/>
            <attribute name="module"/>
            <attribute name="whitelist"/>
            <sequential>
                <ivy:resolve file="@{file}" conf="runtime" showprogress="false" log="quiet"/>
                <ivy:cachepath
                        pathid="@{module}.layer7.dependency.path"
                        organisation="com.l7tech"
                        module="@{module}"
                        conf="runtime"
                        log="quiet"/>
                <pathconvert property="@{module}.layer7.dependency.path.text" pathsep=" " refid="@{module}.layer7.dependency.path">
                    <mapper type="regexp" from=".*[/\\](layer7-.*${module.version.target}.*)?\.jar" to="\1"/>
                </pathconvert>
                <condition property="@{module}.included.dependencies">
                    <!-- Whitelist of modules that are included below -->
                    <matches pattern="^((@{whitelist})-${module.version.target} ?){1,1000}$" string="${@{module}.layer7.dependency.path.text}"/>
                </condition>
                <fail unless="@{module}.included.dependencies" message="Missing included module JAR(s) for applet ${@{module}.layer7.dependency.path.text}"/>
            </sequential>
        </macrodef>
		
		<!--
		Jacoco taskdef
		-->
		<taskdef uri="antlib:org.jacoco.ant" resource="org/jacoco/ant/antlib.xml">
			<classpath path="${src.root}/lib/tools/jacocoant.jar"/>
		</taskdef>
	
    </target>

    <!--
      Show build info for the module
    -->
    <target name="info">
        <echo>
            ===============================================================
            Processing module ${ant.project.name}
            ===============================================================
        </echo>
    </target>

    <!--
      Repository retrieval
    -->
    <target name="retrieve" depends="init">
        <ivy-resolve conf="*"/>
        <ivy:retrieve
                pattern="${build.dir}/repository/[organisation]/[artifact]-[revision](-[classifier]).[ext]"
                ivypattern="${build.dir}/repository/[organisation]/[module]-ivy-[revision].xml"/>
    </target>

    <target name="extra-path-init-pre">
        <path id="extras.path.id"/>
    </target>
    <target name="extra-path-init" if="emma.instrumentation.parameters" depends="extra-path-init-pre">
        <echo>Adding path for coverage build (EMMA)</echo>
        <path id="extras.path.id">
            <!--
              Path valid when running in TeamCity for a coverage build
            -->
            <pathelement location="${src.root}/../../plugins/coveragePlugin/emma.jar"/>
        </path>
    </target>

    <!--
      Common initialization
    -->
    <target name="init" depends="task-init,extra-path-init">
        <ivy:settings file="${ivy.settings.filepath}"/>

        <!-- Determine available sources -->
        <available file="${src.main.java.dir}" type="dir" property="module.source.available"/>
        <available file="${src.main.res.dir}" type="dir" property="module.resources.available"/>
        <available file="${src.test.java.dir}" type="dir" property="module.tests.available"/>
        <available file="${src.test.res.dir}" type="dir" property="module.testresources.available"/>
    </target>

    <!--
      Generate report
    -->
    <target name="report" description="Generate a report of dependencies" depends="init">
        <ivy-resolve conf="runtime"/>
        <ivy:report todir="${report.dir}" graph="false"/>
    </target>

    <!--
      Compile
    -->
    <target name="compile-main-init" if="module.source.available" depends="init">
        <mkdir dir="${classes.main.dir}"/>
        <ivy-resolve conf="compile"/>
        <ivy:cachepath pathid="lib.path.id" conf="compile"/>
        <pathconvert property="lib.path.text" targetos="unix" pathsep="${line.separator}" refid="lib.path.id"/>
        <echo level="debug">Resolved compilation path:${line.separator}${lib.path.text}</echo>
        <path id="module.invalid.source.filepath">
            <fileset dir="${src.main.java.dir}">
                <exclude name="${module.package.root}/**/*"/>
            </fileset>
        </path>
        <condition property="module.invalid.package">
            <and>
                <not>
                    <equals arg1="${module.package.root}" arg2="."/>
                </not>
                <resourcecount refid="module.invalid.source.filepath" when="greater" count="0" />
            </and>
        </condition>
        <fail if="module.invalid.package">Invalid source found, this module should only have sources under : ${module.package.root}${line.separator}${toString:module.invalid.source.filepath}</fail>
        <path id="module.properties.source.filepath">
            <fileset dir="${src.main.java.dir}">
                <include name="**/*.properties"/>
            </fileset>
        </path>
        <condition property="module.invalid.properties">
            <and>
                <equals arg1="${module.source.allow.properties}" arg2="false"/>
                <resourcecount refid="module.properties.source.filepath" when="greater" count="0" />
            </and>
        </condition>
        <fail if="module.invalid.properties">Invalid source found, this module should not have properties files in the java source tree.${line.separator}${toString:module.properties.source.filepath}</fail>
    </target>
    <target name="compile-main-java" if="module.source.available" depends="compile-main-init">
        <module-javac srcdir="${src.main.java.dir}" destdir="${classes.main.dir}"/>
    </target>
    <target name="compile-main-forms" if="module.source.available" unless="module.skip.forms" depends="compile-main-init, compile-main-java">
        <module-javac2 srcdir="${src.main.java.dir}" destdir="${classes.main.dir}">
		<classpath >
			<path>
				<fileset dir="${java.home}/lib" includes="javaws.jar" />
			</path>
			<path refid="lib.path.id"/>
		</classpath>
		</module-javac2>
    </target>
    <target name="compile-main-jasper" if="module.jasper.available" depends="compile-main-init, compile-main-java">
        <module-jrc srcdir="${src.main.java.dir}" destdir="${classes.main.dir}" classpathref="lib.path.id"/>
    </target>
    <target name="compile-main-resources" if="module.resources.available" depends="compile-main-init">
        <path id="module.form.resources.filepath">
            <fileset dir="${src.main.res.dir}">
                <include name="**/*.form"/>
            </fileset>
        </path>
        <condition property="module.invalid.form">
            <and>
                <equals arg1="${module.resources.allow.forms}" arg2="false"/>
                <resourcecount refid="module.form.resources.filepath" when="greater" count="0" />
            </and>
        </condition>
        <fail if="module.invalid.form">Invalid resources found, this module should not have IDEA form files in the resources source tree.${line.separator}${toString:module.form.resources.filepath}</fail>

        <copy todir="${classes.main.dir}" preservelastmodified="true">
            <fileset dir="${src.main.res.dir}" includes="**/*.properties"/>
            <filterset begintoken="@@@" endtoken="@@@">
                <filtersfile file="${src.root}/build/etc/filter.properties"/>
            </filterset>
        </copy>
        <copy todir="${classes.main.dir}" preservelastmodified="true">
            <fileset dir="${src.main.res.dir}" excludes="**/*.properties"/>
        </copy>
    </target>
    <target name="compile" description="Compile" if="module.source.available"
            depends="compile-main-java, compile-main-forms, compile-main-jasper, compile-main-resources">
    </target>

    <!--
      Test
    -->
    <target name="compile-test-init" if="module.tests.available" depends="init" unless="module.skip.tests">
        <mkdir dir="${classes.test.dir}"/>
        <ivy-resolve conf="test"/>
        <ivy:cachepath pathid="lib.test.path.id" conf="test"/>
        <pathconvert property="lib.test.path.text" targetos="unix" pathsep="${line.separator}"
                     refid="lib.test.path.id"/>
        <echo level="debug">Resolved test path:${line.separator}${lib.test.path.text}</echo>
        <path id="full.test.path.id">
            <pathelement location="${classes.main.dir}"/>
            <path refid="lib.test.path.id"/>
        </path>
    </target>
    <target name="compile-test-java" if="module.tests.available" depends="compile-test-init,compile" unless="module.skip.tests">
        <module-javac srcdir="${src.test.java.dir}" destdir="${classes.test.dir}">
            <classpath refid="full.test.path.id"/>
        </module-javac>
    </target>
    <target name="check-skip-test-forms">
        <condition property="module.skip.test.forms" value="true" else="false">
            <or>
                <equals arg1="${module.skip.forms}" arg2="true"/>
                <equals arg1="${module.skip.tests}" arg2="true"/>
            </or>
        </condition>
    </target>
    <target name="compile-test-forms" if="module.tests.available" unless="module.skip.test.forms" depends="check-skip-test-forms, compile-test-init, compile-test-java">
        <module-javac2 srcdir="${src.test.java.dir}" destdir="${classes.test.dir}" classpathref="full.test.path.id"/>
    </target>
    <target name="compile-test-resources" if="module.testresources.available" depends="compile-test-init" unless="module.skip.tests">
        <copy todir="${classes.test.dir}" preservelastmodified="true">
            <fileset dir="${src.test.res.dir}" includes="**/*.properties"/>
            <filterset begintoken="@@@" endtoken="@@@">
                <filtersfile file="${src.root}/build/etc/filter.properties"/>
            </filterset>
        </copy>
        <copy todir="${classes.test.dir}" preservelastmodified="true">
            <fileset dir="${src.test.res.dir}" excludes="**/*.properties"/>
        </copy>
    </target>
    <target name="compile-test-all" depends="compile-test-java, compile-test-forms, compile-test-resources" unless="module.skip.tests"/>
    <target name="test" description="Run unit tests" if="module.tests.available" unless="module.skip.tests"
            depends="compile-test-all">
        <mkdir dir="${report.test.dir}"/>

		<jacoco:coverage destfile="build/jacoco.exec">
			<junit printsummary="yes"
				   haltonfailure="no"
				   fork="on"
				   forkmode="once"
				   errorproperty="test.error"
				   failureproperty="test.failure"
				   maxmemory="2560m">
				<jvmarg value="-ea"/>

				<classpath>
					<pathelement location="${classes.test.dir}"/>
					<path refid="full.test.path.id"/>
				</classpath>

				<formatter type="plain" unless="build.junit.xmlformat"/>
				<formatter type="xml" if="build.junit.xmlformat"/>

				<sysproperty key="src.root" value="${src.root}"/>
				<syspropertyset>
					<propertyref prefix="com.l7tech"/>
					<propertyref name="module.skip.forms"/>
					<!-- This property is used to specify the build type. For example nightly or daily
					Example: -Dbuild.type="nightly" -->
					<propertyref name="build.type"/>
					<!-- This is used to set the random generator. On tests we use /dev/urandom otherwise the tests will block waiting for entropy.
					 Example: run tests with: -Djava.security.egd=file:/dev/./urandom-->
					<propertyref name="java.security.egd"/>
					<!-- use this property to tweak the timeout for creating source and target environments  during migration
					 Example: -Dtest.migration.waitTimeMinutes=15 -->
					<propertyref name="test.migration.waitTimeMinutes"/>
					<!-- use this property to set the current code signing certificate inside /etc/ssgKeyStore
					 Example: -Dcode.signer.cert.alias=signer7 -->
					<propertyref name="code.signer.cert.alias"/>
					<!-- use this property to tweak the code signing certificate expiry period (in days) threshold
					nightly builds will fail when the current code signing certificate already expired or will expire within the specified threshold
					 Example: -Dcode.signer.cert.expiry.reminder.days=180 -->
					<propertyref name="code.signer.cert.expiry.reminder.days"/>
				</syspropertyset>

				<batchtest haltonfailure="no" todir="${report.test.dir}">
					<fileset dir="${classes.test.dir}">
						<include name="**/*Test.class"/>
					</fileset>
				</batchtest>
			</junit>
		</jacoco:coverage>

        <!-- Does not fail on runtime error and test failure -->
        <!-- <fail if="test.failure">One or more JUnit tests failed.</fail> -->
        <!-- <fail if="test.error">One or more JUnit tests exited due to error.</fail> -->
    </target>

    <!--
    -->
    <target name="ivy-official-version" if="module.official.build" depends="init">
        <ivy:info file="${ivy.file}"/>
        <property name="ivy.new.revision" value="${module.version.target}"/>
    </target>
    <target name="ivy-new-version" unless="ivy.new.revision" depends="init,ivy-official-version">
        <property name="module.version.prefix" value="${module.version.target}-dev-b"/>

        <ivy:info file="${ivy.file}"/>
        <ivy:buildnumber
                organisation="${ivy.organisation}" module="${ivy.module}"
                revision="${module.version.prefix}" defaultBuildNumber="1" revSep=""/>
    </target>

    <!--
    -->
    <target name="local-version">
        <tstamp>
            <format property="now" pattern="yyyyMMddHHmmss"/>
        </tstamp>
        <property name="ivy.new.revision" value="${module.version.target}-local-${now}"/>
    </target>

    <!--
    -->
    <target name="version" depends="ivy-new-version">
        <property name="version" value="${ivy.new.revision}"/>
    </target>

    <!--
    -->
    <target name="package.alt.dependencies.resolve" depends="init" if="module.resolve.alternatives" unless="module.package.dependencies.skip">
        <ivy-resolve conf="alternative"/>
    </target>
    <target name="package.alt.dependencies.retrieve" depends="package.alt.dependencies.resolve" if="module.resolve.alternatives" unless="module.package.dependencies.skip">
        <mkdir dir="${deps.alt.dir}"/>
        <ivy:retrieve pattern="${deps.alt.dir}/[artifact]-[revision](-[classifier]).[ext]"/>
    </target>
    <target name="package.dependencies.resolve" depends="init">
        <ivy-resolve conf="runtime"/>
    </target>
    <target name="package.dependencies.retrieve" depends="package.dependencies.resolve" unless="module.package.dependencies.skip">
        <mkdir dir="${deps.dir}"/>
        <ivy:retrieve pattern="${deps.dir}/[artifact]-[revision](-[classifier]).[ext]"/>
    </target>
    <target name="package.dependencies" depends="package.alt.dependencies.retrieve, package.dependencies.retrieve" unless="module.package.dependencies.skip"/>
    <target name="package.classpath" if="module.main">
        <ivy:cachepath pathid="module.classpath" conf="runtime"/>
        <pathconvert property="module.classpath.text" pathsep=" " refid="module.classpath">
            <mapper type="regexp" from=".*[/\\](.*)\.jar" to="${module.classpath.prefix}\1.jar"/>
        </pathconvert>

        <mkdir dir="${build.etc.dir}"/>
        <manifest file="${build.etc.dir}/MANIFEST.MF">
            <attribute name="Main-Class" value="${module.main}"/>
            <attribute name="Class-Path" value="${module.classpath.text}"/>
        </manifest>
    </target>
    <target name="package.init">
        <available property="module.package.jar.required" file="${classes.main.dir}"/>
        <condition property="module.obfuscate.enabled">
            <and>
                <isset property="module.obfuscate"/>
                <isset property="module.package.jar.required"/>
                <not>
                    <isset property="module.obfuscate.disabled"/>
                </not>
            </and>
        </condition>
    </target>
    <!-- Overridden by modules with custom packaging requirements -->
    <target name="package.custom">
    </target>
    <target name="package.custom.post">
    </target>
    <target name="package.obfuscate" if="module.obfuscate.enabled">
        <obfuscate-classes/>
        <property name="package.classes.dir" value="${classes.obf.dir}"/>
    </target>
    <target name="package.work" if="module.package.jar.required" unless="module.package.jar.disabled"
            depends="compile, package.dependencies, package.init, package.classpath, package.custom, package.obfuscate">
        <property name="package.classes.dir" value="${classes.main.dir}"/>
        <property name="ivy.extra.title" value="${ivy.module}"/>
        <mkdir dir="${build.etc.dir}"/>
        <touch file="${build.etc.dir}/MANIFEST.MF"/>
        <jar destfile="${jar.file}" manifest="${build.etc.dir}/MANIFEST.MF" index="${module.jar.index}">
            <fileset dir="${package.classes.dir}"/>
            <!-- Index element is ignored unless index is true for the jar task -->
            <indexjars>
                <path refid="module.classpath"/>
            </indexjars>
            <manifest>
                <attribute name="Implementation-Title" value="${ivy.extra.title}"/>
                <attribute name="Implementation-Version" value="${module.version.target}"/>
                <attribute name="Implementation-Vendor" value="${build.vendor}"/>
                <attribute name="Implementation-Vendor-Id" value="${build.vendor.id}"/>
                <attribute name="Built-By" value="${build.user}"/>
                <attribute name="Build-Jdk" value="${java.version}"/>
                <attribute name="Build-Timestamp" value="${build.timestamp}"/>
            </manifest>
        </jar>
    </target>
    <target name="package.sign" if="module.sign">
        <copy file="${jar.file}" tofile="${jar.file.unsigned}.tmp"/>
        <sign-jar/>
        <move file="${jar.file.unsigned}.tmp" tofile="${jar.file.unsigned}"/>
    </target>
	
	<target name="package" depends="version, compile, package.work, package.custom.post, package.sign, package.skarsigner.sign.archive, package.skarsigner.generate.restman.xml" description="Package this project">
    </target>
	
	<!--
	Check if both global and specific assertion properties have been set
	-->
	<target name="check.sign.archive">
		<condition property="sign.archive">
			<and>
				<equals arg1="${module.skarsigner.sign.all}" arg2="true"/>
				<isset property="module.skarsigner.sign.archive"/>
			</and>
		</condition>
	</target>
	
	<target name="check.generate.restman.xml">
		<condition property="generate.restman.xml">
			<and>
				<equals arg1="${module.skarsigner.sign.all}" arg2="true"/>
				<isset property="module.skarsigner.generate.restman.xml"/>
			</and>
		</condition>
	</target>
		
	<target name="package.skarsigner.sign.archive" depends="check.sign.archive" if="sign.archive" description="Sign aar/jar with the SkarSigner">
		<skarsigner-sign-archive keystore="${src.root}/${module.skarsigner.keystore}"/>
	</target>
		
	<target name="package.skarsigner.generate.restman.xml" depends="check.generate.restman.xml" if="generate.restman.xml" description="Generate RESTman xml with the SkarSigner">
		<skarsigner-generate-restman-xml/>
	</target>
	
    <!--
    -->
    <target name="packagetests" if="module.tests.available" depends="version, test" description="Package this project" unless="module.skip.tests">
        <jar destfile="${jar.file.test}">
            <fileset dir="${classes.test.dir}"/>
            <manifest>
                <attribute name="Built-By" value="${user.name}"/>
                <attribute name="Build-Version" value="${version}"/>
            </manifest>
        </jar>
    </target>

    <!--
    -->
    <target name="idea.init" depends="info, init, ivy-new-version">
        <mkdir dir="${build.etc.dir}"/>

        <ivy-resolve conf="${module.idea.configurations}" haltonfailure="false" />
        <!--<ivy:deliver deliverpattern="build/ivyidea/[organisation]/[module]-ivy-[revision].xml"-->
        <!--pubrevision="${module.version.target}"-->
        <!--status="integration"-->
        <!--/>-->
        <ivy:publish artifactspattern="${build.dir}/[type]/[artifact].[ext]"
                     resolver="idea"
                     haltonmissing="false"
                     warnonmissing="false"
                     pubrevision="${module.version.target}"
                     status="integration"
                     forcedeliver="true"
                     overwrite="true"
                />
    </target>
    <target name="idea.report.module" depends="idea.init" unless="module.useProjectLibraries">
        <ivy:report todir="${build.etc.dir}" outputpattern="dependency_gen.xml" conf="test" graph="false" xsl="false" xml="true"/>
    </target>
    <target name="idea.report.project" depends="idea.init" if="module.useProjectLibraries">
        <ivy:artifactreport tofile="${build.etc.dir}/dependency_gen.xml"/>
    </target>
    <target name="idea.report" depends="idea.report.module,idea.report.project"/>
    <target name="idea" depends="idea.report" description="Generate Intellij IDEA module">
        <copy file="${ivy.module}.iml" tofile="${build.etc.dir}/${ivy.module}.tmp.xml" overwrite="true" failonerror="false"/>
        <copy file="${src.root}/etc/build/idea_module.xml" tofile="${build.etc.dir}/${ivy.module}.tmp.xml" overwrite="false"/> <!-- Default to empty module -->
        <xslt in="${build.etc.dir}/dependency_gen.xml" out="${build.etc.dir}/dependency.xml"
              style="${src.root}/etc/build/identity.xsl" force="true"/>
        <xslt in="${build.etc.dir}/${ivy.module}.tmp.xml" out="${ivy.module}.iml"
              style="${src.root}/etc/build/idea_module.xsl" force="true">
            <param name="modulemeta" expression="${src.root}/etc/build/idea_meta.xml"/>
            <param name="data" expression="${build.etc.dir}/dependency.xml"/>
            <param name="build" expression="${basedir}/build.xml"/>
            <param name="source" expression="${module.source.available}"/>
            <param name="tests" expression="${module.tests.available}"/>
            <param name="source.resources" expression="${module.resources.available}"/>
            <param name="test.resources" expression="${module.testresources.available}"/>
            <param name="build.output" expression="${module.build.output}"/>
            <param name="scope" expression="${module.idea.dependencies.scope}"/>
        </xslt>
    </target>

    <target name="enable-m2local-snapshot" description="Enable publish of jars and rpms to local m2 repository">
        <echo level="info">Enabling publishing of integration (snapshot) to local m2 repo.</echo>
        <property name="publish.jar.target" value="local-m2"/>
        <property name="publish.status" value="integration"/>
        <property name="suffix.snapshot" value="-SNAPSHOT"/>
    </target>

	<!--
	-->
    <target name="enable-snapshot" description="Enable publish of jars and rpms to Artifactory">
        <echo level="info">Enabling Artifactory publishing of integration (snapshot) repo.</echo>
        <property name="publish.jar.target" value="artifactory-snapshot"/>
		<property name="publish.rpm.target" value="${artifactory.yum.snapshot}"/>
		<property name="publish.generic.target" value="${artifactory.generic.snapshot}"/>
		<property name="publish.status" value="integration"/>
		<property name="suffix.snapshot" value="-SNAPSHOT"/>
    </target>
	
	<!--
	-->
    <target name="enable-release" description="Enable publish of jars and rpms to Artifactory">
        <echo level="info">Enabling Artifactory publishing of release repo.</echo>
        <property name="publish.jar.target" value="artifactory-release"/>
		<property name="publish.rpm.target" value="${artifactory.yum.release}"/>
		<property name="publish.generic.target" value="${artifactory.generic.release}"/>
		<property name="publish.status" value="release"/>
		<property name="suffix.snapshot" value=""/>
    </target>
	
    <!--
		Run package, then publish locally
    -->
    <target name="publish" depends="info, clean, package, packagetests" description="Publish this project to the local Ivy repository">
        <!-- specify conf to publish -->
        <ivy:publish artifactspattern="${build.dir}/[type]/[artifact].[ext]"
                     module="${ant.project.name}"
                     conf="default, master, master-unsigned, compile, test, runtime, optional, core, client, skarsigner"
                     resolver="shared"
                     pubrevision="${version}"
                     overwrite="true"
					 haltonmissing="false"/>
        <echo message="project ${ant.project.name} local published with version ${version}"/>
    </target>

	<!--
		Assume that package is ready. Publish locally, then try to publish to artifactory
    -->
    <target name="publish-only" depends="version" description="Publish this project to the local Ivy repository">
        <antcall target="publish-artifactory-init"/>
        <!-- specify conf to publish conf -->
        <ivy:publish artifactspattern="${build.dir}/[type]/[artifact].[ext]"
                     module="${ant.project.name}"
                     conf="default, master, master-unsigned, compile, test, runtime, optional, core, client, skarsigner"
                     resolver="shared"
                     pubrevision="${version}${suffix.snapshot}"
                     overwrite="true"
					 haltonmissing="false"/>
        <echo message="project ${ant.project.name} local published with version ${version}"/>
        <antcall target="publish-artifactory"/>
    </target>
	
    <!--
        Run ivy:resolve, ivy:deliver, and ivy:makepom to prepare for publish-artifactory
    -->
    <target name="publish-artifactory-init" if="publish.jar.target" description="Resolve ivy dependencies and create pom file to prepare for publishing to Artifactory">
        <property name="publish.status" value="integration"/> <!-- if publish.status is not set from "enable-snapshot or enable-release", use default value of integration -->
        <ivy:resolve file="ivy.xml" conf="default, master, compile, test, runtime, optional, core, pom, skarsigner"/>
        <ivy:deliver deliverpattern="${build.dir}/ivy/ivy.xml" pubrevision="${version}${suffix.snapshot}" status="${publish.status}"/>
        <ivy:makepom ivyfile="${build.dir}/ivy/ivy.xml" pomfile="${build.dir}/pom/${ivy.module}.pom">
            <mapping conf="default" scope="compile"/>
            <mapping conf="master" scope="compile"/>
            <mapping conf="compile" scope="compile"/>
            <mapping conf="test" scope="test"/>
            <mapping conf="runtime" scope="runtime"/>
            <mapping conf="optional" scope="optional"/>
            <mapping conf="core" scope="compile"/>
            <mapping conf="skarsigner" scope="compile"/>
        </ivy:makepom>
    </target>

    <!--
		Publish to artifactory if publish.jar.target is set to an artifactory resolver
    -->
    <target name="publish-artifactory" if="publish.jar.target" description="Publish this project to Artifactory repository">
        <ivy:publish artifactspattern="${build.dir}/[type]/[artifact].[ext]"
                     module="${ant.project.name}"
                     conf="default, master, pom, core, skarsigner, optional, test"
                     resolver="${publish.jar.target}"
                     pubrevision="${version}"
                     overwrite="true"
					 haltonmissing="false"
                     publishivy="false"/>
        <echo message="project ${ant.project.name} artifactory published with version ${version}"/>
    </target>

    <!--
    -->
    <target name="clean" description="Clean the project">
        <delete dir="${build.dir}"/>
    </target>
</project>
