SSG keystores and certificates


Description of the organization of the keystores and certificates on the SSG for deployment and maintenance purposes. This is not a design document that describe how things should work but rather a precise description of the existing implementation.


1.SSL keystore, certificate and client trust


The ssl keystore is used by tomcat at runtime for ssl pusposes. It is important that tomcat knows where to find it and that tomcat has the permission to access this file at runtime.

Location: $TOMCAT_HOME/kstores/ssl.ks.

This keystore’s location and password must be accessible to tomcat through it’s server.xml file [$TOMCAT_HOME/conf/server.xml] as below:

<Factory className="org.apache.catalina.net.SSLServerSocketFactory"
…
keystoreFile="kstores/tomcatSsl" keystorePass="tralala"/>

1.Generating the ssl keystore

The ssl keystore is generated by the script sslGen.sh. At deployment time, this script is located in the sources root under the etc directory. Once deployment is complete, this script should be copied somewhere so that it will be available to the user even when the source are deleted. Recommended location to copy this script to is ~/bin.

When sslGen.sh runs, a key pair is created for ssl purposes. The “subject” for this keypair should match the host name that the user will use to refer this server with such as ssg.acme.com. In version 1.0, the script plainly asks for a host name and construct a DN based on that (option –dname "CN=host_name_provided" in keytool). In the beta version, the script lets keytool query the user to determine the subject. The user should provide the host name as an answer to the question “What is your first and last name” and leave the other info to “Unknown”.

This script will ask the user for a keystore password. This password will be recorded in [$TOMCAT_HOME/conf/server.xml] it is therefore important that the deploy target of the build script be run beforehand so that this file is ready to be parsed accordingly.

This keystore password is also recorded in the keystore.properties file.

2.SSL Certificate

Another output of sslGen.sh is the ssl self-signed cert. This config script will output the certificate $TOMCAT_HOME/kstores/ssl_self.cer which is the self-signed ssl certificate (ssg.cer in beta version). In post beta versions, another ssl certificate related file is produced: ssl.csr. This is a certificate signing request to be fed to another config script: signsslcsr.sh. This later script (which will be described in the next section) produces a certificate for ssl purposes that is signed by the root keystore instead of being self signed. The root signed ssl certificate, when produced by signsslcsr.sh has the path $TOMCAT_HOME/kstores/ssl.cer.

The later (ssl.cer) is the cert used by tomcat for ssl purposes. It should always be generated whenever the ssl keystore is regenerated.

The signsslcsr.sh script is called at the end of the sslGen.sh script when successfull.

3.Client Proxy and Console SSL trust

Whenever a new ssl key pair is generated on the ssg, the client proxy and console must be configured to trust this new key. The way this happens is that the proxy (and the console) will import the root ca cert in their local trusted store whenever they get ssl handshake exceptions. This cert is served to the client through the disco modulator servlet.

In order to protect against “man-in-the-middle attacks” where a malicious server serves its own cert to the client, the server sends along with the cert a magical value calculated with the user’s password. The user trust the cert is the ssg appears to know it’s password.


2.ROOT keystore

This whole section is not relevant if you are using the beta version (it was implemented post-beta).

The root keystore is used to generate client and ssl certs.  The accompanying root cert is used to verify client certs at run time.


Keystore location: $TOMCAT_HOME/kstores/ca.ks.

Because this keystore contains the private key, it may be located on a removable hardware component such as a usb key. If this is the case, the keystore must still be accessible from the location specified above through a symbolic link for example.

This keystore’s password must also be recorded. This is done by the script responsible to generating the keystore.

The accompanying certificate contains no private key are does not need to be secured.

Root cert location: $TOMCAT_HOME/kstores/ ca.cer.

The root keystore is used at runtime to sign client certificates. CSR requests will fail if this store is not available (if the removable hardware is not in place for example).

Whenever a request comes in that is authenticated using a client cert. This cert is verified using the root cert. Therefore it is important that this root cert always be present (unlike the root keystore which is only used to answer certificate signing requests).

1.Generating the root keystore

The script rootcaGen.sh generates the root keystore and its root certificate. It asks the caller for a password and a host name and generates the root keystore and its certificate.

Because this script must write to the keystore.properties file, the war file will be unzipped to the webapps directory if the file cannot be found. This is necessary the first time you generate this store because you built and deploy the software but the war file would normally be unzipped by tomcat only at startup.

After you run this script, don’t forget that you may want to move the actual root keystore to a removable hardware and link to it from its original location.

Once deployment is complete, the rootcaGen.sh script should be copied somewhere so that it will be available to the user even when the source are deleted. Recommended location to copy this script to is ~/bin.

Whenever you run this script, the script responsible for the generation of the ssl keystore is called.

2.SSL cert signing

In version 1.0, it is possible to generate a ssl cert signed by the root private key. This is done by the signsslcsr.sh script. You should never need to call this script directly because it is called by the script responsible for the creation of the ssl keystore.

This script needs to invoke our java software to run. It therefore also requires that the war file be unzipped. Although this should have occurred previously, it will automatically do it if the java libraries are not found.

This process involves reading the tomcatSsl.csr file and creating a new ssl certificate signed with the root key. It is important that the root keystore be present for this to succeed (the root cert is not enough). The web.xml file will be updated at the end of this script so that the disco modulator now refers to this new cert instead of the self-signed default cert.

This script should be executed whenever the root store is regenerated AND whenever the ssl store is regenerated.

Once deployment is complete, the signsslcsr.sh script should be copied somewhere so that it will be available to the user even when the source are deleted. Recommended location to copy this script to is ~/bin.

3.Note regarding updating ssg servers

When a ssg server is updated, chances are that your keystore.properties file was overwritten along with all the keystore passwords and locations. It is important that you manually adjust it (and potentially also server.xml) or that you regenerate both the root and ssl stores after the upgrade.


4.Client cert management

Client certs are created by the CSR Handler on the ssg. The process is initiated by the client who generates his own key pair and sends a CSR to the CSR Handler. The CSR Handler will only answer this request with a signed cert if:

the csr request comes in with valid username / password credentials through ssl
the client has re-generated his cert less than 10 times
the subject of the csr matches the login used in the request credentials

If these conditions are not met, the CSR Handler will return an error.

Otherwise, a cert is recorded in the local database and returned to the caller. This cert can then be used for authentication by the client until one of those two things happen:

the administrator revokes the client cert (through user panel). This simply erases the cert from the database
the root store (and its root cert) are regenerated.

At run time, a client cert is accepted if it matches the cert we have in our local database for the user and if it is signed by the current root. The latter is verified using the root cert which is why this cert must be present always.

We only support client certs for users defined in our local identity source (database). Client certs for ldap users will be supported post 1.0.

