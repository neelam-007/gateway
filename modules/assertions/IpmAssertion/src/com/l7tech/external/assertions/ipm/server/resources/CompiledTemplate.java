package com.l7tech.external.assertions.ipm.server.resources;

import java.io.IOException;

/**
 * Interface implemented by compiled templates.
 * <p/>
 * The actual compiled template instances are dynamically generated by {@link com.l7tech.external.assertions.ipm.server.TemplateCompiler}.
 * <P/>
 * <B>NOTE:</b> This class must be completely standalone.  It can use standard Java classes but must refer to
 * no Layer 7 classes.  This is because only this class by itself is fed to the runtime Java compiler alongside the
 * dynamically-generated subclass sources.
 * <p/>
 * Instances of this class are not threadsafe.  Users are responsible for any needed synchronization/thread-locality.
 */
public abstract class CompiledTemplate {
    protected char[] in;
    protected int ip;
    protected char[] out;
    protected int op;

    /**
     * Expand the input buffer, expected to be an IPM DATA_BUFF, into the output buffer as XML
     * according to the template implemented by this CompiledTemplate.
     * <p/>
     * <b>Note:</b> Only one thread at a time may call this method on the same CompiledTemplate instance,
     * even if it is using different buffers, because internal state is kept in member fields during
     * the expansion.
     *
     * @param in  the input buffer. Required.
     * @param out  the output buffer.  Required.
     * @return the expanded result String.  Never null.
     * @throws java.io.IOException  if there is a problem with the input format, the input is too short, or there is not
     *                              enough room in the output buffer.
     * @noinspection AssignmentToCollectionOrArrayFieldFromParameter
     */
    public String expand(char[] in, char[] out) throws IOException {
        if (in == null || out == null)
            throw new NullPointerException();

        this.in = in;
        this.out = out;
        this.ip = 0;
        this.op = 0;

        try {
            doExpand();
            return new String(out, 0, op);
        } catch (ArrayIndexOutOfBoundsException e) {
            throw new IOException("Unable to expand template: ran out of input characters, or filled output or temporary buffer: " + e.getMessage(), e);
        } finally {
            this.in = null;
            this.out = null;
            this.ip = 0;
            this.op = 0;
        }
    }

    protected abstract void doExpand() throws IOException;

    private static final char[] ENTAMP = "&amp;".toCharArray();
    private static final char[] ENTLT = "&lt;".toCharArray();
    private static final char[] ENTGT = "&gt;".toCharArray();

    /**
     * Copy count characters from in to out.
     * Output characters ampersand, greater-than and less-than will be replaced by XML entities.
     * Always either succeeds or throws IOException.
     *
     * @param count  number of characters to copy
     * @throws ArrayIndexOutOfBoundsException if we lack temporary buffer space, run out of input characters, or run out of room in the output buffer.
     */
    protected final void copy(int count) {
        while (count-- > 0) {
            char c = in[ip++];
            switch (c) {
                case '&':
                    write(ENTAMP);
                    break;
                case '<':
                    write(ENTLT);
                    break;
                case '>':
                    write(ENTGT);
                    break;
                default:
                    out[op++] = c;
            }
        }
    }

    /**
     * Copy the specified string into the output buffer.
     * Output characters are NOT XML escaped -- caller is responsible for any needed escaping.
     * Always either succeeds or throws IOException.
     *
     * @param what the string to emit.  Required.
     * @throws ArrayIndexOutOfBoundsException if we lack temporary buffer space, run out of input characters, or run out of room in the output buffer.
     */
    protected final void write(char[] what) {
        final int len = what.length;
        System.arraycopy(what, 0, out, op, len);
        op += len;
    }
}
