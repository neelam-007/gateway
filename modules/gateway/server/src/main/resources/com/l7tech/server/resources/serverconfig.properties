# suppress inspection "UnusedProperty" for whole file
#
# Server Configuration Properties (used by ServerConfig)
#

#
# FYI: When defining a property with a default of another property e.g. myproperty.default= ${myotherprop},
# then myotherprop should only be available as a system property. It is not currently intended for default
# properties to be dynamic.
# If it is also available as a cluster property, and a value has been supplied (i.e. it exists in cluster_properties)
# then on gateway start up, it is possible that the value used for myotherprop will be its default value
# and not the value from the database, depending on whether or not the default values in the cache have expired
# or not before the property is read. Really only an issue if the value is read once during assertion initialization
# for example
#

# Validation patterns
regex.boolean = (?i)true|false

# Shutdown delay
ssg.shutdownDelay.description = Seconds to wait during shutdown after stopping SSG components.
ssg.shutdownDelay.default = 0

# Numeric server ID (default generated from IP address)
serverId.description = Numeric server identifier
serverId.systemProperty = ${propertyPrefix}.serverId

# Multicast address (default generated randomly)
multicastAddress.description = Cluster multicast address
multicastAddress.systemProperty = ${propertyPrefix}.multicastAddress

# Whether cluster-wide replay protection is enabled
cluster.replayProtection.multicast.enabled.description = Whether replay protection will use multicast traffic to catch messages IDs replayed to a different cluster node (true/false; default=true)
cluster.replayProtection.multicast.enabled.default = true
cluster.replayProtection.multicast.enabled.clusterProperty = cluster.replayProtection.multicast.enabled
cluster.replayProtection.multicast.enabled.systemProperty = ${propertyPrefix}.cluster.replayProtection.multicast.enabled
cluster.replayProtection.multicast.enabled.validation.regex = ${regex.boolean}

# ldap templates path
ldapTemplatesPath.description = LDAP templates path
ldapTemplatesPath.systemProperty = ${propertyPrefix}.ldapTemplatesPath

# uddi templates path
uddiTemplatesPath.description = UDDI templates path
uddiTemplatesPath.systemProperty = ${propertyPrefix}.uddiTemplatesPath

# FIPS and non-FIPS software provider paths
ssg.crypto.fipsLib.default = ${ssg.libalt}${fs}jcmFIPS-6.1.jar
ssg.crypto.fipsLib.systemProperty = com.l7tech.security.prov.rsa.libpath.fips
ssg.crypto.nonFipsLib.default = ${ssg.libalt}${fs}jcm-6.1.jar
ssg.crypto.nonFipsLib.systemProperty = com.l7tech.security.prov.rsa.libpath.nonfips

# directory for ssg log files
logDirectory.description = Directory for SSG log files
logDirectory.default = ${ssg.var}${fs}logs
logDirectory.systemProperty = ${propertyPrefix}.logDirectory

# template for log file pattern
#  0 - "default_"
#  1 - sink name (e.g. "ssg")
#  2 - "%g" the generation number to distinguish rotated logs
#  3 - "%u" a unique number to resolve conflicts
logFileTemplate.description = Template for log filename pattern ('{1}' is sink name, '{2}' the generation number to distinguish rotated logs, '{3}' a unique number to resolve file conflicts)
logFileTemplate.default = {1}_{2}_{3}.log
logFileTemplate.systemProperty = ${propertyPrefix}.logFileTemplate
logFileTemplate.clusterProperty = log.filenameTemplate

# customized logger levels
logLevels.description = Log level configuration (one level per line)
logLevels.default = com.l7tech.level = CONFIG
logLevels.clusterProperty = log.levels

logStdOutLevel.description = Log level to use for logging of messages captured from standard output (FINEST|FINER|FINE|INFO|WARNING|SEVERE)
logStdOutLevel.default = INFO
logStdOutLevel.clusterProperty = log.stdoutLevel
logStdOutLevel.validation.regex = FINEST|FINER|FINE|INFO|WARNING|SEVERE

logStdErrLevel.description = Log level to use for logging of messages captured from standard error (FINEST|FINER|FINE|INFO|WARNING|SEVERE)
logStdErrLevel.default = WARNING
logStdErrLevel.clusterProperty = log.stderrLevel
logStdErrLevel.validation.regex = FINEST|FINER|FINE|INFO|WARNING|SEVERE

# Allows use of a cluster property to override the JceProvider engine
security.jceProviderEngineName.description=Override JceProvider engine name, or empty for no override (engine name; default empty)
security.jceProviderEngineName.visible=false
security.jceProviderEngineName.systemProperty=com.l7tech.common.security.jceProviderEngineName
security.jceProviderEngineName.clusterProperty=security.jceProviderEngineName

# comma-separated list of IP addresses (defaults to all)
ipAddresses.description = IP addresses
ipAddresses.systemProperty = ${propertyPrefix}.ipAddresses

#
# The defaultHttpPort and defaultHttpsPort are kept up-to-date dynamically by the
# SsgConnectorManager, pointing at an HTTP or HTTPS port (respectively) that has
# the service OTHER_SERVLETS enabled, or removed completely whenever an appropriate
# connector doesn't exist.
#
defaultHttpPort.default = 8080
defaultHttpPort.mutable = true
httpPort.description = HTTP listening port for built-in services
httpPort.default = ${defaultHttpPort}
httpPort.systemProperty = ${propertyPrefix}.httpPort

defaultHttpsPort.default = 8443
defaultHttpsPort.mutable = true
httpsPort.description = HTTPS listening port for built-in services
httpsPort.default = ${defaultHttpsPort}
httpsPort.systemProperty = ${propertyPrefix}.httpsPort

interfaceTags.visible = false
interfaceTags.description = Available named interfaces and their corresponding address pattern lists.  This is intended to be edited using the special GUI in the SSM.
interfaceTags.default = loopback(127.0.0.1)
interfaceTags.clusterProperty = interfaceTags

httpSessionName.default = ssgsessionid
httpSessionName.description = Session parameter and cookie name to be used by tomcat for session identification.
httpSessionName.systemProperty = ${propertyPrefix}.httpSessionId

#
# The port used for internode communications in a cluster
#
clusterPortOld.visible = false
clusterPortOld.description = Inter-Node communication port for clusters
clusterPortOld.default = 0
clusterPortOld.clusterProperty = cluster.internodePort
clusterPortOld.validation.type = integer
clusterPortOld.validation.min = 0
clusterPortOld.validation.max = 65535

clusterNodePort.description = Inter-Node communication port for clusters
clusterNodePort.default = 2124
clusterNodePort.mutable = true

clusterAdminAppletPort.description = The port used for Browser-based Administration.
clusterAdminAppletPort.default = 9443
clusterAdminAppletPort.clusterProperty = cluster.adminAppletPort
clusterAdminAppletPort.mutable = true
clusterAdminAppletPort.validation.type = integer
clusterAdminAppletPort.validation.min = 1
clusterAdminAppletPort.validation.max = 65535

#
# The host used for accessing the cluster
#
defaultClusterHost.default =
defaultClusterHost.systemProperty = com.l7tech.server.defaultClusterHostname

clusterHost.description = External hostname for the cluster
clusterHost.default = ${defaultClusterHost}
clusterHost.clusterProperty = cluster.hostname

#
# Following two settings should be modified if the cluster is configured in such a
# way that port forwarding is used
#
clusterhttpport.description = External HTTP port for the cluster
clusterhttpport.default = ${httpPort}
clusterhttpport.systemProperty = ${propertyPrefix}.clusterHttpPort
clusterhttpport.clusterProperty = cluster.httpPort
clusterhttpport.validation.type = integer
clusterhttpport.validation.min = 1
clusterhttpport.validation.max = 65535

clusterhttpsport.description = External HTTPS port for the cluster
clusterhttpsport.default = ${httpsPort}
clusterhttpsport.systemProperty = ${propertyPrefix}.clusterHttpsPort
clusterhttpsport.clusterProperty = cluster.httpsPort
clusterhttpsport.validation.type = integer
clusterhttpsport.validation.min = 1
clusterhttpsport.validation.max = 65535

clusterMasterNode.description = The identifier of the master node in the cluster.
clusterMasterNode.clusterProperty = cluster.masterNodeId
clusterMasterNode.visible = false

# hostname (defaults to OS hostname)
hostname.description = Hostname
hostname.systemProperty = ${propertyPrefix}.hostname

# system properties path
systemPropertiesPath.description = System properties path
systemPropertiesPath.default = ${configDirectory}${fs}system.properties
systemPropertiesPath.systemProperty = ${propertyPrefix}.systemPropertiesPath

#custom assertions (file name or resource name)
custom.assertions.file=custom_assertions.properties
custom.assertions.modules=${ssg.run}${fs}modules${fs}lib
custom.assertions.temp=${ssg.var}${fs}modules

# ldap fallback timeout
# the time (in ms) for which the ldap connector will not try to reconnect to
# a particular ldap url when the connection failed
ldap.reconnect.timeout = 60000

ldapConnectionTimeout.description = LDAP connection timeout.  A value less than or equal to zero seconds means to use the network protocol's (i.e., TCP's) timeout value.
ldapConnectionTimeout.default = 5s
ldapConnectionTimeout.clusterProperty = ldap.connection.timeout
ldapConnectionTimeout.validation.type = timeUnit

ldapReadTimeout.description =  LDAP read timeout.  A value less than or equal to zero seconds means it will wait for the response infinitely until it is received.
ldapReadTimeout.default = 30s
ldapReadTimeout.clusterProperty = ldap.read.timeout
ldapReadTimeout.validation.type = timeUnit

ldapSimpleUsernamePattern.description = Regular expression that any username must match when being combined into a DN using the Simple LDAP provider.
ldapSimpleUsernamePattern.default = ^[\\p{Alnum}\\.\\-\\_]+$
ldapSimpleUsernamePattern.clusterProperty = ldap.simple.username.pattern

ldapReferral.description = How LDAP referrals should be handled.  Possible values are "follow" or "ignore". (default=follow)
ldapReferral.default = follow
ldapReferral.clusterProperty = ldap.referral
ldapReferral.validation.regex = follow|ignore|throw

ldapIgnorePartialResultException.description = Whether a PartialResultException should be ignored if encountered while iterating an LDAP search result. (default=true)
ldapIgnorePartialResultException.systemProperty = ${propertyPrefix}.ldap.ignorePartialResultException
ldapIgnorePartialResultException.default = true
ldapIgnorePartialResultException.validation.regex = ${regex.boolean}

# serverconfig name must be same as cluster property name for this property
trace.policy.guid.description = GUID of internal policy to invoke after each assertion finished, when debug tracing is enabled for a published service (default=empty)
trace.policy.guid.default =
trace.policy.guid.clusterProperty = trace.policy.guid
trace.policy.guid.visible = false

# Audit settings
audit.external.name.description = Name of the datasource to use for external audit persistence.
audit.external.name.default =
audit.external.name.clusterProperty = audit.external.name

audit.sink.policy.guid.description = GUID of internal policy to invoke when flushing audit messages, or empty to use internal audit database (default=empty)
audit.sink.policy.guid.default =
audit.sink.policy.guid.clusterProperty = audit.sink.policy.guid
audit.sink.policy.guid.visible = false

audit.lookup.policy.guid.description = GUID of internal policy to invoke when retrieving audit messages from an external source, or empty to use internal audit database (default=empty)
audit.lookup.policy.guid.default =
audit.lookup.policy.guid.clusterProperty = audit.lookup.policy.guid
audit.lookup.policy.guid.visible = false

audit.sink.alwaysSaveInternal.description = If true, audit records will always be saved to the internal database, even if they were successfully processed via a configured audit sink policy. (default=false)
audit.sink.alwaysSaveInternal.default = false
audit.sink.alwaysSaveInternal.clusterProperty = audit.sink.alwaysSaveInternal
audit.sink.alwaysSaveInternal.visible = false
audit.sink.alwaysSaveInternal.validation.regex = ${regex.boolean}

audit.sink.fallbackToInternal.description = If true, audit records will be saved to the internal database if auditing to a configured audit sink fails.  If false, an error message will be logged and the audit record will be lost. (default=true)
audit.sink.fallbackToInternal.default = true
audit.sink.fallbackToInternal.clusterProperty = audit.sink.fallbackToInternal
audit.sink.fallbackToInternal.validation.regex = ${regex.boolean}

audit.sink.url.description = Default URL to which audit records will be posted via HTTP, if the default audit sink policy is enabled.  (default = http://localhost:4680/ )
audit.sink.url.default = http://localhost:4680/
audit.sink.url.clusterProperty = audit.sink.url

audit.lockMessages.description = Should audit messages be locked after registration of known messages (boolean)
audit.lockMessages.default = true
audit.lockMessages.systemProperty = com.l7tech.gateway.common.audit.lockMessages

auditMessageThreshold.description = Minimum level required of a Message Audit Record for it to be saved to the database (Level)
auditMessageThreshold.default = WARNING
auditMessageThreshold.systemProperty = ${propertyPrefix}.audit.messageThreshold
auditMessageThreshold.clusterProperty = audit.messageThreshold

auditAdminThreshold.description = Minimum level required of an Admin Audit Record for it to be saved to the database (Level)
auditAdminThreshold.default = INFO
auditAdminThreshold.systemProperty = ${propertyPrefix}.audit.adminThreshold
auditAdminThreshold.clusterProperty = audit.adminThreshold

# associated logs threshold
auditAssociatedLogsThreshold.default = INFO
auditAssociatedLogsThreshold.description = Minimum level required of an Audit Detail Message for it to be saved to the database (Level)
auditAssociatedLogsThreshold.clusterProperty = audit.detailThreshold

# client component system logs threshold
auditClientSystemLogsThreshold.default = WARNING
auditClientSystemLogsThreshold.description = Minimum level required of an System Audit Record for a client component for it to be saved to the database (Level)
auditClientSystemLogsThreshold.clusterProperty = audit.clientServicesThreshold

auditHintingEnabled.description = Enable audit messages to provide hints for audited information, such as request XML (true/false)
auditHintingEnabled.default = false
auditHintingEnabled.systemProperty = ${propertyPrefix}.audit.hinting
auditHintingEnabled.clusterProperty = audit.hinting
auditHintingEnabled.validation.regex = ${regex.boolean}

auditAssertionStatusEnabled.description = Use the highest assertion status level when checking if a record should be saved (true/false)
auditAssertionStatusEnabled.default = true
auditAssertionStatusEnabled.systemProperty = ${propertyPrefix}.audit.assertionStatus
auditAssertionStatusEnabled.clusterProperty = audit.assertionStatus
auditAssertionStatusEnabled.validation.regex = ${regex.boolean}

auditAssociatedLogsThresholdRespected.description = Use the audit detail level when checking if a record should be saved (true/false)
auditAssociatedLogsThresholdRespected.default = true
auditAssociatedLogsThresholdRespected.systemProperty = ${propertyPrefix}.audit.detailThresholdRespected
auditAssociatedLogsThresholdRespected.clusterProperty = audit.detailThresholdRespected
auditAssociatedLogsThresholdRespected.validation.regex = ${regex.boolean}

# audit logging format
auditLogFormatServiceHeader.description = Format for the first log message of a service audit
auditLogFormatServiceHeader.default = Processing request for service: {3}
auditLogFormatServiceHeader.clusterProperty = audit.log.service.headerFormat

auditLogFormatServiceFooter.description = Format for the final (summary) log message of a service audit
auditLogFormatServiceFooter.default = {1}
auditLogFormatServiceFooter.clusterProperty = audit.log.service.footerFormat

auditLogFormatServiceDetail.description = Format for details related to a service audit
auditLogFormatServiceDetail.default = {0}: {1}
auditLogFormatServiceDetail.clusterProperty = audit.log.service.detailFormat

auditLogFormatOther.description = Format used for other (non-service) audit logs (i.e. System/Admin audits)
auditLogFormatOther.default = {1}
auditLogFormatOther.clusterProperty = audit.log.other.format

auditLogFormatOtherDetail.description = Format used for other (non-service) audit details (i.e. System/Admin audits)
auditLogFormatOtherDetail.default = {0}: {1}
auditLogFormatOtherDetail.clusterProperty = audit.log.other.detailFormat

# default = 1 week
auditPurgeMinimumAge.description = Minimum age of Audit Records that can be purged (Hours)
auditPurgeMinimumAge.default = 168
auditPurgeMinimumAge.systemProperty = ${propertyPrefix}.audit.purgeMinimumAge
auditPurgeMinimumAge.clusterProperty = audit.purgeMinimumAge
auditPurgeMinimumAge.validation.type = integer

auditSigningEnabled.description = Sign audited data (true/false)
auditSigningEnabled.default = false
auditSigningEnabled.systemProperty = ${propertyPrefix}.audit.sign
auditSigningEnabled.clusterProperty = audit.signing
auditSigningEnabled.validation.regex = ${regex.boolean}

auditBatchExternal.description = Should audit information be batched when logging (true/false)
auditBatchExternal.default = true
auditBatchExternal.systemProperty = ${propertyPrefix}.audit.batchExternal
auditBatchExternal.clusterProperty = audit.batchExternal
auditBatchExternal.validation.regex = ${regex.boolean}

audit.originalMainPart.enable.description = Enable saving the original document for requests and responses.  This enables use of the .originalMainPart suffix for Message variables.  Note: Enabling this option reduces performance and may double the quantity of memory used during message processing.  Consider reducing the maximum concurrency to compensate. (true/false; default = false)
audit.originalMainPart.enable.default = false
audit.originalMainPart.enable.systemProperty = com.l7tech.message.enableOriginalDocument
audit.originalMainPart.enable.clusterProperty = audit.originalMainPart.enable
audit.originalMainPart.enable.validation.regex = ${regex.boolean}

audit.adminExceptions.auditPermissionDenied.description = Should permission denials for administrative users be audited (true/false)
audit.adminExceptions.auditPermissionDenied.default = true
audit.adminExceptions.auditPermissionDenied.clusterProperty = audit.adminExceptions.auditPermissionDenied
audit.adminExceptions.auditPermissionDenied.visible = false
audit.adminExceptions.auditPermissionDenied.validation.regex = ${regex.boolean}

audit.adminExceptions.excludes.description = List of exception classes that should be excluded from auditing during administrative calls (space separated list)
audit.adminExceptions.excludes.default =
audit.adminExceptions.excludes.clusterProperty = audit.adminExceptions.excludes
audit.adminExceptions.excludes.visible = false

logBuffer.messageSize.description = Maximum permitted size for unformatted log message (characters)
logBuffer.messageSize.default = 4096
logBuffer.messageSize.systemProperty = ${propertyPrefix}.logBuffer.messageSize
logBuffer.messageSize.clusterProperty = log.buffer.messageSizeLimit
logBuffer.messageSize.validation.type = integer

logBuffer.paramSize.description = Maximum permitted size for unformatted log message parameter (characters)
logBuffer.paramSize.default = 4096
logBuffer.paramSize.systemProperty = ${propertyPrefix}.logBuffer.paramSize
logBuffer.paramSize.clusterProperty = log.buffer.parameterSizeLimit
logBuffer.paramSize.validation.type = integer

auditArchiverTimerPeriod.description = Time period in seconds for scheduling the AuditArchiver task, or 0 to disable.
auditArchiverTimerPeriod.default = 600
auditArchiverTimerPeriod.clusterProperty = audit.archiverTimerPeriod
auditArchiverTimerPeriod.validation.type = integer

auditArchiverStaleTimeout.description = Timeout, in minutes, after which an "in progress" archive job is considered stale and dead, so that other nodes can steal the lock.
auditArchiverStaleTimeout.default = 120
auditArchiverStaleTimeout.clusterProperty = audit.archiverStaleTimeout
auditArchiverStaleTimeout.validation.type = integer

auditArchiverBatchSize.description = Number of audit records to be processed by one archiver job. Max 10000.
auditArchiverBatchSize.default = 1000
auditArchiverBatchSize.clusterProperty = audit.archiverBatchSize
auditArchiverBatchSize.validation.type = integer
auditArchiverBatchSize.validation.max = 10000

auditArchiverInProgress.description = Used as the underlying mechanism with the ClusterLock; not exposed in the UI.
auditArchiverInProgress.default =
auditArchiverInProgress.clusterProperty = audit.archiverInProgress
auditArchiverInProgress.visible = false

auditArchiverShutdownThreshold.description = The AuditArchiver will put the SSG in "no processing" mode when database disk usage (percentage) is above this threshold.
auditArchiverShutdownThreshold.default = 90
auditArchiverShutdownThreshold.clusterProperty = audit.archiverShutdownThreshold
auditArchiverShutdownThreshold.validation.type = integer
auditArchiverShutdownThreshold.validation.min = 0
auditArchiverShutdownThreshold.validation.max = 100

auditArchiverWarningThreshold.description = The AuditArchiver will issue an early warning to alert users if the current database usage (percent) is above this threshold.
auditArchiverWarningThreshold.default = 50
auditArchiverWarningThreshold.clusterProperty = audit.archiverWarningThreshold
auditArchiverWarningThreshold.validation.type = integer
auditArchiverWarningThreshold.validation.min = 0
auditArchiverWarningThreshold.validation.max = 100

auditArchiverStartThreshold.description = Archiving of audit records will start when database disk usage (percentage) is above this threshold.
auditArchiverStartThreshold.default = 75
auditArchiverStartThreshold.clusterProperty = audit.archiverStartThreshold
auditArchiverStartThreshold.validation.type = integer
auditArchiverStartThreshold.validation.min = 0
auditArchiverStartThreshold.validation.max = 100

auditArchiverStopThreshold.description = Archiving of audit records will stop when database disk usage (percentage) drops below this threshold.
auditArchiverStopThreshold.default = 50
auditArchiverStopThreshold.clusterProperty = audit.archiverStopThreshold
auditArchiverStopThreshold.validation.type = integer
auditArchiverStopThreshold.validation.min = 0
auditArchiverStopThreshold.validation.max = 100

auditArchiverFtpConfig.description = The serialized form of the FTP configuration where the archiver backs up the audit logs; not exposed in UI.
auditArchiverFtpConfig.default =
auditArchiverFtpConfig.clusterProperty = audit.archiver.ftp.config
auditArchiverFtpConfig.visible = false

auditArchiverFtpFileprefix.description = The prefix for the audit archives file to be uploaded.
auditArchiverFtpFileprefix.default = SSGAuditArchive-
auditArchiverFtpFileprefix.clusterProperty = audit.archiver.ftp.fileprefix

auditArchiverFtpMaxUploadFileSize.description = Maximum file size to be uploaded (bytes). Should be large enough to accommodate the largest audit record, and smaller than the FTP server's filesize limit, if any.
auditArchiverFtpMaxUploadFileSize.default = 2000000000
auditArchiverFtpMaxUploadFileSize.clusterProperty = audit.archiver.ftp.maxfilesize
auditArchiverFtpMaxUploadFileSize.validation.type = long

# default = /ssg/var/attachments
attachmentDirectory.description = Directory in which to cache large SOAP attachments
attachmentDirectory.default = ${ssg.var}${fs}attachments
attachmentDirectory.systemProperty = ${propertyPrefix}.attachmentDirectory

# default = /ssg/var/messageCache
messageCacheDirectory.description = Directory in which to cache large response messages from the backend
messageCacheDirectory.default = ${ssg.var}${fs}messageCache
messageCacheDirectory.systemProperty = ${propertyPrefix}.messageCacheDirectory

# default = /ssg/modules/assertions
modularAssertionsDirectory.description = Directory in which to find modular assertion jarfiles
modularAssertionsDirectory.default = ${ssg.run}${fs}modules${fs}assertions
modularAssertionsDirectory.systemProperty = ${propertyPrefix}.modularAssertionsDirectory

modularAssertionsRescanMillis.description = Milliseconds in between checks to see if the modules directory timestamp has changed
modularAssertionsRescanMillis.default = 4523
modularAssertionsRescanMillis.systemProperty = ${propertyPrefix}.modularAssertionsRescanMillis

modularAssertionsFileExtensions.description = Space separated list of file extensions (including leading dot) that will be considered as modular assertions.  Set to a single dash to disable scanning for modules
modularAssertionsFileExtensions.default = .jar .assertion .ass .assn .aar
modularAssertionsFileExtensions.systemProperty = ${propertyPrefix}.modularAssertionsFileExtensions

# default = 131071
attachmentDiskThreshold.description = Threshold for size of attachments in a single request to keep in RAM (Bytes)
attachmentDiskThreshold.default = 1048576
attachmentDiskThreshold.systemProperty = ${propertyPrefix}.attachmentDiskThreshold
attachmentDiskThreshold.clusterProperty = attachment.diskThreshold
attachmentDiskThreshold.validation.type = integer

# default = 9096
messageCacheDiskThreshold.description = Threshold for size of messages to be cached on disk (Bytes)
messageCacheDiskThreshold.default = 8096
messageCacheDiskThreshold.systemProperty = ${propertyPrefix}.messageCacheDiskThreshold
messageCacheDiskThreshold.clusterProperty = messageCache.diskThreshold
messageCacheDiskThreshold.validation.type = integer

messageCacheResetGeneration.description = Incrementing the generation number clears all message caches created under a different generation number.
messageCacheResetGeneration.default = 0
messageCacheResetGeneration.systemProperty = ${propertyPrefix}.messageCacheResetGeneration
messageCacheResetGeneration.clusterProperty = messageCache.resetGeneration

# Symantec AntiVirus ScanEngine (savseEnable = yes to enable scanning)
savseEnable.description = Whether or not this gateway has access to a sav scan engine to do virus scanning
savseEnable.default = no
savseEnable.systemProperty = ${propertyPrefix}.savseEnable

# The hostname of the sav se
savseHost.description = The hostname of the sav scan engine that this gateway can connect to
savseHost.default = 127.0.0.1
savseHost.systemProperty = ${propertyPrefix}.savseHost

# The port of the sav se
savsePort.description = The port number associated with the savseHost property
savsePort.default = 7777
savsePort.systemProperty = ${propertyPrefix}.savsePort

metricsFineInterval.description = Time interval for Service Metrics fine resolution bins (Milliseconds). (Note: A cluster-wide restart is required for changes to apply.)
metricsFineInterval.default = 5000
metricsFineInterval.systemProperty = com.l7tech.service.metrics.fineBinInterval
metricsFineInterval.clusterProperty = metrics.fineInterval
metricsFineInterval.validation.type = long

# passthrough filter for wsdl and policy downloads (requests for such documents will not require authentication
# if they come from an ip address below mentioned)
# for example, a value could look like "127.0.0.1 192.168" and would allow localhost as well as anything starting with 192.168
passthroughDownloads.description = Remote IPs of requestors allowed to download WSDL and policy documents without credentials (Space separated list)
passthroughDownloads.default = 127.0.0.1
passthroughDownloads.systemProperty = com.l7tech.service.passthroughdownloads
passthroughDownloads.clusterProperty = service.passthroughdownloads

service.disabledServiceDownloads.description = Which requestors can download WSDL and policy documents for disabled services. Use "none" to forbid, "all" for all requestors or "passthrough" to permit requestors defined by "service.passthroughdownloads" (none|passthrough|all)
service.disabledServiceDownloads.default = none
service.disabledServiceDownloads.clusterProperty = service.disabledDownloads
service.disabledServiceDownloads.validation.regex = none|all|passthrough

service.anonFederatedPolicies.description = Treat policies containing all federated identity assertions as though they contained no identity assertions, for purposes of checking whether a policy allows anonymous access.  In an identity bridging use case, this allows an XVC from another trust domain to download the policy for a federated service.  (true/false)
service.anonFederatedPolicies.default = true
service.anonFederatedPolicies.clusterProperty = service.anonFederatedPolicies
service.anonFederatedPolicies.validation.regex = ${regex.boolean}

# IO timeout settings
ioInReadTimeout.description = IO timeout for incoming requests (Milliseconds)
ioInReadTimeout.default = 60000
ioInReadTimeout.systemProperty = ${propertyPrefix}.timeout
ioInReadTimeout.clusterProperty = io.timeout
ioInReadTimeout.validation.type = long

ioInSlowReadThreshold.description = IO timeout for incoming request rate checking (Milliseconds)
ioInSlowReadThreshold.default = 60000
ioInSlowReadThreshold.systemProperty = ${propertyPrefix}.rateTimeout
ioInSlowReadThreshold.clusterProperty = io.rateTimeout
ioInSlowReadThreshold.validation.type = long

ioInSlowReadRate.description = Minimum permissible rate for incoming requests (Bytes per second)
ioInSlowReadRate.default = 1024
ioInSlowReadRate.systemProperty = ${propertyPrefix}.rateLimit
ioInSlowReadRate.clusterProperty = io.rateLimit
ioInSlowReadRate.validation.type = long

ioOutConnectionTimeout.description = IO timeout for outbound connection (Milliseconds)
ioOutConnectionTimeout.default = 30000
ioOutConnectionTimeout.systemProperty = ${propertyPrefix}.outConnectTimeout
ioOutConnectionTimeout.clusterProperty = io.outConnectTimeout
ioOutConnectionTimeout.validation.type = long

ioOutReadTimeout.description = IO timeout for outbound response (Milliseconds)
ioOutReadTimeout.default = 60000
ioOutReadTimeout.systemProperty = ${propertyPrefix}.outTimeout
ioOutReadTimeout.clusterProperty = io.outTimeout
ioOutReadTimeout.validation.type = long

ioFailoverServerRetryDelay.description = The delay before retrying a failed server when using a "Round-Robin" or "Ordered Sticky with Failover" failover strategy. This setting is used by assertions with a failover strategy such as the Route via HTTP(S), Route via SecureSpan Bridge, and Scan Using ICAP-Enabled Antivirus assertions. A value of zero means the default delay for the selected failover strategy is used (Milliseconds)
ioFailoverServerRetryDelay.default = 0
ioFailoverServerRetryDelay.clusterProperty = io.failoverServerRetryDelay
ioFailoverServerRetryDelay.systemProperty = com.l7tech.common.io.failover.robin.retryMillis
ioFailoverServerRetryDelay.validation.type = integer
ioFailoverServerRetryDelay.validation.min = 0

ioHttpsHostVerify.description = Verify server host names against certificate name (true/false)
ioHttpsHostVerify.default = true
ioHttpsHostVerify.clusterProperty = io.httpsHostVerify
ioHttpsHostVerify.validation.regex = ${regex.boolean}

ioHttpsHostAllowWildcard.description = Allow wildcards when verifying hostnames (true/false)
ioHttpsHostAllowWildcard.default = false
ioHttpsHostAllowWildcard.clusterProperty = io.httpsHostAllowWildcard
ioHttpsHostAllowWildcard.validation.regex = ${regex.boolean}

ioHttpsAcceptedClientCa.description = A list of certificate PEM strings, delimited with the character ','. When set, this will be presented by the SSL listeners as a list of trusted client CA names.
ioHttpsAcceptedClientCa.clusterProperty=io.httpsAcceptedClientCa
ioHttpsAcceptedClientCa.systemProperty=com.l7tech.security.ssl.acceptedclientca
ioHttpsAcceptedClientCa.visible=false

io.https.response.truncationProtection.disable.description = Set to true to disable response truncation attack protection for outbound HTTPS.  (true/false; default=false)
io.https.response.truncationProtection.disable.default = false
io.https.response.truncationProtection.disable.clusterProperty = io.https.response.truncationProtection.disable
io.https.response.truncationProtection.disable.validation.regex = ${regex.boolean}

ioHttpUseExpectContinue.description = Use an HTTP 1.1 Expect/Continue handshake (true/false)
ioHttpUseExpectContinue.default = false
ioHttpUseExpectContinue.clusterProperty = io.httpExpectContinue
ioHttpUseExpectContinue.validation.regex = ${regex.boolean}

ioHttpNoKeepAlive.description = Disable HTTP Keep-Alive connections for outbound HTTP connections (other than routing assertions) (true/false)
ioHttpNoKeepAlive.default = false
ioHttpNoKeepAlive.clusterProperty = io.httpDisableKeepAlive
ioHttpNoKeepAlive.validation.regex = ${regex.boolean}

ioHttpHeadersToSkip.description = List of HTTP headers to skip when passing outbound request or inbound response headers (comma-separated list)
ioHttpHeadersToSkip.default = Connection, Content-Encoding, Content-Length, Content-Type, Date, Keep-Alive, Server, Transfer-Encoding
ioHttpHeadersToSkip.clusterProperty = io.httpHeadersToSkip
ioHttpHeadersToSkip.systemProperty = com.l7tech.policy.assertion.HttpPassthroughRuleSet.headersToSkip
ioHttpHeadersToSkip.visible = false

ioHttpVersion.description = The HTTP version to use (1.0/1.1)
ioHttpVersion.default = 1.1
ioHttpVersion.clusterProperty = io.httpVersion
ioHttpVersion.validation.regex = 1.0|1.1

ioHttpDefaultContentType.description = The value of the "Content-Type" HTTP header to use if a response does not have a "Content-Type" header (no default value).
ioHttpDefaultContentType.clusterProperty = io.httpDefaultContentType
ioHttpDefaultContentType.systemProperty = ${propertyPrefix}.ioHttpDefaultContentType

ioHttpResponseStreaming.description = True to allow streaming of HTTP responses when possible (true/false, default true)
ioHttpResponseStreaming.default = true
ioHttpResponseStreaming.clusterProperty = io.httpResponseStreaming
ioHttpResponseStreaming.validation.regex = ${regex.boolean}

ioHttpResponseStreamUnlimited.description = Ignore the message size limit when streaming HTTP responses (true/false, default true)
ioHttpResponseStreamUnlimited.default = true
ioHttpResponseStreamUnlimited.clusterProperty = io.httpResponseStreamUnlimited
ioHttpResponseStreamUnlimited.validation.regex = ${regex.boolean}
ioHttpResponseStreamUnlimited.visible = false

ioHttpPoolMaxIdleTime.description = Time an idle thread will wait for additional work before shutting down (milliseconds)
ioHttpPoolMaxIdleTime.default = 60000
ioHttpPoolMaxIdleTime.systemProperty = ${propertyPrefix}.ioHttpPoolMaxIdleTime
ioHttpPoolMaxIdleTime.validation.type = long

ioHttpPoolMaxConcurrency.description = Maximum number of concurrent active HTTP connections.  This is a hard upper limit.
ioHttpPoolMaxConcurrency.default = 215
ioHttpPoolMaxConcurrency.systemProperty = ${propertyPrefix}.ioHttpPoolMaxConcurrency
ioHttpPoolMaxConcurrency.clusterProperty = io.httpMaxConcurrency
ioHttpPoolMaxConcurrency.validation.type = integer

ioHttpPoolMinSpareThreads.description = Core number of concurrent active HTTP connections.  This is a soft limit that can be temporarily exceeded if necessary.  A negative number means to use a fraction of io.httpMaxConcurrency (ie, -5 would mean one fifth of the maximum).
ioHttpPoolMinSpareThreads.default = 185
ioHttpPoolMinSpareThreads.systemProperty = ${propertyPrefix}.ioHttpPoolMinSpareThreads
ioHttpPoolMinSpareThreads.clusterProperty = io.httpCoreConcurrency
ioHttpPoolMinSpareThreads.validation.type = integer

ioHttpProxy.description = Default HTTP Proxy configuration.
ioHttpProxy.systemProperty = ${propertyPrefix}.ioHttpProxy
ioHttpProxy.clusterProperty = ioHttpProxy
ioHttpProxy.visible = false

ioHttpConnectionIdleInterval.description = Interval between checks for outbound HTTP connection timeout (timeunit)
ioHttpConnectionIdleInterval.default = 5s
ioHttpConnectionIdleInterval.systemProperty = com.l7tech.server.transport.http.httpConnectionIdleInterval
ioHttpConnectionIdleInterval.clusterProperty = io.httpConnectionIdleInterval
ioHttpConnectionIdleInterval.validation.type = timeUnit
ioHttpConnectionIdleInterval.visible = false

ioHttpConnectionIdleTimeout.description = Maximum idle time for outbound HTTP connections, 0 for no timeout (timeunit)
ioHttpConnectionIdleTimeout.default = 0s
ioHttpConnectionIdleTimeout.systemProperty = com.l7tech.server.transport.http.httpConnectionIdleTimeout
ioHttpConnectionIdleTimeout.clusterProperty = io.httpConnectionIdleTimeout
ioHttpConnectionIdleTimeout.validation.type = timeUnit
ioHttpConnectionIdleTimeout.visible = false

ioHttpConnectionTestingEnabled.description = Should idle outbound HTTP connections be tested to ensure they are valid (boolean)
ioHttpConnectionTestingEnabled.default = true
ioHttpConnectionTestingEnabled.systemProperty = com.l7tech.common.http.prov.apache.staleCheckEnabled
ioHttpConnectionTestingEnabled.clusterProperty = io.httpConnectionTestingEnabled
ioHttpConnectionTestingEnabled.validation.regex = ${regex.boolean}
ioHttpConnectionTestingEnabled.visible = false

ioJmsErrorSleep.description = Time to sleep after a connection error for an inbound JMS Queue (timeunit)
ioJmsErrorSleep.default = 60s
ioJmsErrorSleep.clusterProperty = jms.connectErrorSleep
ioJmsErrorSleep.validation.type = timeUnit

ioJmsResponseTimeout.description = Timeout for JMS routing to wait on the replyTo queue in milliseconds, default 10 seconds.
ioJmsResponseTimeout.default = 10000
ioJmsResponseTimeout.clusterProperty = jms.responseTimeout
ioJmsResponseTimeout.validation.type = long

ioJmsConnectionCacheMaxAge.description = Maximum age for cached JMS connections or 0 for no limit (timeunit)
ioJmsConnectionCacheMaxAge.default = 10m
ioJmsConnectionCacheMaxAge.clusterProperty = io.jmsConnectionCacheMaxAge
ioJmsConnectionCacheMaxAge.validation.type = timeUnit

ioJmsConnectionCacheMaxIdleTime.description = The maximum time an idle JMS connection will be cached or 0 for no limit (timeunit)
ioJmsConnectionCacheMaxIdleTime.default = 5m
ioJmsConnectionCacheMaxIdleTime.clusterProperty = io.jmsConnectionCacheMaxIdleTime
ioJmsConnectionCacheMaxIdleTime.validation.type = timeUnit

ioJmsConnectionCacheSize.description = The number of JMS connections to cache, this is not a hard limit, 0 for no caching (Integer)
ioJmsConnectionCacheSize.default = 100
ioJmsConnectionCacheSize.clusterProperty = io.jmsConnectionCacheMaxSize
ioJmsConnectionCacheSize.validation.type = integer

ioJmsEndpointListenerFactory.description = The endpoint listener type to use (Simple|Pooled)
ioJmsEndpointListenerFactory.default = Pooled
ioJmsEndpointListenerFactory.clusterProperty = io.jmsEndpointListenerFactory
ioJmsEndpointListenerFactory.visible = false

ioJmsMessageMaxBytes.description = Maximum number of bytes permitted for a JMS message, or 0 for unlimited (Integer)
ioJmsMessageMaxBytes.default = 2621440
ioJmsMessageMaxBytes.systemProperty = ${propertyPrefix}.jmsMessageMaxBytes
ioJmsMessageMaxBytes.clusterProperty = io.jmsMessageMaxBytes
ioJmsMessageMaxBytes.validation.type = long
ioJmsMessageMaxBytes.validation.min = 0

ioJmsRoutingRetrySleep.description = Time to sleep after a connection error for an outbound JMS Queue (timeunit)
ioJmsRoutingRetrySleep.default = 1s
ioJmsRoutingRetrySleep.systemProperty = com.l7tech.server.policy.assertion.jmsRoutingRetryDelay
ioJmsRoutingRetrySleep.clusterProperty = io.jmsRoutingRetrySleep
ioJmsRoutingRetrySleep.validation.type = timeUnit
ioJmsRoutingRetrySleep.validation.min = 0

ioJmsRoutingMaxRetries.description = Maximum number of connection attempts for an outbound JMS Queue.
ioJmsRoutingMaxRetries.default = 5
ioJmsRoutingMaxRetries.systemProperty = com.l7tech.server.policy.assertion.jmsRoutingMaxRetries
ioJmsRoutingMaxRetries.clusterProperty = io.jmsRoutingMaxRetries
ioJmsRoutingMaxRetries.validation.type = integer
ioJmsRoutingMaxRetries.validation.min = 1

ioMqRoutingRetrySleep.description = Time to sleep after a connection error for an outbound MQ Queue (timeunit)
ioMqRoutingRetrySleep.default = 1s
ioMqRoutingRetrySleep.systemProperty = com.l7tech.external.assertions.mqnative.server.routingRetryDelay
ioMqRoutingRetrySleep.clusterProperty = io.mqRoutingRetrySleep
ioMqRoutingRetrySleep.validation.type = timeUnit
ioMqRoutingRetrySleep.validation.min = 0

ioMqRoutingMaxRetries.description = Maximum number of connection attempts for an outbound MQ Queue.
ioMqRoutingMaxRetries.default = 5
ioMqRoutingMaxRetries.systemProperty = com.l7tech.external.assertions.mqnative.server.routingMaxRetries
ioMqRoutingMaxRetries.clusterProperty = io.mqRoutingMaxRetries
ioMqRoutingMaxRetries.validation.type = integer
ioMqRoutingMaxRetries.validation.min = 1

ioMqMessageMaxBytes.description = Maximum number of bytes permitted for a MQ Native Queue message, or 0 for unlimited (Integer)
ioMqMessageMaxBytes.default = 2621440
ioMqMessageMaxBytes.systemProperty = ${propertyPrefix}.mqMessageMaxBytes
ioMqMessageMaxBytes.clusterProperty = io.mqMessageMaxBytes
ioMqMessageMaxBytes.validation.type = long
ioMqMessageMaxBytes.validation.min = 0

ioEmailMessageMaxBytes.description = Maximum number of bytes permitted for an email message, or 0 for unlimited (Integer)
ioEmailMessageMaxBytes.default = 2621440
ioEmailMessageMaxBytes.clusterProperty = io.emailMessageMaxBytes
ioEmailMessageMaxBytes.validation.type = long
ioEmailMessageMaxBytes.validation.min = 0

ioStaleCheckCount.description = Number of stale checked connections per interval (Integer)
ioStaleCheckCount.default = 1
ioStaleCheckCount.systemProperty = com.l7tech.common.http.prov.apache.CommonsHttpClient.staleCheckCount
ioStaleCheckCount.clusterProperty = io.staleCheckCount
ioStaleCheckCount.validation.type = integer

ioStaleCheckHosts.description = Maximum number of stale checked hosts (Integer)
ioStaleCheckHosts.default = 10
ioStaleCheckHosts.systemProperty = com.l7tech.common.http.prov.apache.CommonsHttpClient.staleCheckHosts
ioStaleCheckHosts.clusterProperty = io.staleCheckHosts
ioStaleCheckHosts.validation.type = integer

ioXmlPartMaxBytes.description = Maximum number of bytes permitted in the XML part of a message, or 0 for unlimited (Integer)
ioXmlPartMaxBytes.default = 2621440
ioXmlPartMaxBytes.systemProperty = ${propertyPrefix}.xmlPartMaxBytes
ioXmlPartMaxBytes.clusterProperty = io.xmlPartMaxBytes
ioXmlPartMaxBytes.validation.type = long

ioAttachmentSignedMaxBytes.description = Maximum number of bytes permitted in each signed attachment, or 0 for unlimited (Integer)
ioAttachmentSignedMaxBytes.default = 5242880
ioAttachmentSignedMaxBytes.clusterProperty = io.signedPartMaxBytes
ioAttachmentSignedMaxBytes.validation.type = long

ioMailConnectTimeout.description = IO timeout for outbound connection to mail server (timeunit)
ioMailConnectTimeout.default = 30s
ioMailConnectTimeout.clusterProperty = mail.outConnectTimeout
ioMailConnectTimeout.validation.type = timeUnit

ioMailReadTimeout.description = IO timeout for outbound communication with mail server (timeunit)
ioMailReadTimeout.default = 60s
ioMailReadTimeout.clusterProperty = mail.outTimeout
ioMailReadTimeout.validation.type = timeUnit

ioMailInConnectTimeout.description = IO timeout for inbound connection from mail server (timeunit)
ioMailInConnectTimeout.default = 30s
ioMailInConnectTimeout.clusterProperty = mail.inConnectTimeout
ioMailInConnectTimeout.validation.type = timeUnit

ioMailInTimeout.description = IO timeout for inbound communication with mail server (timeunit)
ioMailInTimeout.default = 60s
ioMailInTimeout.clusterProperty = mail.inTimeout
ioMailInTimeout.validation.type = timeUnit

ioAlwaysValidateContentType.description = Always perform full validation of Content-Type headers (true/false, default false). Requires gateway restart.
ioAlwaysValidateContentType.default = false
ioAlwaysValidateContentType.clusterProperty = io.alwaysValidateContentType
ioAlwaysValidateContentType.systemProperty = com.l7tech.common.mime.alwaysValidateContentType
ioAlwaysValidateContentType.visible = false
ioAlwaysValidateContentType.validation.regex = ${regex.boolean}

ioDebugSsl.description = Log debug information for SSL and TLS operations (true/false)
ioDebugSsl.default = false
ioDebugSsl.clusterProperty = io.debugSsl
ioDebugSsl.validation.regex = ${regex.boolean}

ioDebugSslValue.description = Value to use for SSL and TLS debugging.
ioDebugSslValue.default = ssl
ioDebugSslValue.clusterProperty = io.debugSslValue
ioDebugSslValue.visible = false

# Old name of this setting, but defaults live here -- new one points at this one for defaults
xsltMaxCacheEntries.description = Maximum number of cached stylesheets loaded from URLs, 0 for no caching (Integer). Requires gateway restart.
xsltMaxCacheEntries.default = 100
xsltMaxCacheEntries.systemProperty = ${propertyPrefix}.xsltcache.maxEntries
xsltMaxCacheEntries.clusterProperty = xsltcache.maxEntries
xsltMaxCacheEntries.validation.type = integer

# Old name of this setting, but defaults live here -- new one points at this one for defaults
xsltMaxCacheAge.description = Maximum age of cached stylesheets loaded from URLs (Milliseconds). Requires gateway restart.
xsltMaxCacheAge.default = 300000
xsltMaxCacheAge.systemProperty = ${propertyPrefix}.xsltcache.maxAge
xsltMaxCacheAge.clusterProperty = xsltcache.maxAge
xsltMaxCacheAge.validation.type = long

xsltMaxStaleCacheAge.description = Maximum age of stale (expired) cached stylesheets loaded from URLs, -1 for no expiry (Milliseconds). Requires gateway restart.
xsltMaxStaleCacheAge.default = -1
xsltMaxStaleCacheAge.systemProperty = ${propertyPrefix}.xsltcache.maxStaleAge
xsltMaxStaleCacheAge.clusterProperty = xsltcache.maxStaleAge
xsltMaxStaleCacheAge.validation.type = long

xslt.engine.force20.description = Force use of the XSLT 2.0 engine when processing XSLT 1.0 stylesheets in software (true/false, default=false). Requires gateway restart.
xslt.engine.force20.default = false
xslt.engine.force20.systemProperty = com.l7tech.xml.xslt.useSaxon
xslt.engine.force20.clusterProperty = xslt.engine.force20
xslt.engine.force20.validation.regex = ${regex.boolean}

schemaMaxCacheAge.description = Maximum age of cached XML Schema documents loaded from URLs (Milliseconds).
schemaMaxCacheAge.default = 30000
schemaMaxCacheAge.systemProperty = ${propertyPrefix}.schemacache.maxAge
schemaMaxCacheAge.clusterProperty = schemacache.maxAge
schemaMaxCacheAge.validation.type = long

schemaMaxStaleCacheAge.description = Maximum age of stale (expired) cached XML Schema documents loaded from URLs, -1 for no expiry (Milliseconds).
schemaMaxStaleCacheAge.default = -1
schemaMaxStaleCacheAge.systemProperty = ${propertyPrefix}.schemacache.maxStaleAge
schemaMaxStaleCacheAge.clusterProperty = schemacache.maxStaleAge
schemaMaxStaleCacheAge.validation.type = long

schemaMaxCacheEntries.description = Maximum number of cached XML schema documents loaded from URLs, 0 for no caching (Integer).
schemaMaxCacheEntries.default = 100
schemaMaxCacheEntries.systemProperty = ${propertyPrefix}.schemacache.maxEntries
schemaMaxCacheEntries.clusterProperty = schemacache.maxEntries
schemaMaxCacheEntries.validation.type = integer

schemaRecompileLatency.description = Minimum time that must elapse in between two consecutive rebuilds of the hardware schema table (Milliseconds). This prevents continuous rebuilding.
schemaRecompileLatency.default = 10000
schemaRecompileLatency.systemProperty = ${propertyPrefix}.schemacache.recompileLatency
schemaRecompileLatency.clusterProperty = schemacache.recompileLatency
schemaRecompileLatency.validation.type = long

schemaRecompileMinAge.description = Time after a schema becomes hardware eligible to wait for additional schemas to become eligible before triggering a batch rebuild of the hardware schema table (Milliseconds). Schema status changes often occur in clumps.
schemaRecompileMinAge.default = 500
schemaRecompileMinAge.systemProperty = ${propertyPrefix}.schemacache.recompileMinAge
schemaRecompileMinAge.clusterProperty = schemacache.recompileMinAge
schemaRecompileMinAge.validation.type = long

schemaRecompileMaxAge.description = Maximum time a needed schema hardware cache rebuild can be held to wait for additional schemas to stop arriving (Milliseconds)
schemaRecompileMaxAge.default = 20000
schemaRecompileMaxAge.systemProperty = ${propertyPrefix}.schemacache.recompileMaxAge
schemaRecompileMaxAge.clusterProperty = schemacache.recompileMaxAge
schemaRecompileMaxAge.validation.type = long

schemaCacheMaxSchemaSize.description = Maximum size in bytes of a Schema document download, or 0 for unlimited (Integer)
schemaCacheMaxSchemaSize.default = ${documentDownload.maxSize}
schemaCacheMaxSchemaSize.systemProperty = ${propertyPrefix}.schemacache.maxSchemaSize
schemaCacheMaxSchemaSize.clusterProperty = schemacache.maxSchemaSize
schemaCacheMaxSchemaSize.validation.type = long

schema.remoteResourceRegex.description = Regular expression to match URLs from which download of remote XML Schema dependencies is permitted.
schema.remoteResourceRegex.default = .*
schema.remoteResourceRegex.systemProperty = ${propertyPrefix}.schema.remoteResourceRegex
schema.remoteResourceRegex.clusterProperty = schema.remoteResourceRegex

ephemeralKeyMaxCacheEntries.description = Maximum number of cached ephemeral key thumbprints per-node, or 0 to disable ephemeral key caching (Integer)
ephemeralKeyMaxCacheEntries.default = 1000
ephemeralKeyMaxCacheEntries.systemProperty = ${propertyPrefix}.ekeycache.maxEntries
ephemeralKeyMaxCacheEntries.clusterProperty = ekeycache.maxEntries
ephemeralKeyMaxCacheEntries.validation.type = integer

defaultfaultlevel.description = Level of details in SOAP faults returned by the SSG (can be overridden by FaultLevel assertion). Values are 0 for drop connection, 1 for template, 2 for generic, 3 for medium details, 4 for full details.
defaultfaultlevel.default = 2
defaultfaultlevel.systemProperty = ${propertyPrefix}.fault.level
defaultfaultlevel.clusterProperty = soapfault.level
defaultfaultlevel.validation.regex = [0-4]

defaultfaulttemplate.description = Template used for SOAP faults returned by the SSG (Text). This is only relevant when soapfault.level is set to 1 for template.
defaultfaulttemplate.default = <s:Envelope xmlns:s="http://schemas.xmlsoap.org/soap/envelope/"><s:Body><s:Fault><faultcode>s:Client</faultcode><faultstring>Client Error</faultstring></s:Fault></s:Body></s:Envelope>
defaultfaulttemplate.systemProperty = ${propertyPrefix}.fault.template
defaultfaulttemplate.clusterProperty = soapfault.template

defaultfaultpolicyurl.description = Whether or not the SSG includes the policy download URL when returning SOAP faults (true/false)
defaultfaultpolicyurl.default = true
defaultfaultpolicyurl.systemProperty = ${propertyPrefix}.fault.policyurl
defaultfaultpolicyurl.clusterProperty = soapfault.policyurl
defaultfaultpolicyurl.validation.regex = ${regex.boolean}

defaultfaultsign.description = Whether or not the SSG signs the SOAP body when returning SOAP faults (true/false)
defaultfaultsign.default = false
defaultfaultsign.systemProperty = ${propertyPrefix}.fault.sign
defaultfaultsign.clusterProperty = soapfault.sign
defaultfaultsign.validation.regex = ${regex.boolean}

defaultfaultkeyalias.description = The alias of the private key to use when signing SOAP faults. This is only relevant when soapfault.sign is set to "true".
defaultfaultkeyalias.systemProperty = ${propertyPrefix}.fault.privateKeyAlias
defaultfaultkeyalias.clusterProperty = soapfault.privateKeyAlias

uddi.result.max_rows.description = The maximum number of records to retrieve for any inquiry.
uddi.result.max_rows.clusterProperty = uddi.limit
uddi.result.max_rows.default = 100
uddi.result.max_rows.validation.type = integer
uddi.result.batch_size.description = The number of records to retrieve at a time (Integer). (This value is effective only if less than or equal to the uddi.limit value.)
uddi.result.batch_size.clusterProperty = uddi.batch
uddi.result.batch_size.default = 100
uddi.result.batch_size.validation.type = integer
uddi.policyUrlTemplate.description = Template for building WS-Policy Attachment URL.
uddi.policyUrlTemplate.clusterProperty = uddi.policyUrlTemplate
uddi.policyUrlTemplate.default = http://{0}:{1}/ssg/policy/disco?serviceoid={3}&fulldoc={4}&inline={5}
uddi.centrasite.activesoa.target.description = The target to reference for CentraSite ActiveSOA UDDI Registry metrics.
uddi.centrasite.activesoa.target.clusterProperty = uddi.centrasite.activesoa.target
uddi.connectTimeout.description = IO timeout for UDDI connection (Milliseconds)
uddi.connectTimeout.clusterProperty = uddi.connectTimeout
uddi.connectTimeout.default = 30000
uddi.connectTimeout.validation.type = long
uddi.timeout.description = IO timeout for UDDI response (Milliseconds)
uddi.timeout.clusterProperty = uddi.timeout
uddi.timeout.default = 60000
uddi.timeout.validation.type = long
uddi.wsdlpublish.maxretries.description = Maximum number of retry attempts when publishing Gateway WSDL information to UDDI
uddi.wsdlpublish.maxretries.clusterProperty = uddi.wsdlpublish.maxretries
uddi.wsdlpublish.maxretries.default = 3
uddi.wsdlpublish.maxretries.validation.type = integer

# setting for auto republishing to uddi when external urls change
uddi.autorepublish.default = true
uddi.autorepublish.description = Republish to UDDI as needed e.g. when the cluster hostname or port number changes
uddi.autorepublish.clusterProperty = uddi.auto_republish
uddi.autorepublish.systemProperty = ${propertyPrefix}.uddi.auto_republish
uddi.autorepublish.validation.regex = ${regex.boolean}

# Active SOA specific cluster properties
uddi.centrasite.activesoa.virtual.service.tmodelkey.description = tModelKey to add to proxied business services in ActiveSOA.
uddi.centrasite.activesoa.virtual.service.tmodelkey.clusterProperty = uddi.centrasite.activesoa.virtual.service.tmodelkey
uddi.centrasite.activesoa.virtual.service.tmodelkey.default = uddi:9de0173b-5117-11de-8cf9-da0192ff3739

uddi.systinet.gif.management.system.description = keyValue for GIF 'uddi:systinet.com:management:system' keyedReference
uddi.systinet.gif.management.system.clusterProperty = uddi.systinet.gif.management.system
uddi.systinet.gif.management.system.default = Layer7 Gateway
uddi.systinet.gif.management.system.visible = false

# This setting is no longer used (should now be configured via manager log sink UI)
trafficLoggerEnabled.description = Whether or not traffic should be recorded (true/false)
trafficLoggerEnabled.default = false
trafficLoggerEnabled.clusterProperty = trafficlogger.enabled
trafficLoggerEnabled.systemProperty = ${propertyPrefix}.trafficlogger.enabled
trafficLoggerEnabled.visible = false
trafficLoggerEnabled.validation.regex = ${regex.boolean}

trafficLoggerDetail.description = Template for logged information related to the request (Text)
trafficLoggerDetail.default = ${request.time}, ${request.soap.namespace}, ${request.soap.operationname}, ${response.http.status}
trafficLoggerDetail.clusterProperty = trafficlogger.detail
trafficLoggerDetail.systemProperty = ${propertyPrefix}.trafficlogger.detail

# This setting is no longer used (should now be configured via manager log sink UI)
trafficLoggerPattern.description = File path in the style of java.util.logging.FileHandler.pattern; see java.util.logging (Text)
trafficLoggerPattern.default = ${ssgHome}${fs}logs${fs}traffic_%g_%u.log
trafficLoggerPattern.clusterProperty = trafficlogger.pattern
trafficLoggerPattern.systemProperty = ${propertyPrefix}.trafficlogger.pattern
trafficLoggerPattern.visible = false

# This setting is no longer used (should now be configured via manager log sink UI)
trafficLoggerLimit.description = Approximate maximum size for log files (Bytes). If this is zero, then there is no limit
trafficLoggerLimit.default = 5242880
trafficLoggerLimit.clusterProperty = trafficlogger.limit
trafficLoggerLimit.systemProperty = ${propertyPrefix}.trafficlogger.limit
trafficLoggerLimit.visible = false

# This setting is no longer used (should now be configured via manager log sink UI)
trafficLoggerCount.description = Number of output files (Integer)
trafficLoggerCount.default = 2
trafficLoggerCount.clusterProperty = trafficlogger.count
trafficLoggerCount.systemProperty = ${propertyPrefix}.trafficlogger.count
trafficLoggerCount.visible = false

trafficLoggerRecordReq.description = Append the contents of the request received by the Gateway at the end of each record (true/false)
trafficLoggerRecordReq.default = false
trafficLoggerRecordReq.clusterProperty = trafficlogger.recordreq
trafficLoggerRecordReq.systemProperty = ${propertyPrefix}.trafficlogger.recordreq
trafficLoggerRecordReq.validation.regex = ${regex.boolean}

trafficLoggerRecordRes.description = Append the contents of the response returned by the Gateway at the end of each record (true/false)
trafficLoggerRecordRes.default = false
trafficLoggerRecordRes.clusterProperty = trafficlogger.recordres
trafficLoggerRecordRes.systemProperty = ${propertyPrefix}.trafficlogger.recordres
trafficLoggerRecordRes.validation.regex = ${regex.boolean}

trafficLoggerSelective.description = Whether the traffic logging is selective (true) or globally turned on/off (false)
trafficLoggerSelective.default = false
trafficLoggerSelective.clusterProperty = trafficlogger.selective
trafficLoggerSelective.systemProperty = ${propertyPrefix}.trafficlogger.selective
trafficLoggerSelective.validation.regex = ${regex.boolean}

pingServletMode.description = Set the permission mode of the Ping Servlet (OFF | REQUIRE_CREDS | OPEN | MONITOR)
pingServletMode.default = REQUIRE_CREDS
pingServletMode.clusterProperty = pingServlet.mode
pingServletMode.systemProperty = ${propertyPrefix}.pingServlet.mode
pingServletMode.validation.regex = \\s*(OFF|REQUIRE_CREDS|OPEN|MONITOR)\\s*

serviceMetricsEnabled.description = Enable collection of service metrics (true/false)
serviceMetricsEnabled.default = true
serviceMetricsEnabled.clusterProperty = serviceMetrics.enabled
serviceMetricsEnabled.systemProperty = com.l7tech.service.metrics.enabled
serviceMetricsEnabled.validation.regex = ${regex.boolean}

wsdlImportFixupEnabled.default = true
wsdlImportFixupEnabled.systemProperty = com.l7tech.service.wsdlimportfix.enabled

wsdlImportProxyEnabled.description = Permit download of WSDL dependencies (WSDL/Schema). When enabled, available WSDL dependencies can be downloaded (true/false)
wsdlImportProxyEnabled.default = false
wsdlImportProxyEnabled.clusterProperty = service.wsdlDependenciesEnabled
wsdlImportProxyEnabled.validation.regex = ${regex.boolean}

wsdlProxy.allowInsecureHttpBasic.description = Permit WSDL download authentication using HTTP Basic over HTTP, by default only HTTPS is permitted (true/false)
wsdlProxy.allowInsecureHttpBasic.default = false
wsdlProxy.allowInsecureHttpBasic.systemProperty = ${propertyPrefix}.wsdlProxy.allowInsecureHttpBasic
wsdlProxy.allowInsecureHttpBasic.clusterProperty = wsdlProxy.allowInsecureHttpBasic
wsdlProxy.allowInsecureHttpBasic.validation.regex = ${regex.boolean}
wsdlProxy.allowInsecureHttpBasic.visible = false

wsdlQuery.description = Permit download of WSDL using '?wsdl' URL suffix. When enabled, WSDL documents can be downloaded using the Service's resolution path (true/false)
wsdlQuery.default = true
wsdlQuery.clusterProperty = service.wsdlQueryEnabled
wsdlQuery.validation.regex = ${regex.boolean}

schemaSoftwareFallback.description = If true, in the event of a hardware schema validation failure, the validation will be retried in software
schemaSoftwareFallback.default = true
schemaSoftwareFallback.systemProperty = ${propertyPrefix}.schema.softwareFallback
schemaSoftwareFallback.clusterProperty = schema.softwareFallback
schemaSoftwareFallback.validation.regex = ${regex.boolean}

schema.hardwareTargetNamespaces.description = XML Schemas that will always be loaded to hardware, identified by their target namespace (space separated list)
schema.hardwareTargetNamespaces.default = http://schemas.xmlsoap.org/soap/envelope/\nhttp://www.w3.org/2003/05/soap-envelope
schema.hardwareTargetNamespaces.systemProperty = ${propertyPrefix}.schema.hardwareTargetNamespaces
schema.hardwareTargetNamespaces.clusterProperty = schema.hardwareTargetNamespaces

schema.allowDoctype.description = Allow use of a document type definition in XML Schemas (true/false)
schema.allowDoctype.default = false
schema.allowDoctype.systemProperty = ${propertyPrefix}.schema.allowDoctype
schema.allowDoctype.clusterProperty = schema.allowDoctype
schema.allowDoctype.validation.regex = ${regex.boolean}

samlBeforeOffsetMinute.description = The number of minutes (should be a positive integer) to offset the Not-Before aspect of the validity of SAML statements created by the token service
samlBeforeOffsetMinute.default = 2
samlBeforeOffsetMinute.clusterProperty = samlAssertion.NotBeforeOffsetMinutes
samlBeforeOffsetMinute.systemProperty = ${propertyPrefix}.saml.notbeforeoffsetmin
samlBeforeOffsetMinute.validation.type = integer

samlAfterOffsetMinute.description = The number of minutes (should be a positive integer) to offset the Not-On-Or-After aspect of the validity of SAML statements created by the token service
samlAfterOffsetMinute.default = 5
samlAfterOffsetMinute.clusterProperty = samlAssertion.NotAfterOffsetMinutes
samlAfterOffsetMinute.systemProperty = ${propertyPrefix}.saml.notafteroffsetmin
samlAfterOffsetMinute.validation.type = integer

service.validateWssTimestamps.description = Should built-in services validate WS-Security timestamps (true/false)
service.validateWssTimestamps.default = true
service.validateWssTimestamps.clusterProperty = service.validateWssTimestamps
service.validateWssTimestamps.systemProperty = com.l7tech.server.servicesValidateWssTimestamps
service.validateWssTimestamps.validation.regex = ${regex.boolean}

samlValidateBeforeOffsetMinutes.description = The number of minutes to subtract from a SAML assertion's NotBefore restriction during validation.  This can be used to relax the validity window to allow for clock skew.  (default=0)
samlValidateBeforeOffsetMinutes.default = 0
samlValidateBeforeOffsetMinutes.clusterProperty = samlAssertion.validate.notBeforeOffsetMin
samlValidateBeforeOffsetMinutes.systemProperty = ${propertyPrefix}.saml.validate.notBeforeOffsetMin
samlValidateBeforeOffsetMinutes.validation.type = integer

samlValidateAfterOffsetMinutes.description = The number of minutes to add to a SAML assertion's NotOnOrAfter restriction during validation.  This can be used to relax the validity window to allow for clock skew.  (default=0)
samlValidateAfterOffsetMinutes.default = 0
samlValidateAfterOffsetMinutes.clusterProperty = samlAssertion.validate.notOnOrAfterOffsetMin
samlValidateAfterOffsetMinutes.systemProperty = ${propertyPrefix}.saml.validate.notOnOrAfterOffsetMin
samlValidateAfterOffsetMinutes.validation.type = integer

samlGenerateIncludeDNSAddress.description = Should the subject locality for SAML authentication statements include a DNS address (true/false)
samlGenerateIncludeDNSAddress.default = false
samlGenerateIncludeDNSAddress.clusterProperty = saml.generation.includeDNSAddress
samlGenerateIncludeDNSAddress.systemProperty = com.l7tech.security.saml.enableDNS
samlGenerateIncludeDNSAddress.validation.regex = ${regex.boolean}

pkixValidation.identity.description = Default certificate validation setting for identity providers (validate/validatepath/revocation)
pkixValidation.identity.default = validate
pkixValidation.identity.clusterProperty = pkix.validation.identityProvider
pkixValidation.identity.validation.regex = validate|validatepath|revocation

pkixValidation.routing.description = Default certificate validation setting for message routing (validate/validatepath/revocation)
pkixValidation.routing.default = validate
pkixValidation.routing.clusterProperty = pkix.validation.routing
pkixValidation.routing.validation.regex = validate|validatepath|revocation

pkixValidation.other.description = Default certificate validation setting for other uses (validate/validatepath/revocation)
pkixValidation.other.default = validate
pkixValidation.other.clusterProperty = pkix.validation.other
pkixValidation.other.validation.regex = validate|validatepath|revocation

pkixTrust.useDefaultAnchors.description = Should well known Certificate Authorities be included as Trust Anchors (true/false)
pkixTrust.useDefaultAnchors.default = false
pkixTrust.useDefaultAnchors.clusterProperty = pkix.useDefaultTrustAnchors
pkixTrust.useDefaultAnchors.validation.regex = ${regex.boolean}
pkixTrust.useDefaultAnchors.visible = false

pkixTrust.permittedCriticalExtensions.description = List of critical extensions that should be permitted when validating certificates (space separated list of OIDs)
pkixTrust.permittedCriticalExtensions.default =
pkixTrust.permittedCriticalExtensions.clusterProperty = pkix.permittedCriticalExtensions

pkixCRL.expiry.description = Default setting for CRL expiry age (timeunit)
pkixCRL.expiry.default = 1h
pkixCRL.expiry.clusterProperty = pkix.crl.defaultExpiryAge
pkixCRL.expiry.validation.type = timeUnit

pkixCRL.cache.expiry.description = CRL cache expiry age (timeunit)
pkixCRL.cache.expiry.default = 5m
pkixCRL.cache.expiry.clusterProperty = pkix.crl.cacheExpiryAge
pkixCRL.cache.expiry.validation.type = timeUnit

pkixCRL.cache.preexpiry.description = CRL cache refresh pre-expiry age (timeunit)
pkixCRL.cache.preexpiry.default = 1m
pkixCRL.cache.preexpiry.clusterProperty = pkix.crl.cachePreExpiryAge
pkixCRL.cache.preexpiry.visible = false
pkixCRL.cache.preexpiry.validation.type = timeUnit

pkixCRL.cache.threads.description = CRL cache refresh worker thread count, or 0 to disable.
pkixCRL.cache.threads.default = 3
pkixCRL.cache.threads.clusterProperty = pkix.crl.cachePreExpiryThreads
pkixCRL.cache.threads.visible = false
pkixCRL.cache.threads.validation.type = integer

pkixCRL.minExpiryAge.description = Minimum allowed value for CRL expiry age (timeunit)
pkixCRL.minExpiryAge.default = 1h
pkixCRL.minExpiryAge.clusterProperty = pkix.crl.minExpiryAge
pkixCRL.minExpiryAge.validation.type = timeUnit

pkixCRL.maxExpiryAge.description = Maximum allowed value for CRL expiry age (timeunit)
pkixCRL.maxExpiryAge.default = 7d
pkixCRL.maxExpiryAge.clusterProperty = pkix.crl.maxExpiryAge
pkixCRL.maxExpiryAge.validation.type = timeUnit

pkixCRL.maxSize.description = Maximum size in bytes for a CRL, or 0 for unlimited (Integer).
pkixCRL.maxSize.default = 1048576
pkixCRL.maxSize.clusterProperty = pkix.crl.maxSize
pkixCRL.maxSize.systemProperty = ${propertyPrefix}.pkix.crlMaxSize
pkixCRL.maxSize.validation.type = long

pkixOCSP.expiry.description = Default setting for OCSP response expiry age (timeunit)
pkixOCSP.expiry.default = 1m
pkixOCSP.expiry.clusterProperty = pkix.ocsp.defaultExpiryAge
pkixOCSP.expiry.validation.type = timeUnit

pkixOCSP.minExpiryAge.description = Minimum allowed value for OCSP response expiry age (timeunit)
pkixOCSP.minExpiryAge.default = 1s
pkixOCSP.minExpiryAge.clusterProperty = pkix.ocsp.minExpiryAge
pkixOCSP.minExpiryAge.validation.type = timeUnit

pkixOCSP.maxExpiryAge.description = Maximum allowed value for OCSP response expiry age (timeunit)
pkixOCSP.maxExpiryAge.default = 15m
pkixOCSP.maxExpiryAge.clusterProperty = pkix.ocsp.maxExpiryAge
pkixOCSP.maxExpiryAge.validation.type = timeUnit

pkixOCSP.useNonce.description = Include a nonce in OCSP requests (true/false)
pkixOCSP.useNonce.default = true
pkixOCSP.useNonce.clusterProperty = pkix.ocsp.useNonce
pkixOCSP.useNonce.validation.regex = ${regex.boolean}

pkix.csr.defaultExpiryAge.description = The default certificate expiry to use for issued user certificates (days)
pkix.csr.defaultExpiryAge.default = 730
pkix.csr.defaultExpiryAge.clusterProperty = pkix.csr.defaultExpiryAge
pkix.csr.defaultExpiryAge.validation.type = integer
pkix.csr.defaultExpiryAge.validation.min = 1
pkix.csr.defaultExpiryAge.validation.max = 100000

keyStoreDefaultSslKey.description = Keystore ID and alias of default SSL key, colon delimited.  A keystore ID of -1 means "unspecified".
keyStoreDefaultSslKey.default = -1:SSL
keyStoreDefaultSslKey.clusterProperty = keyStore.defaultSsl.alias
keyStoreDefaultSslKey.systemProperty = ${propertyPrefix}.keyStore.defaultSsl.alias
keyStoreDefaultSslKey.visible = false

keyStoreDefaultCaKey.description = Keystore ID and alias of default CA key, colon delimited.  A keystore ID of -1 means "unspecified".
keyStoreDefaultCaKey.default =
keyStoreDefaultCaKey.clusterProperty = keyStore.defaultCa.alias
keyStoreDefaultCaKey.systemProperty = ${propertyPrefix}.keyStore.defaultCa.alias
keyStoreDefaultCaKey.visible = false

keyStoreAuditViewerKey.description = Keystore ID and alias of audit viewer decryption key, colon delimited.  A keystore ID of -1 means "unspecified".
keyStoreAuditViewerKey.default =
keyStoreAuditViewerKey.clusterProperty = keyStore.auditViewer.alias
keyStoreAuditViewerKey.systemProperty = ${propertyPrefix}.keyStore.auditViewer.alias
keyStoreAuditViewerKey.visible = false

keyStoreAuditSigningKey.description = Keystore ID and alias of default audit signing key, colon delimited.  A keystore ID of -1 means "unspecified".
keyStoreAuditSigningKey.default =
keyStoreAuditSigningKey.clusterProperty = keyStore.auditSigning.alias
keyStoreAuditSigningKey.systemProperty = ${propertyPrefix}.keyStore.auditSigning.alias
keyStoreAuditSigningKey.visible = false

keyStoreSearchForAlias.description = If a key alias isn't found in the expected keystore, search all other keystores as well (true/false)
keyStoreSearchForAlias.default = true
keyStoreSearchForAlias.clusterProperty = keyStore.searchForAlias
keyStoreSearchForAlias.validation.regex = ${regex.boolean}

keyStore.certgen.signWithSha1.description = If true, use SHA-1 by default for the message digest when signing certificates.  If false, use SHA-384 if available.  (true/false)
keyStore.certgen.signWithSha1.default = false
keyStore.certgen.signWithSha1.clusterProperty = keyStore.signWithSha1
keyStore.certgen.signWithSha1.systemProperty = com.l7tech.security.cert.alwaysSignWithSha1
keyStore.certgen.signWithSha1.validation.regex = ${regex.boolean}

# Note: not a cluster property
keyStore.luna.pinFinder.default=com.l7tech.server.security.keystore.luna.GatewayLunaPinFinder
keyStore.luna.pinFinder.systemProperty=com.l7tech.lunaPinFinder

keyStore.luna.encryptedLunaPin.description = Luna client PIN, encrypted by GatewayLunaPinFinder (string; no default)
keyStore.luna.encryptedLunaPin.visible=false
keyStore.luna.encryptedLunaPin.systemProperty=com.l7tech.encryptedLunaPin
keyStore.luna.encryptedLunaPin.clusterProperty=keyStore.luna.encryptedLunaPin

keyStore.luna.lunaSlotNum.description = Luna slot number, or -1 to let LunaTokenManager choose one (integer; default -1)
keyStore.luna.lunaSlotNum.visible=false
keyStore.luna.lunaSlotNum.default=-1
keyStore.luna.lunaSlotNum.systemProperty=com.l7tech.lunaSlotNum
keyStore.luna.lunaSlotNum.clusterProperty=keyStore.luna.lunaSlotNum

keyStore.luna.installAsLeastPreference.description = Whether to install the Luna provider as the least-preference security provider. (boolean; default false)
keyStore.luna.installAsLeastPreference.visible=false
keyStore.luna.installAsLeastPreference.default=false
keyStore.luna.installAsLeastPreference.systemProperty=com.l7tech.luna.installAsLeastPreference
keyStore.luna.installAsLeastPreference.clusterProperty=keyStore.luna.installAsLeastPreference
keyStore.luna.installAsLeastPreference.validation.regex = ${regex.boolean}

license.expiryWarnAge.description = Time in days before a license/SSL expiry warning is displayed (eg 30d)
license.expiryWarnAge.default = 30d
license.expiryWarnAge.clusterProperty = license.expiryWarningPeriod
license.expiryWarnAge.validation.type = timeUnit

trustedCert.expiryCheckPeriod.description = The delay to wait between successive Trusted Cert expiry checks
trustedCert.expiryCheckPeriod.default = 12h
trustedCert.expiryCheckPeriod.clusterProperty = trustedCert.expiryCheckPeriod
trustedCert.expiryCheckPeriod.validation.type = timeUnit

trustedCert.expiryFineAge.description = The period prior to the expiry of the Certificate in a Trusted Cert Entry that the Gateway should start logging/auditing FINE-level messages
trustedCert.expiryFineAge.default = 30d
trustedCert.expiryFineAge.clusterProperty = trustedCert.expiryFineAge
trustedCert.expiryFineAge.validation.type = timeUnit

trustedCert.expiryInfoAge.description = The period prior to the expiry of the Certificate in a Trusted Cert Entry that the Gateway should start logging/auditing INFO-level messages
trustedCert.expiryInfoAge.default = 7d
trustedCert.expiryInfoAge.clusterProperty = trustedCert.expiryInfoAge
trustedCert.expiryInfoAge.validation.type = timeUnit

trustedCert.expiryWarningAge.description = The period prior to the expiry of the Certificate in a Trusted Cert Entry that the Gateway should start logging/auditing WARNING-level messages
trustedCert.expiryWarningAge.default = 2d
trustedCert.expiryWarningAge.clusterProperty = trustedCert.expiryWarningAge
trustedCert.expiryWarningAge.validation.type = timeUnit

serverPolicyValidation.maxConcurrency.description = Maximum number of server-side policy validation jobs that may be active simultaneously.
serverPolicyValidation.maxConcurrency.default = 15
serverPolicyValidation.maxConcurrency.clusterProperty = policyValidation.maxConcurrency
serverPolicyValidation.maxConcurrency.validation.type = integer

policyValidation.maxPaths.description = Maximum number of possible paths through a policy before the policy is considered to be too complex to attempt server-side validation.
policyValidation.maxPaths.default = 500000
policyValidation.maxPaths.clusterProperty = policyValidation.maxPaths
policyValidation.maxPaths.validation.type = integer

policyVersioningMaxRevisions.description = Maximum number of policy revisions to retain. Only revisions that are not active and which do not have a comment count toward the maximum.
policyVersioningMaxRevisions.default = 20
policyVersioningMaxRevisions.clusterProperty = policyVersioning.maxRevisions
policyVersioningMaxRevisions.validation.type = integer

hpsoamEnabled.description = Enable Agent web service for HP SOA Manager (true/false)
hpsoamEnabled.default = false
hpsoamEnabled.clusterProperty = hpsoam.enabled
hpsoamEnabled.visible = false
hpsoamEnabled.validation.regex = ${regex.boolean}

hpsoamRequireSSL.description = Control whether SSL is required for Agent web service for HP SOA Manager (true/false)
hpsoamRequireSSL.default = false
hpsoamRequireSSL.clusterProperty = hpsoam.requireSSL
hpsoamRequireSSL.visible = false
hpsoamRequireSSL.validation.regex = ${regex.boolean}

hpsoamRequireCreds.description = Control whether credentials of 'Administrator' or 'Operator' roles are required for Agent web service for HP SOA Manager (true/false)
hpsoamRequireCreds.default = false
hpsoamRequireCreds.clusterProperty = hpsoam.requireCreds
hpsoamRequireCreds.visible = false
hpsoamRequireCreds.validation.regex = ${regex.boolean}

soapRejectMustUnderstand.description = If true, SOAP messages containing an unrecognized SOAP header addressed to the Gateway with mustUnderstand="1" will be rejected immediately (true/false)
soapRejectMustUnderstand.default = true
soapRejectMustUnderstand.clusterProperty = soap.rejectMustUnderstand
soapRejectMustUnderstand.validation.regex = ${regex.boolean}

soap.actors.description = Additional SOAP (1.1) Actors for Security headers that will be processed by the Gateway (space separated list)
soap.actors.default = secure_span\nhttp://www.layer7tech.com/ws/policy
soap.actors.systemProperty = com.l7tech.xml.soap.actors
soap.actors.clusterProperty = soap.actors

soap.roles.description = Additional SOAP (1.2) Roles for Security headers that will be processed by the Gateway (space separated list)
soap.roles.default = secure_span\nhttp://www.layer7tech.com/ws/policy
soap.roles.systemProperty = com.l7tech.xml.soap.roles
soap.roles.clusterProperty = soap.roles

template.strictMode.description = If true, using nonexistent variables in a template can cause assertions or policy processing to fail.  If false (the default) an empty string is used instead.
template.strictMode.default = false
template.strictMode.systemProperty = ${propertyPrefix}.template.strictMode
template.strictMode.clusterProperty = template.strictMode
template.strictMode.validation.regex = ${regex.boolean}

template.defaultMultivalueDelimiter.description = The delimiter to use between values when a multivalued variable is interpolated
template.defaultMultivalueDelimiter.default = ", "
template.defaultMultivalueDelimiter.systemProperty = ${propertyPrefix}.template.defaultMultivalueDelimiter
template.defaultMultivalueDelimiter.clusterProperty = template.defaultMultivalueDelimiter

# The auth cache tunings need to default to their old system properties, but let their cluster properties take precedence
defaultAuthCacheMaxSuccessTime.default = 60000
defaultAuthCacheMaxSuccessTime.systemProperty = ${propertyPrefix}.identity.AuthCache.maxSuccessTime
authCacheMaxSuccessTime.description = Milliseconds to cache successful authentications
authCacheMaxSuccessTime.default = ${defaultAuthCacheMaxSuccessTime}
authCacheMaxSuccessTime.clusterProperty = authCache.maxSuccessTime
authCacheMaxSuccessTime.validation.type = long

defaultAuthCacheMaxFailureTime.default = 30000
defaultAuthCacheMaxFailureTime.systemProperty = ${propertyPrefix}.identity.AuthCache.maxFailureTime
authCacheMaxFailureTime.description = Milliseconds to cache failed authentications
authCacheMaxFailureTime.default = ${defaultAuthCacheMaxFailureTime}
authCacheMaxFailureTime.clusterProperty = authCache.maxFailureTime
authCacheMaxFailureTime.validation.type = long

defaultAuthCacheSuccessCacheSize.default = 2000
defaultAuthCacheSuccessCacheSize.systemProperty = ${propertyPrefix}.identity.AuthCache.successCacheSize
authCacheSuccessCacheSize.description = The cache size for successful authentications
authCacheSuccessCacheSize.default = ${defaultAuthCacheSuccessCacheSize}
authCacheSuccessCacheSize.clusterProperty = authCache.successCacheSize
authCacheSuccessCacheSize.validation.type = integer

defaultAuthCacheFailureCacheSize.default = 200
defaultAuthCacheFailureCacheSize.systemProperty = ${propertyPrefix}.identity.AuthCache.failureCacheSize
authCacheFailureCacheSize.description = The cache size for failed authentications
authCacheFailureCacheSize.default = ${defaultAuthCacheFailureCacheSize}
authCacheFailureCacheSize.clusterProperty = authCache.failureCacheSize
authCacheFailureCacheSize.validation.type = integer

defaultAuthCacheGroupMembershipCacheSize.default = 5000
defaultAuthCacheGroupMembershipCacheSize.systemProperty = ${propertyPrefix}.identity.AuthCache.groupMembershipCacheSize
authCacheGroupMembershipCacheSize.description = The cache size for group memberships
authCacheGroupMembershipCacheSize.default = ${defaultAuthCacheGroupMembershipCacheSize}
authCacheGroupMembershipCacheSize.clusterProperty = authCache.groupMembershipCacheSize
authCacheGroupMembershipCacheSize.validation.type = integer

principalSessionCacheSize.description = Maximum number of principals to keep in cache
principalSessionCacheSize.default = 100
principalSessionCacheSize.clusterProperty = principalSessionCache.cacheSize
principalSessionCacheSize.validation.type = integer

principalSessionCacheMaxTime.description = Milliseconds to cache successful principal validations
principalSessionCacheMaxTime.default = 300000
principalSessionCacheMaxTime.clusterProperty = principalSessionCache.maxTime
principalSessionCacheMaxTime.validation.type = long

principalSessionCacheMaxPrincipalGroups.description = Number of groups per principal to store in the cache
principalSessionCacheMaxPrincipalGroups.default = 50
principalSessionCacheMaxPrincipalGroups.clusterProperty = principalSessionCache.maxPrincipalGroups
principalSessionCacheMaxPrincipalGroups.validation.type = integer

jmsListenerThreadLimit.description=The global limit on the number of processing threads that can be created to work off all JMS endpoints. Value must be >= 5.
jmsListenerThreadLimit.default=25
jmsListenerThreadLimit.clusterProperty=jms.listenerThreadLimit
jmsListenerThreadLimit.validation.type = integer
jmsListenerThreadLimit.validation.min = 5

emailListenerThreadLimit.description=The global limit on the number of processing threads that can be created to work off all Email endpoints. Value must be >= 5.
emailListenerThreadLimit.default=25
emailListenerThreadLimit.clusterProperty=email.listenerThreadLimit
emailListenerThreadLimit.validation.type = integer
emailListenerThreadLimit.validation.min = 5

sftpMessageProcessingThreadLimit.description=The global limit on the number of processing threads for SFTP requests (integer)
sftpMessageProcessingThreadLimit.default=20
sftpMessageProcessingThreadLimit.clusterProperty=sftp.messageProcessingThreadLimit
sftpMessageProcessingThreadLimit.validation.type = integer
sftpMessageProcessingThreadLimit.validation.min = 1
sftpMessageProcessingThreadLimit.validation.max = 1000
sftpMessageProcessingThreadLimit.visible = false

sshResponseDownloadThreadLimit.description=The global limit on the number of response download threads for SSH2 routing (integer)
sshResponseDownloadThreadLimit.default=20
sshResponseDownloadThreadLimit.clusterProperty=ssh.responseDownloadThreadLimit
sshResponseDownloadThreadLimit.validation.type = integer
sshResponseDownloadThreadLimit.validation.min = 1
sshResponseDownloadThreadLimit.validation.max = 1000
sshResponseDownloadThreadLimit.visible = false

sshRoutingEnabledCiphers.description = The list of ciphers to enable for SSH2 routing, permitted values are "aes128-ctr", "aes192-ctr", "aes256-ctr", "aes128-cbc", "aes192-cbc", "aes256-cbc", "blowfish-cbc", "3des-cbc" (Comma delimited)
sshRoutingEnabledCiphers.default= aes128-ctr, aes128-cbc, 3des-cbc, blowfish-cbc, aes192-ctr, aes192-cbc, aes256-ctr, aes256-cbc
sshRoutingEnabledCiphers.clusterProperty = ssh.routingEnabledCiphers
sshRoutingEnabledCiphers.validation.regex = (aes128-ctr|aes192-ctr|aes256-ctr|aes128-cbc|aes192-cbc|aes256-cbc|blowfish-cbc|3des-cbc|none)(\\s*,\\s*(aes128-ctr|aes192-ctr|aes256-ctr|aes128-cbc|aes192-cbc|aes256-cbc|blowfish-cbc|3des-cbc|none))*

sftpRoutingExplicitlyValidateDeleteFile.description=This will explicitly check to see if the file attempted to be deleted exists, and it is a file.
sftpRoutingExplicitlyValidateDeleteFile.default=true
sftpRoutingExplicitlyValidateDeleteFile.clusterProperty=sftp.routingExplicitlyValidateDeleteFile
sftpRoutingExplicitlyValidateDeleteFile.validation.regex = ${regex.boolean}

sftpRoutingExplicitlyValidateDeleteDir.description=This will explicitly check to see if the directory attempted to be deleted exists, and it is a directory.
sftpRoutingExplicitlyValidateDeleteDir.default=true
sftpRoutingExplicitlyValidateDeleteDir.clusterProperty=sftp.routingExplicitlyValidateDeleteDir
sftpRoutingExplicitlyValidateDeleteDir.validation.regex = ${regex.boolean}

sftpRoutingExplicitlyValidateMkdir.description=This will explicitly check to see if a directory of the same name exists before attempting to create it.
sftpRoutingExplicitlyValidateMkdir.default=true
sftpRoutingExplicitlyValidateMkdir.clusterProperty=sftp.routingExplicitlyValidateMkdir
sftpRoutingExplicitlyValidateMkdir.validation.regex = ${regex.boolean}

customerMapping.addToGatewayAuditEvents.description=Add customer mapping information into the gateway audit, so the user can view the information in Gateway Audit Events window. (true/false)
customerMapping.addToGatewayAuditEvents.default=true
customerMapping.addToGatewayAuditEvents.clusterProperty=customerMapping.addToGatewayAuditEvents
customerMapping.addToGatewayAuditEvents.visible=false
customerMapping.addToGatewayAuditEvents.validation.regex = ${regex.boolean}

customerMapping.addToServiceMetrics.description=Add customer mapping information into the service_metrics table, so the user can apply the information in the Dashboard. (true/false)
customerMapping.addToServiceMetrics.default=true
customerMapping.addToServiceMetrics.clusterProperty=customerMapping.addToServiceMetrics
customerMapping.addToServiceMetrics.visible=false
customerMapping.addToServiceMetrics.validation.regex = ${regex.boolean}

services.certificateDiscoveryEnabled.description=Enabling certificate discovery allows XML VPN Clients and Bridge Routing Assertions that send requests to this Gateway to securely discover this Gateway's SSL certificate without user intervention (true/false).
services.certificateDiscoveryEnabled.default=true
services.certificateDiscoveryEnabled.clusterProperty=services.certificateDiscoveryEnabled
services.certificateDiscoveryEnabled.validation.regex = ${regex.boolean}

admin.certificateDiscoveryEnabled.description=Enabling certificate discovery allows the Policy Manager to securely discover this Gateway's SSL certificate without user intervention (true/false).
admin.certificateDiscoveryEnabled.default=true
admin.certificateDiscoveryEnabled.clusterProperty=admin.certificateDiscoveryEnabled
admin.certificateDiscoveryEnabled.validation.regex = ${regex.boolean}

admin.esmRequestSizeLimit.description = The size limit in bytes for ESM administration and Node Control requests, or 0 for unlimited (Integer)
admin.esmRequestSizeLimit.default = 10485760
admin.esmRequestSizeLimit.systemProperty = ${propertyPrefix}.admin.ws.requestSizeLimit
admin.esmRequestSizeLimit.clusterProperty = admin.esmRequestSizeLimit
admin.esmRequestSizeLimit.validation.type = long

admin.esmInterfaceTag.description = Name of the Interface Tag used to identify the IP address for ESM administration requests.
admin.esmInterfaceTag.default =
admin.esmInterfaceTag.systemProperty = ${propertyPrefix}.admin.esmInterfaceTag
admin.esmInterfaceTag.clusterProperty = admin.esmInterfaceTag

admin.esmPort.description = External HTTPS port for ESM administration requests.
admin.esmPort.default = ${clusterhttpsport}
admin.esmPort.systemProperty = ${propertyPrefix}.admin.esmPort
admin.esmPort.clusterProperty = admin.esmPort
admin.esmPort.validation.type = integer
admin.esmPort.validation.min = 1
admin.esmPort.validation.max = 65535

processControllerPresent.description = Nodes in this cluster are managed processes (true/false).
processControllerPresent.visible = false
processControllerPresent.clusterProperty = node.processControllerPresent
processControllerPresent.systemProperty = ${propertyPrefix}.processControllerPresent
processControllerPresent.default = false
processControllerPresent.validation.regex = ${regex.boolean}

processControllerPort.description = Port number for internal communication with the process manager.
processControllerPort.visible = false
processControllerPort.clusterProperty = node.processControllerPort
processControllerPort.systemProperty = ${propertyPrefix}.processControllerPort
processControllerPort.default = 8765
processControllerPort.validation.type = integer
processControllerPort.validation.min = 1
processControllerPort.validation.max = 65535

processControllerDefaultExternalPort.description = Default value for the node management port.
processControllerDefaultExternalPort.systemProperty = ${propertyPrefix}.processControllerPort
processControllerDefaultExternalPort.default = 8765

processControllerExternalPort.description = Port number for ESM remote management of cluster node process managers.
processControllerExternalPort.clusterProperty = node.processControllerExternalPort
processControllerExternalPort.systemProperty = ${propertyPrefix}.processControllerExternalPort
processControllerExternalPort.default = ${processControllerDefaultExternalPort}
processControllerExternalPort.validation.type = integer
processControllerExternalPort.validation.min = 1
processControllerExternalPort.validation.max = 65535

logon.warningBanner.description=Warning message that will be displayed to the user upon successful login to the Policy Manager. By default, this cluster property is empty, which will result in no warning banner being displayed.
logon.warningBanner.default=
logon.warningBanner.clusterProperty=logon.warningBanner

logon.maxAllowableAttempts.description=Maximum number of failed login attempts before the account is locked.   Default is set to 5 attempts max.
logon.maxAllowableAttempts.default=5
logon.maxAllowableAttempts.clusterProperty=logon.maxAllowableAttempts
logon.maxAllowableAttempts.validation.type = integer

logon.lockoutTime.description=The time interval that the locked account will have to wait before next possible login retry after lock out.  The default time is set to 1200 seconds (20 min).  Value should be entered in seconds.
logon.lockoutTime.default=1200
logon.lockoutTime.clusterProperty=logon.lockoutTime
logon.lockoutTime.validation.type = long

logon.sessionExpiry.description = The time interval a session can be inactive for.  Default is 30 minutes.  Value should be entered in minutes.
logon.sessionExpiry.default = 30
logon.sessionExpiry.clusterProperty = logon.sessionExpiry
logon.sessionExpiry.validation.type = integer

logon.inactivityPeriod.description=The time interval an administrative user account could be inactive for.  Default is 35 days  Value should be entered in days.
logon.inactivityPeriod.default=35
logon.inactivityPeriod.clusterProperty=logon.inactivityPeriod
logon.inactivityPeriod.validation.type = integer

#Property is deprecated, leaving in for backwards compatibility
security.stig.enabled.default=true
security.stig.enabled.systemProperty=${propertyPrefix}.stigEnabled

security.policyManager.forbidPasswordWhenCertPresent.description = Use certificate to authenticate when present.
security.policyManager.forbidPasswordWhenCertPresent.default=${security.stig.enabled}
security.policyManager.forbidPasswordWhenCertPresent.clusterProperty=security.policyManager.forbidPasswordWhenCertPresent
security.policyManager.forbidPasswordWhenCertPresent.visible=false

krb5Keytab.description = Kerberos keytab file data
krb5Keytab.visible = false
krb5Keytab.clusterProperty = krb5.keytab

keytabValidate.description = Validate Kerberos keytab file
keytabValidate.visible = false
keytabValidate.clusterProperty = krb5.keytab.validate


krb5Realm.description=The Realm value in the Kerberos configuration file krb5.conf.
krb5Realm.clusterProperty=krb5.realm

krb5KDC.description=The KDC value in the Kerberos configuration file krb5.conf. Supports a list of comma-separated (,) IP addresses where the first in the list is the preferred host.
krb5KDC.clusterProperty=krb5.kdc

defaultKrb5TicketCacheLifetime.default=3600
krb5TicketCacheLifetime.systemProperty=com.l7tech.common.security.kerberos.lifetime

policyorganization.maxFolderDepth.default=8
policyorganization.maxFolderDepth.systemProperty=${propertyPrefix}.maxFolderDepth

maxLdapSearchResultSize.description = The maximum number of results to return in an LDAP Identity Provider search (Integer).
maxLdapSearchResultSize.default = 50
maxLdapSearchResultSize.clusterProperty = ldap.searchMaxResults
maxLdapSearchResultSize.systemProperty = ${propertyPrefix}.maxLdapSearchResultSize
maxLdapSearchResultSize.validation.type = integer

ldap.group.searchMaxResults.description = The maximum number of results to return in an LDAP group membership search (Integer).
ldap.group.searchMaxResults.default = ${maxLdapSearchResultSize}
ldap.group.searchMaxResults.clusterProperty = ldap.group.searchMaxResults
ldap.group.searchMaxResults.systemProperty = ${propertyPrefix}.maxGroupLdapSearchResultSize
ldap.group.searchMaxResults.validation.type = integer

ldapCertIndexInterval.description=Milliseconds in between LDAP certificate indexing.
ldapCertIndexInterval.default=600000
ldapCertIndexInterval.clusterProperty=ldap.certificateIndex.interval
ldapCertIndexInterval.validation.type = long

ldapCertCacheLifetime.description=Milliseconds to keep LDAP certificates in the LDAP certificate cache.
ldapCertCacheLifetime.default=600000
ldapCertCacheLifetime.clusterProperty=ldap.certificate.cachetime
ldapCertCacheLifetime.validation.type = long

ldapCaseInsensitiveComparison.description=Compare LDAP attribute values in a case insensitive manner.
ldapCaseInsensitiveComparison.default=true
ldapCaseInsensitiveComparison.clusterProperty=ldap.attributecomparison.caseinsensitive
ldapCaseInsensitiveComparison.visible=false
ldapCaseInsensitiveComparison.validation.regex = ${regex.boolean}

request.compress.gzip.allow.description=Allow GZIP compressed requests (true/false)
request.compress.gzip.allow.default=true
request.compress.gzip.allow.clusterProperty=request.compress.gzip.allow
request.compress.gzip.allow.validation.regex = ${regex.boolean}

request.compress.gzip.soapFaultRejection.description = When a GZIP compressed request is rejected, should a SOAP Fault response be sent (true/false)
request.compress.gzip.soapFaultRejection.default = true
request.compress.gzip.soapFaultRejection.clusterProperty = request.compress.gzip.soapFaultRejection
request.compress.gzip.soapFaultRejection.validation.regex = ${regex.boolean}
request.compress.gzip.soapFaultRejection.visible = false

response.compress.gzip.allow.description = Allow GZIP compressed responses (true/false)
response.compress.gzip.allow.default = true
response.compress.gzip.allow.clusterProperty = response.compress.gzip.allow
response.compress.gzip.allow.validation.regex = ${regex.boolean}
response.compress.gzip.allow.visible = false

timestampCreatedFutureGrace.description = To accommodate clock skew, WSS timestamp created dates are permitted to be up to this far in the future (milliseconds).
timestampCreatedFutureGrace.default = 60000
timestampCreatedFutureGrace.systemProperty = ${propertyPrefix}.policy.assertion.xmlsec.ServerRequestWssTimestamp.createdFutureGrace
timestampCreatedFutureGrace.clusterProperty = security.wss.timestamp.createdFutureGrace
timestampCreatedFutureGrace.validation.type = long

timestampExpiresPastGrace.description = To accommodate clock skew, WSS timestamp expiry dates are permitted to be up to this far in the past (milliseconds).
timestampExpiresPastGrace.default = 60000
timestampExpiresPastGrace.systemProperty = ${propertyPrefix}.policy.assertion.xmlsec.ServerRequestWssTimestamp.expiresPastGrace
timestampExpiresPastGrace.clusterProperty = security.wss.timestamp.expiresPastGrace
timestampExpiresPastGrace.validation.type = long

security.xml.dsig.permittedDigestAlgorithms.description = List of message digest algorithm names that will be respected when verifying XML digital signatures.  DigestMethod and SignatureMethod references that require algorithms not on this list will not be respected.  (Comma delimited; default="MD5,SHA,SHA-1,SHA-256,SHA-384,SHA-512")
security.xml.dsig.permittedDigestAlgorithms.default = MD5,SHA,SHA-1,SHA-256,SHA-384,SHA-512
security.xml.dsig.permittedDigestAlgorithms.clusterProperty = security.xml.dsig.permittedDigestAlgorithms
security.xml.dsig.permittedDigestAlgorithms.systemProperty = com.l7tech.security.xml.dsig.permittedDigestAlgorithms

security.xml.dsig.permittedTransformAlgorithms.description = List of transform algorithm URIs that will be permitted when verifying XML digital signatures. Transforms that require algorithms not on this list will fail (Comma delimited)
security.xml.dsig.permittedTransformAlgorithms.clusterProperty = security.xml.dsig.permittedTransformAlgorithms
security.xml.dsig.permittedTransformAlgorithms.systemProperty = com.l7tech.security.xml.dsig.permittedTransformAlgorithms
security.xml.dsig.permittedTransformAlgorithms..visible = false
security.xml.dsig.permittedTransformAlgorithms.default = \
  http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#STR-Transform,\
  http://docs.oasis-open.org/wss/2004/XX/oasis-2004XX-wss-swa-profile-1.0#Attachment-Complete-Transform,\
  http://docs.oasis-open.org/wss/2004/XX/oasis-2004XX-wss-swa-profile-1.0#Attachment-Content-Only-Transform,\
  http://www.w3.org/2000/09/xmldsig#enveloped-signature,\
  http://www.w3.org/2001/10/xml-exc-c14n#,\
  http://www.w3.org/2001/10/xml-exc-c14n#WithComments

security.xml.dsig.idAttributeNames.description = Attribute names that will be recognized as ID attributes for purposes of locating Signature Reference URI targets during WS-Security processing.  The special prefix "local" matches the namespace URI against the owning element rather than the attribute.
security.xml.dsig.idAttributeNames.default = {http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd}Id\n\
 {http://schemas.xmlsoap.org/ws/2002/07/utility}Id\n\
 {http://schemas.xmlsoap.org/ws/2003/06/utility}Id\n\
 {urn:oasis:names:tc:SAML:1.0:assertion}local:AssertionID\n\
 {urn:oasis:names:tc:SAML:2.0:assertion}local:ID\n\
 Id\n\
 id\n\
 ID\n
security.xml.dsig.idAttributeNames.clusterProperty = security.xml.dsig.idAttributeNames
security.xml.dsig.idAttributeNames.systemProperty = com.l7tech.common.security.xml.idAttributeConfig

security.xml.xenc.encryptEmptyElements.description = Whether the Encrypt Element assertion should encrypt the content of empty elements. Set this to "false" to leave empty elements unencrypted. Setting this to "false" restores pre-v6.1.5 behaviour and is required for interoperability with earlier versions of the SecureSpan XML VPN Client. (true/false; default=true)
security.xml.xenc.encryptEmptyElements.clusterProperty = security.xml.xenc.encryptEmptyElements
security.xml.xenc.encryptEmptyElements.systemProperty = com.l7tech.security.xml.encryptEmptyElements
security.xml.xenc.encryptEmptyElements.default = true
security.xml.xenc.encryptEmptyElements.validation.regex = ${regex.boolean}

security.xml.xenc.decryptionAlwaysSucceeds.description = Whether attempts to decrypt XML must always appear to succeed, once the Gateway has gotten as far as obtaining the symmetric key and attempting to decrypt the CipherValue.  XML that cannot be decrypted will be replaced with a dummy element named "L7xenc:DecryptionFault" in the "http://layer7tech.com/ns/xenc/decryptionfault" namespace.  This makes it more difficult for an attacker to use the Gateway as a decryption oracle. (true/false; default=true)
security.xml.xenc.decryptionAlwaysSucceeds.clusterProperty = security.xml.xenc.decryptionAlwaysSucceeds
security.xml.xenc.decryptionAlwaysSucceeds.systemProperty = com.l7tech.security.xml.decryptionAlwaysSucceeds
security.xml.xenc.decryptionAlwaysSucceeds.default = true
security.xml.xenc.decryptionAlwaysSucceeds.validation.regex = ${regex.boolean}

security.xml.xenc.blacklist.enabled.description = Whether symmetric keys that fail to successfully decrypt XML are blacklisted on this node for a period of time.  This makes it more difficult to use the Gateway as a decryption oracle. (true/false; default=true)
security.xml.xenc.blacklist.enabled.clusterProperty = security.xml.xenc.blacklist.enabled
security.xml.xenc.blacklist.enabled.systemProperty = com.l7tech.security.xml.xenc.decryptionKeyBlacklist.enabled
security.xml.xenc.blacklist.enabled.default = true
security.xml.xenc.blacklist.enabled.validation.regex = ${regex.boolean}

security.xml.xenc.blacklist.failWhenFull.description = If true, all XML decryption attempts will immediately fail, should the decryption key blacklist become full.  (true/false; default=false)
security.xml.xenc.blacklist.failWhenFull.clusterProperty = security.xml.xenc.blacklist.failWhenFull
security.xml.xenc.blacklist.failWhenFull.systemProperty = com.l7tech.security.xml.xenc.decryptionKeyBlacklist.failWhenFull
security.xml.xenc.blacklist.failWhenFull.default = false
security.xml.xenc.blacklist.failWhenFull.validation.regex = ${regex.boolean}

security.xml.xenc.blacklist.maxFailures.description = Maximum number of XML decryption attempts that may fail before a key is blacklisted on a node (integer; default=5)
security.xml.xenc.blacklist.maxFailures.clusterProperty = security.xml.xenc.blacklist.maxFailures
security.xml.xenc.blacklist.maxFailures.systemProperty = com.l7tech.security.xml.xenc.decryptionKeyBlacklist.maxFailures
security.xml.xenc.blacklist.maxFailures.default = 5
security.xml.xenc.blacklist.maxFailures.validation.type = integer
security.xml.xenc.blacklist.maxFailures.validation.min = 0

security.xml.xenc.blacklist.capacity.description = Number of entries permitted in the decryption key blacklist (integer; default=50000)
security.xml.xenc.blacklist.capacity.clusterProperty = security.xml.xenc.blacklist.capacity
security.xml.xenc.blacklist.capacity.systemProperty = com.l7tech.security.xml.xenc.decryptionKeyBlacklist.capacity
security.xml.xenc.blacklist.capacity.default = 50000
security.xml.xenc.blacklist.capacity.validation.type = integer
security.xml.xenc.blacklist.capacity.validation.min = 0

security.xml.xenc.blacklist.maxAge.description = Minimum time a blacklisted key should remain on the blacklist.  Notwithstanding this setting, the blacklist is cleared when a node is restarted.  (timeunit; default=7d)
security.xml.xenc.blacklist.maxAge.clusterProperty = security.xml.xenc.blacklist.maxAge
security.xml.xenc.blacklist.maxAge.systemProperty = com.l7tech.security.xml.xenc.decryptionKeyBlacklist.maxAge
security.xml.xenc.blacklist.maxAge.default = 7d
security.xml.xenc.blacklist.maxAge.validation.type = timeUnit

wsdmNotificationEnabled.description = Enable WSDM subscription notifications (true/false)
wsdmNotificationEnabled.default = true
wsdmNotificationEnabled.clusterProperty = wsdm.notification.enabled
wsdmNotificationEnabled.validation.regex = ${regex.boolean}

wsdmNotificationInterval.description = The interval between WSDM subscription notification attempts (in milliseconds). Note that this only applies to metrics notifications; status changes are sent as they occur.
wsdmNotificationInterval.default = 60000
wsdmNotificationInterval.clusterProperty = wsdm.notification.interval
wsdmNotificationInterval.validation.type = long

pkix.keyUsagePolicy.description=Policy for enforcement of X.509 Key Usage and Extended Key Usage extensions (XML string; empty to use system default policy)
pkix.keyUsagePolicy.default=
pkix.keyUsagePolicy.systemProperty=com.l7tech.pkix.keyUsagePolicy
pkix.keyUsagePolicy.clusterProperty=pkix.keyUsagePolicy

pkix.keyUsage.description=Whether X.509 Key Usage and Extended Key Usage extensions should be enforced per the pkix.keyUsagePolicy. (values IGNORE and ENFORCE; default ENFORCE)
pkix.keyUsage.default=ENFORCE
pkix.keyUsage.systemProperty=com.l7tech.pkix.keyUsage
pkix.keyUsage.clusterProperty=pkix.keyUsage
pkix.keyUsage.validation.regex=\\s*(IGNORE|ENFORCE)\\s*

wss.secureConversation.defaultSessionDuration.description=The default duration for WS-SecureConversation sessions (timeunit)
wss.secureConversation.defaultSessionDuration.default=2h
wss.secureConversation.defaultSessionDuration.clusterProperty=wss.secureConversation.defaultSessionDuration
wss.secureConversation.defaultSessionDuration.validation.type = timeUnit

wss.secureConversation.maxSessions.description=The maximum number of WS-SecureConversation sessions.
wss.secureConversation.maxSessions.default=10000
wss.secureConversation.maxSessions.clusterProperty=wss.secureConversation.maxSessions
wss.secureConversation.maxSessions.validation.type=integer

wss.secureConversation.clusterSessions.description = Should WS-SecureConversation sessions be shared amongst cluster nodes (true/false)
wss.secureConversation.clusterSessions.default = false
wss.secureConversation.clusterSessions.clusterProperty = wss.secureConversation.clusterSessions
wss.secureConversation.clusterSessions.validation.regex = ${regex.boolean}

wss.secureConversation.clusterSessionsCleanupInterval.description = Interval between successive maintenance of WS-SecureConversation sessions (timeunit)
wss.secureConversation.clusterSessionsCleanupInterval.default = 33407ms
wss.secureConversation.clusterSessionsCleanupInterval.visible = false
wss.secureConversation.clusterSessionsCleanupInterval.clusterProperty = wss.secureConversation.clusterSessionsCleanupInterval
wss.secureConversation.clusterSessionsCleanupInterval.validation.type = timeUnit

outbound.secureConversation.defaultSessionDuration.description=The default duration for Outbound WS-SecureConversation sessions (timeunit)
outbound.secureConversation.defaultSessionDuration.default=2h
outbound.secureConversation.defaultSessionDuration.clusterProperty=outbound.secureConversation.defaultSessionDuration
outbound.secureConversation.defaultSessionDuration.validation.type = timeUnit

outbound.secureConversation.maxSessions.description=The maximum number of Outbound WS-SecureConversation sessions.
outbound.secureConversation.maxSessions.default=10000
outbound.secureConversation.maxSessions.clusterProperty=outbound.secureConversation.maxSessions
outbound.secureConversation.maxSessions.validation.type=integer

outbound.secureConversation.sessionPreExpiryAge.description=The pre-expiry age (timeunit; default 1 minute) for outbound secure conversation sessions.
outbound.secureConversation.sessionPreExpiryAge.default=1m
outbound.secureConversation.sessionPreExpiryAge.clusterProperty=outbound.secureConversation.sessionPreExpiryAge
outbound.secureConversation.sessionPreExpiryAge.validation.type = timeUnit

wss.decorator.mustUnderstand.description=Whether Security headers should be generated with mustUnderstand asserted (true/false; default true)
wss.decorator.mustUnderstand.default=true
wss.decorator.mustUnderstand.systemProperty=com.l7tech.common.security.xml.decorator.secHdrMustUnderstand
wss.decorator.mustUnderstand.clusterProperty=wss.decorator.mustUnderstand
wss.decorator.mustUnderstand.validation.regex = ${regex.boolean}

wss.processor.allowMultipleTimestampSignatures.description = Whether Security headers should be permitted to contain multiple Signatures covering the timestamp (true/false; default false)
wss.processor.allowMultipleTimestampSignatures.default = false
wss.processor.allowMultipleTimestampSignatures.clusterProperty = wss.processor.allowMultipleTimestampSignatures
wss.processor.allowMultipleTimestampSignatures.validation.regex = ${regex.boolean}

wss.processor.allowUnknownBinarySecurityTokens.description = Should Binary Security Tokens of an unknown type be permitted or cause security processing to fail (true/false; default false).
wss.processor.allowUnknownBinarySecurityTokens.default = false
wss.processor.allowUnknownBinarySecurityTokens.clusterProperty = wss.processor.allowUnknownBinarySecurityTokens
wss.processor.allowUnknownBinarySecurityTokens.validation.regex = ${regex.boolean}

wss.processor.strictSignatureConfirmationValidation.description = Strict enforcement of signature confirmation validation, default true.
wss.processor.strictSignatureConfirmationValidation.default = true
wss.processor.strictSignatureConfirmationValidation.clusterProperty = wss.processor.strictSignatureConfirmationValidation
wss.processor.strictSignatureConfirmationValidation.validation.regex = ${regex.boolean}

wss.processor.enableDeferredRequestProcessing.description = Allow deferred WS-Security processing of the request message (true/false; default true)
wss.processor.enableDeferredRequestProcessing.default = true
wss.processor.enableDeferredRequestProcessing.visible = false
wss.processor.enableDeferredRequestProcessing.clusterProperty = wss.processor.enableDeferredRequestProcessing
wss.processor.enableDeferredRequestProcessing.validation.regex = ${regex.boolean}

wss.decorator.digsig.messagedigest.description=Specify the default digital signature message digest algorithm used by the WSS decorator and the non-SOAP sign XML element assertion (SHA-1, SHA-256, SHA-384, or SHA-512; default SHA-1)
wss.decorator.digsig.messagedigest.default=SHA-1
wss.decorator.digsig.messagedigest.clusterProperty=wss.decorator.digsig.messagedigest
wss.decorator.digsig.messagedigest.systemProperty=com.l7tech.security.xml.decorator.digsig.messagedigest

wss.decorator.soapActorNamespaced.description = Should the SOAP 1.1 actor attribute created by the WSS decorator be in the SOAP namespace (true/false; default true)
wss.decorator.soapActorNamespaced.default = true
wss.decorator.soapActorNamespaced.clusterProperty = wss.decorator.soap.soapActorNamespaced
wss.decorator.soapActorNamespaced.systemProperty = com.l7tech.security.xml.decorator.soap.soapActorNamespaced
wss.decorator.soapActorNamespaced.validation.regex = ${regex.boolean}

wss.decorator.wsTrust200502TypeIndex.description = WS-Trust 2005/02 request type index, 0 for standard, 1 for IBM TFIM (Tivoli Federated Identity Manager) compatibility.
wss.decorator.wsTrust200502TypeIndex.default = 0
wss.decorator.wsTrust200502TypeIndex.clusterProperty = wss.decorator.wsTrustRequestTypeIndex
wss.decorator.wsTrust200502TypeIndex.systemProperty = com.l7tech.common.security.wstrust.requestTypeIndex
wss.decorator.wsTrust200502TypeIndex.validation.type=integer

wss.decorator.timestamp.omitNanos.description = Should WS-Security timestamps created dates omit nanoseconds (true/false)
wss.decorator.timestamp.omitNanos.default = false
wss.decorator.timestamp.omitNanos.clusterProperty = wss.decorator.omitNanos
wss.decorator.timestamp.omitNanos.systemProperty = com.l7tech.server.timestamp.omitNanos
wss.decorator.timestamp.omitNanos.validation.regex = ${regex.boolean}

namespaces.wss10Extras.description = Namespaces to treat as WS-Security 1.0 equivalent (space separated list)
namespaces.wss10Extras.default = http://schemas.xmlsoap.org/ws/2002/12/secext http://schemas.xmlsoap.org/ws/2002/07/secext http://schemas.xmlsoap.org/ws/2002/xx/secext http://schemas.xmlsoap.org/ws/2003/06/secext
namespaces.wss10Extras.clusterProperty = namespaces.wss10Extras
namespaces.wss10Extras.systemProperty = com.l7tech.util.wss10ExtraNs
namespaces.wss10Extras.visible = false

namespaces.wsu10Extras.description = Namespaces to treat as WS-Security 1.0 utility equivalent (space separated list)
namespaces.wsu10Extras.default = http://schemas.xmlsoap.org/ws/2002/07/utility http://schemas.xmlsoap.org/ws/2003/06/utility
namespaces.wsu10Extras.clusterProperty = namespaces.wsu10Extras
namespaces.wsu10Extras.systemProperty = com.l7tech.util.wsu10ExtraNs
namespaces.wsu10Extras.visible = false

namespaces.soap11Extras.description = Namespaces to treat as SOAP 1.1 equivalent (space separated list)
namespaces.soap11Extras.default = http://www.w3.org/2001/06/soap-envelope http://www.w3.org/2001/09/soap-envelope urn:schemas-xmlsoap-org:soap.v1
namespaces.soap11Extras.clusterProperty = namespaces.soap11Extras
namespaces.soap11Extras.systemProperty = com.l7tech.util.soap11ExtraNs
namespaces.soap11Extras.visible = false

security.fips.enabled.description = Enable only FIPS-compliant cryptographic algorithms.  (true/false)
security.fips.enabled.default=false
security.fips.enabled.clusterProperty=security.fips.enabled
security.fips.enabled.systemProperty=com.l7tech.security.fips.enabled
security.fips.enabled.validation.regex = ${regex.boolean}

security.pcidss.enabled.description= Enable PCI-DSS. (true/false)
security.pcidss.enabled.default= false
security.pcidss.enabled.clusterProperty=security.pcidss.enabled
security.pcidss.enabled.validation.regex = ${regex.boolean}

rbac.autoRole.manageService.autoAssign.description=Whether a non-admin user should be added to the auto-created Manage Service role when they successfully create a new Published Service (true/false; default true)
rbac.autoRole.manageService.autoAssign.default=true
rbac.autoRole.manageService.autoAssign.clusterProperty=rbac.autoRole.manageService.autoAssign
rbac.autoRole.manageService.autoAssign.validation.regex=${regex.boolean}

rbac.autoRole.managePolicy.autoAssign.description=Whether a non-admin user should be added to the auto-created Manage Policy role when they successfully create a new Policy (true/false; default true)
rbac.autoRole.managePolicy.autoAssign.default=true
rbac.autoRole.managePolicy.autoAssign.clusterProperty=rbac.autoRole.managePolicy.autoAssign
rbac.autoRole.managePolicy.autoAssign.validation.regex=${regex.boolean}

rbac.autoRole.manageProvider.autoAssign.description=Whether a non-admin user should be added to the auto-created Manage Identity Provider role when they successfully create a new Identity Provider (true/false; default true)
rbac.autoRole.manageProvider.autoAssign.default=true
rbac.autoRole.manageProvider.autoAssign.clusterProperty=rbac.autoRole.manageProvider.autoAssign
rbac.autoRole.manageProvider.autoAssign.validation.regex=${regex.boolean}

# //todo move into modular assertion meta()
jdbcQuery.maxRecords.defaultValue.description=Default maximum number of records allowed to return from querying (records; default 10)
jdbcQuery.maxRecords.defaultValue.default=10
jdbcQuery.maxRecords.defaultValue.clusterProperty=jdbcQuery.maxRecords.defaultValue
jdbcQuery.maxRecords.defaultValue.validation.type=integer

jdbcQuery.maxClobSizeOut.description=Maximum size allowed for a CLOB output variable from a Procedure or Function call. Default is 10MB.
jdbcQuery.maxClobSizeOut.default=10485760
jdbcQuery.maxClobSizeOut.clusterProperty=jdbcQuery.maxClobSizeOut
jdbcQuery.maxClobSizeOut.validation.type=long

jdbcQuery.maxBlobSizeOut.description=Maximum size allowed for a BLOB output variable from a Procedure or Function call. Default is 10MB.
jdbcQuery.maxBlobSizeOut.default=10485760
jdbcQuery.maxBlobSizeOut.clusterProperty=jdbcQuery.maxBlobSizeOut
jdbcQuery.maxBlobSizeOut.validation.type=long

jdbcQueryManager.cacheMetaData.enable.description=Permit or disallow caching of procedure / function meta data. If enabled lazy caching will happen as meta data is downloaded. Connections referenced via a context variable will always require lazy caching.
jdbcQueryManager.cacheMetaData.enable.default=true
jdbcQueryManager.cacheMetaData.enable.clusterProperty=jdbcQueryManager.cacheMetaData.enable
jdbcQueryManager.cacheMetaData.enable.validation.regex=${regex.boolean}

jdbcQueryManager.cacheMetaDataTask.enable.description=Enable / Disable background task to eagerly cache procedure / function meta data.
jdbcQueryManager.cacheMetaDataTask.enable.default=true
jdbcQueryManager.cacheMetaDataTask.enable.clusterProperty=jdbcQueryManager.cacheMetaDataTask.enable
jdbcQueryManager.cacheMetaDataTask.enable.validation.regex=${regex.boolean}

jdbcQueryManager.cacheRefreshInterval.description=Interval in milliseconds between when background task to update meta data cache is ran. Default is 10 minutes.
jdbcQueryManager.cacheRefreshInterval.default=600000
jdbcQueryManager.cacheRefreshInterval.clusterProperty=jdbcQueryManager.cacheRefreshInterval
jdbcQueryManager.cacheRefreshInterval.validation.type=long

jdbcQueryManager.cacheCleanUpInterval.description=Interval in milliseconds between when background clean up task to clear cached exceptions is ran. Default is 1 minute.
jdbcQueryManager.cacheCleanUpInterval.default=60000
jdbcQueryManager.cacheCleanUpInterval.clusterProperty=jdbcQueryManager.cacheCleanUpInterval
jdbcQueryManager.cacheCleanUpInterval.validation.type=long

jdbcQueryManager.cacheStaleTimeout.description=Maximum meta data cache age. Any cached meta data older than this value will be cleared from the cache. Value is a second value. Default is 30 minutes
jdbcQueryManager.cacheStaleTimeout.default=1800
jdbcQueryManager.cacheStaleTimeout.clusterProperty=jdbcQueryManager.cacheStaleTimeout
jdbcQueryManager.cacheStaleTimeout.validation.type=long

jdbcQueryManager.cacheKeyNoUsageExpiration.description=Maximum expiration for a managed meta data cache key. Default is 2678400 (31 days). Value is a second value.
jdbcQueryManager.cacheKeyNoUsageExpiration.default=2678400
jdbcQueryManager.cacheKeyNoUsageExpiration.clusterProperty=jdbcQueryManager.cacheKeyNoUsageExpiration
jdbcQueryManager.cacheKeyNoUsageExpiration.validation.type=long

jdbcQueryManager.minCacheConcurrency.description=The number of threads the background cache meta data task uses. Default is 10, maximum value is 200, minimum value is 1.
jdbcQueryManager.minCacheConcurrency.default=10
jdbcQueryManager.minCacheConcurrency.clusterProperty=jdbcQueryManager.minCacheConcurrency
jdbcQueryManager.minCacheConcurrency.validation.type=integer

jdbcQueryManager.maxGatewayStatementTimeout.description=Maximum Statement query time allowed on the Gateway in seconds. Default is 300 seconds (5 minutes), minimum value is 1.
jdbcQueryManager.maxGatewayStatementTimeout.default=300
jdbcQueryManager.maxGatewayStatementTimeout.clusterProperty=jdbcQueryManager.maxGatewayStatementTimeout
jdbcQueryManager.maxGatewayStatementTimeout.validation.type=integer

jdbcQueryManager.cacheTaskStatementTimeout.description=Maximum Statement query time allowed for queries from the meta data cache background task. Default is 120 seconds
jdbcQueryManager.cacheTaskStatementTimeout.default=120
jdbcQueryManager.cacheTaskStatementTimeout.clusterProperty=jdbcQueryManager.cacheTaskStatementTimeout
jdbcQueryManager.cacheTaskStatementTimeout.validation.type=integer

jdbcConnection.pooling.maxPoolSize.defaultValue.description=Default maximum number of Connections a pool will maintain at any given time (connections; default 15)
jdbcConnection.pooling.maxPoolSize.defaultValue.default=15
jdbcConnection.pooling.maxPoolSize.defaultValue.clusterProperty=jdbcConnection.pooling.maxPoolSize.defaultValue
jdbcConnection.pooling.maxPoolSize.defaultValue.validation.type=integer

jdbcConnection.pooling.minPoolSize.defaultValue.description=Default minimum number of Connections a pool will maintain at any given time (connections; default 3)
jdbcConnection.pooling.minPoolSize.defaultValue.default=3
jdbcConnection.pooling.minPoolSize.defaultValue.clusterProperty=jdbcConnection.pooling.minPoolSize.defaultValue
jdbcConnection.pooling.minPoolSize.defaultValue.validation.type=integer

jdbcConnection.driverClass.defaultList.description=The default list of supported database driver classes (a list of driver classes).  Each driver class is separated by a new line character.
jdbcConnection.driverClass.defaultList.default=com.mysql.jdbc.Driver\ncom.l7tech.jdbc.mysql.MySQLDriver\ncom.l7tech.jdbc.db2.DB2Driver\ncom.l7tech.jdbc.oracle.OracleDriver\ncom.l7tech.jdbc.sqlserver.SQLServerDriver
jdbcConnection.driverClass.defaultList.clusterProperty=jdbcConnection.driverClass.defaultList

jdbcConnection.driverClass.whiteList.description=The list of database driver classes which the JDBC Query Assertion is allowed to use (ie, a white list).  Note: these driver classes may not be supported.  Each driver class is separated by a new line character.
jdbcConnection.driverClass.whiteList.default=com.mysql.jdbc.Driver\ncom.l7tech.jdbc.mysql.MySQLDriver\ncom.l7tech.jdbc.db2.DB2Driver\ncom.l7tech.jdbc.oracle.OracleDriver\ncom.l7tech.jdbc.sqlserver.SQLServerDriver
jdbcConnection.driverClass.whiteList.systemProperty=${propertyPrefix}.jdbcDriver

jdbcConnection.driverClass.whiteListValidate.description= Validate that the driver class used in a JDBC Connection was registered in the JDBC driver white list. Default is true.
jdbcConnection.driverClass.whiteListValidate.default= true
jdbcConnection.driverClass.whiteListValidate.systemProperty=${propertyPrefix}.jdbcDriverValidate
jdbcConnection.driverClass.whiteListValidate.validation.regex=${regex.boolean}

builtinService.snmpQuery.enabled.description=Enable/disable the built-in service, "HTTP-based SNMP query service" (true/false; default true)
builtinService.snmpQuery.enabled.default=true
builtinService.snmpQuery.enabled.clusterProperty=builtinService.snmpQuery.enabled
builtinService.snmpQuery.enabled.validation.regex = ${regex.boolean}

# 10485760 = 1024 * 1024 * 10
documentDownload.maxSize.description=Maximum default size in bytes of a document download, or 0 for unlimited (Integer). Default is 10MB.
documentDownload.maxSize.default=10485760
documentDownload.maxSize.systemProperty=${propertyPrefix}.documentDownload.maxSize
documentDownload.maxSize.validation.type=long

wsdlDocMaxDownloadSize.description = Maximum size in bytes of a WSDL document download, or 0 for unlimited (Integer).
wsdlDocMaxDownloadSize.default = ${documentDownload.maxSize}
wsdlDocMaxDownloadSize.clusterProperty = wsdlDownload.maxSize
wsdlDocMaxDownloadSize.validation.type=long

xslDocMaxDownloadSize.description = Maximum size in bytes of a XSL document download, or 0 for unlimited (Integer).
xslDocMaxDownloadSize.default = ${documentDownload.maxSize}
xslDocMaxDownloadSize.clusterProperty = xslDownload.maxSize
xslDocMaxDownloadSize.validation.type=long

otherTextualContentTypes.description=Other textual content types. Default are (text, xml, json and form encoded). Each content type must be on a new line and may include a charset e.g. application/custom; charset="UTF-8"
otherTextualContentTypes.clusterProperty = contentType.otherTextualTypes

audit.setDetailLevel.SEVERE.description=Set the audit detail level for all listed audit codes to 'SEVERE'. Space separated list.
audit.setDetailLevel.SEVERE.clusterProperty=audit.setDetailLevel.SEVERE
audit.setDetailLevel.SEVERE.visible=false

audit.setDetailLevel.WARNING.description=Set the audit detail level for all listed audit codes to 'WARNING'. Space separated list.
audit.setDetailLevel.WARNING.clusterProperty=audit.setDetailLevel.WARNING
audit.setDetailLevel.WARNING.visible=false

audit.setDetailLevel.INFO.description=Set the audit detail level for all listed audit codes to 'INFO'. Space separated list.
audit.setDetailLevel.INFO.clusterProperty=audit.setDetailLevel.INFO
audit.setDetailLevel.INFO.visible=false

audit.setDetailLevel.CONFIG.description=Set the audit detail level for all listed audit codes to 'CONFIG'. Space separated list.
audit.setDetailLevel.CONFIG.clusterProperty=audit.setDetailLevel.CONFIG
audit.setDetailLevel.CONFIG.visible=false

audit.setDetailLevel.FINE.description=Set the audit detail level for all listed audit codes to 'FINE'. Space separated list.
audit.setDetailLevel.FINE.clusterProperty=audit.setDetailLevel.FINE
audit.setDetailLevel.FINE.visible=false

audit.setDetailLevel.FINER.description=Set the audit detail level for all listed audit codes to 'FINER'. Space separated list.
audit.setDetailLevel.FINER.clusterProperty=audit.setDetailLevel.FINER
audit.setDetailLevel.FINER.visible=false

audit.setDetailLevel.FINEST.description=Set the audit detail level for all listed audit codes to 'FINEST'. Space separated list.
audit.setDetailLevel.FINEST.clusterProperty=audit.setDetailLevel.FINEST
audit.setDetailLevel.FINEST.visible=false

audit.auditDetailExcludeList.description=The audit detail messages never to audit. Space separated list.
audit.auditDetailExcludeList.clusterProperty=audit.auditDetailExcludeList
audit.auditDetailExcludeList.visible=false

audit.validateSignature.maxrecords.description=The maximum amount of audit records signatures to validate at a time. Min 100. Max 1000.
audit.validateSignature.maxrecords.clusterProperty=audit.validateSignature.maxrecords
audit.validateSignature.maxrecords.default=100
audit.validateSignature.maxrecords.visible=false
audit.validateSignature.maxrecords.validation.type=integer
audit.validateSignature.maxrecords.validation.min=100
audit.validateSignature.maxrecords.validation.max=1000

audit.search.maxMessageSize.description=The maximum audited message in bytes the Gateway will read into memory when searching. Default 2.5MB. Min 1KB . Max 20MB.
audit.search.maxMessageSize.clusterProperty=audit.search.maxMessageSize
audit.search.maxMessageSize.default=2621440
audit.search.maxMessageSize.visible=false
audit.search.maxMessageSize.validation.type=long
audit.search.maxMessageSize.validation.min=1024
audit.search.maxMessageSize.validation.max=20971520

audit.messageSizeLimit.description=The maximum audit message in bytes the gateway will record or 0 for no limit
audit.messageSizeLimit.default=10485760
audit.messageSizeLimit.clusterProperty=audit.messageSizeLimit
audit.messageSizeLimit.validation.type=long
audit.messageSizeLimit.validation.min=0

audit.lookup.cache.messageSizeLimit.description=The maximum audit message in bytes the gateway will cache from the audit lookup policy or 0 for no limit. Default 10MB
audit.lookup.cache.messageSizeLimit.default=10485760
audit.lookup.cache.messageSizeLimit.clusterProperty=audit.lookup.cache.messageSizeLimit
audit.lookup.cache.messageSizeLimit.validation.type=long
audit.lookup.cache.messageSizeLimit.validation.min=0

httpDigest.enable.description=Enable storage of digest password compatible with HTTP Digest
httpDigest.enable.clusterProperty=httpDigest.enable
httpDigest.enable.default=false
httpDigest.enable.visible=false

audit.export.group_concat_max_len.description=Session value for MySQL group_concat_max_len server variable set when exporting audits. Minimum value is 1024 bytes.
audit.export.group_concat_max_len.clusterProperty=audit.export.group_concat_max_len
audit.export.group_concat_max_len.default=1048576

db.replicationDelayCheckInterval.description = Interval between updates (and checking) of the replicated sequence value, zero to disable monitoring (timeunit)
db.replicationDelayCheckInterval.default = 10s
db.replicationDelayCheckInterval.clusterProperty = db.replicationDelayCheckInterval
db.replicationDelayCheckInterval.visible = false
db.replicationDelayCheckInterval.validation.type = timeUnit

db.replicationDelayThreshold.description = Threshold for auditing a warning due to slow or failed replication, zero to disable audits (timeunit)
db.replicationDelayThreshold.default = 60s
db.replicationDelayThreshold.clusterProperty = db.replicationDelayThreshold
db.replicationDelayThreshold.validation.type = timeUnit

db.replicationErrorAuditInterval.description = The minimum interval between successive database replication failure audits (timeunit)
db.replicationErrorAuditInterval.default = 60m
db.replicationErrorAuditInterval.clusterProperty = db.replicationErrorAuditInterval
db.replicationErrorAuditInterval.validation.type = timeUnit

datetime.customFormats.description=Custom Date/Time input format values separated by semicolon
datetime.customFormats.default=<Timestamp>;\
  \n<Millisecond Timestamp>;\
  \n<Second Timestamp>;\
  \nyyyy-MM-dd'T'HH:mm:ss.SSSXXX;\
  \nyyyy-MM-dd'T'HH:mm:ss.SSXXX;\
  \nyyyy-MM-dd'T'HH:mm:ss.SXXX;\
  \nyyyy-MM-dd'T'HH:mm:ssXXX;\
  \nyyyy-MM-dd'T'HH:mmXXX;\
  \nyyyy-MM-dd;\
  \nyyyy-MM;\
  \nyyyy;\
  \nEEE, dd MMM yyyy HH:mm:ss z;\
  \nEEE, dd MMM yy HH:mm:ss Z;\
  \nEEE, dd-MMM-yy HH:mm:ss z;\
  \nEEE MMM dd HH:mm:ss yyyy
datetime.customFormats.clusterProperty = datetime.customFormats

datetime.autoFormats.description=Simple Date Formats followed by a space then the Regular Expression that will match it. All expressions must begin with ^ and end with $
datetime.autoFormats.default=yyyy-MM-dd'T'HH:mm:ss.SSSXXX ^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}(?:Z|(?:\\+|-)\\d{2}:\\d{2})$\
  \nyyyy-MM-dd'T'HH:mm:ss.SSXXX ^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{2}(?:Z|(?:\\+|-)\\d{2}:\\d{2})$\
  \nyyyy-MM-dd'T'HH:mm:ss.SXXX ^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{1}(?:Z|(?:\\+|-)\\d{2}:\\d{2})$\
  \nyyyy-MM-dd'T'HH:mm:ssXXX ^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:Z|(?:\\+|-)\\d{2}:\\d{2})$\
  \nyyyy-MM-dd'T'HH:mmXXX ^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}(?:Z|(?:\\+|-)\\d{2}:\\d{2})$\
  \nyyyy-MM-dd ^\\d{4}-\\d{2}-\\d{2}$\
  \nyyyy-MM ^\\d{4}-\\d{2}$\
  \nyyyy ^\\d{4}$\
  \nEEE, dd MMM yyyy HH:mm:ss z ^[a-zA-Z]{3},\\s\\d{2}\\s[a-zA-Z]{3}\\s\\d{4}\\s\\d{2}:\\d{2}:\\d{2}\\s(?:[a-zA-Z]{3}|(?:\\+|-)\\d{4})$\
  \nEEE, dd MMM yy HH:mm:ss Z ^[a-zA-Z]{3},\\s\\d{2}\\s[a-zA-Z]{3}\\s\\d{2}\\s\\d{2}:\\d{2}:\\d{2}\\s(?:[a-zA-Z]{3}|(?:\\+|-)\\d{4})$ \
  \nEEE, dd-MMM-yy HH:mm:ss z ^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday),\\s\\d{2}-[a-zA-Z]{3}-\\d{2}\\s\\d{2}:\\d{2}:\\d{2}\\s(?:[a-zA-Z]{3}|(?:\\+|-)\\d{4})$\
  \nEEE MMM dd HH:mm:ss yyyy ^[a-zA-Z]{3}\\s[a-zA-Z]{3}\\s(\\d{2}|\\s\\d)\\s\\d{2}:\\d{2}:\\d{2}\\s\\d{4}$
datetime.autoFormats.clusterProperty = datetime.autoFormats
datetime.autoFormats.visible = false

commons.httpclient.ntlm.flags.description=NTLM negotiate flags in HEX. 0x0 sets to standard negotiate flags value. This property should be only used if the AD server performing NTLM authentication is so obscure that it doesn't support default NTLM settings. Please refer to NTLM spec (http://msdn.microsoft.com/en-us/library/cc236621%28v=PROT.13%29.aspx) about the flag value
commons.httpclient.ntlm.flags.default=0x0
commons.httpclient.ntlm.flags.clusterProperty = commons.httpclient.ntlm.flags
commons.httpclient.ntlm.flags.visible = false

throughputQuota.enforce_max_quota.description = Enforce the maximum throughput quota value
throughputQuota.enforce_max_quota.default=false
throughputQuota.enforce_max_quota.clusterProperty = throughputquota.enforce_max_quota
throughputQuota.enforce_max_quota.visible = false
throughputQuota.enforce_max_quota.validation.regex = ${regex.boolean}

throughputQuota.max_throughput_quota.description = Maximum throughput quota value. Only applies when maximum quota is enforced.
throughputQuota.max_throughput_quota.default=2147483647
throughputQuota.max_throughput_quota.clusterProperty = throughputquota.max_throughput_quota
throughputQuota.max_throughput_quota.visible = false
throughputQuota.max_throughput_quota.validation.type = long

io.httpChallengeOrder.description=Define legacy order challenges in HTTP response. Values are: \n"reverse" order: NTLM, Negotiate, Digest, Basic \n"windows" order: Negotiate, NTLM, Digest, Basic
io.httpChallengeOrder.default=windows
io.httpChallengeOrder.clusterProperty = io.httpChallengeOrder


