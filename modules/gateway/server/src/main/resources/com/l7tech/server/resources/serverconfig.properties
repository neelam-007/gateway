# suppress inspection "UnusedProperty" for whole file
#
# Server Configuration Properties (used by ServerConfig)
#

#
# FYI: When defining a property with a default of another property e.g. myproperty.default= ${myotherprop},
# then myotherprop should only be available as a system property. It is not currently intended for default
# properties to be dynamic.
# If it is also available as a cluster property, and a value has been supplied (i.e. it exists in cluster_properties)
# then on gateway start up, it is possible that the value used for myotherprop will be its default value
# and not the value from the database, depending on whether or not the default values in the cache have expired
# or not before the property is read. Really only an issue if the value is read once during assertion initialization
# for example
#

# Validation patterns
regex.boolean = (?i)true|false

# Shutdown delay
ssg.shutdownDelay.description = Seconds to wait during shutdown after stopping SSG components.
ssg.shutdownDelay.default = 0

# Numeric server ID (default generated from IP address)
serverId.description = Numeric server identifier
serverId.systemProperty = ${propertyPrefix}.serverId

# Multicast address (default generated randomly)
multicastAddress.description = Cluster multicast address
multicastAddress.systemProperty = ${propertyPrefix}.multicastAddress

### Hazelcast Data Grid Configuration ###
dataGrid.protocol.description = The protocol Hazelcast uses to discover cluster members. Valid values: tcpip. Requires restart for all nodes in the Gateway cluster.
dataGrid.protocol.default = tcpip
dataGrid.protocol.clusterProperty = dataGrid.protocol
dataGrid.protocol.systemProperty = ${propertyPrefix}.dataGrid.protocol
dataGrid.protocol.validation.regex = tcpip

dataGrid.tcpip.connectionTimeout.description = Sets the connection timeout in seconds. This is the maximum amount of time Hazelcast will try to connect to a well known member before giving up. Requires restart for all nodes in the Gateway cluster.
dataGrid.tcpip.connectionTimeout.default = 5
dataGrid.tcpip.connectionTimeout.clusterProperty = dataGrid.tcpip.connectionTimeout
dataGrid.tcpip.connectionTimeout.systemProperty = ${propertyPrefix}.dataGrid.tcpip.connectionTimeout
dataGrid.tcpip.connectionTimeout.validation.type = integer
dataGrid.tcpip.connectionTimeout.validation.min = 1

# ldap templates path
ldapTemplatesPath.description = LDAP templates path
ldapTemplatesPath.systemProperty = ${propertyPrefix}.ldapTemplatesPath

# uddi templates path
uddiTemplatesPath.description = UDDI templates path
uddiTemplatesPath.systemProperty = ${propertyPrefix}.uddiTemplatesPath

# directory for ssg log files
logDirectory.description = Directory for SSG log files
logDirectory.default = ${ssg.var}${fs}logs
logDirectory.systemProperty = ${propertyPrefix}.logDirectory

# template for log file pattern
#  0 - "default_"
#  1 - sink name (e.g. "ssg")
#  2 - "%g" the generation number to distinguish rotated logs
#  3 - "%u" a unique number to resolve conflicts
logFileTemplate.description = Template for log filename pattern ('{1}' is sink name, '{2}' the generation number to distinguish rotated logs, '{3}' a unique number to resolve file conflicts)
logFileTemplate.default = {1}_{2}_{3}.log
logFileTemplate.systemProperty = ${propertyPrefix}.logFileTemplate
logFileTemplate.clusterProperty = log.filenameTemplate

# customized logger levels
logLevels.description = Log level configuration (one level per line)
logLevels.default = com.l7tech.level = CONFIG
logLevels.clusterProperty = log.levels

logStdOutLevel.description = Log level to use for logging of messages captured from standard output (FINEST|FINER|FINE|INFO|WARNING|SEVERE)
logStdOutLevel.default = INFO
logStdOutLevel.clusterProperty = log.stdoutLevel
logStdOutLevel.validation.regex = FINEST|FINER|FINE|INFO|WARNING|SEVERE

logStdErrLevel.description = Log level to use for logging of messages captured from standard error (FINEST|FINER|FINE|INFO|WARNING|SEVERE)
logStdErrLevel.default = WARNING
logStdErrLevel.clusterProperty = log.stderrLevel
logStdErrLevel.validation.regex = FINEST|FINER|FINE|INFO|WARNING|SEVERE

# Allows use of a cluster property to override the JceProvider engine
security.jceProviderEngineName.description=Override JceProvider engine name, or empty for no override (engine name; default empty)
security.jceProviderEngineName.visible=false
security.jceProviderEngineName.systemProperty=com.l7tech.common.security.jceProviderEngineName
security.jceProviderEngineName.clusterProperty=security.jceProviderEngineName

# comma-separated list of IP addresses (defaults to all)
ipAddresses.description = IP addresses
ipAddresses.systemProperty = ${propertyPrefix}.ipAddresses

#
# The defaultHttpPort and defaultHttpsPort are kept up-to-date dynamically by the
# SsgConnectorManager, pointing at an HTTP or HTTPS port (respectively) that has
# the service OTHER_SERVLETS enabled, or removed completely whenever an appropriate
# connector doesn't exist.
#
defaultHttpPort.default = 8080
defaultHttpPort.mutable = true
httpPort.description = HTTP listening port for built-in services
httpPort.default = ${defaultHttpPort}
httpPort.systemProperty = ${propertyPrefix}.httpPort

defaultHttpsPort.default = 8443
defaultHttpsPort.mutable = true
httpsPort.description = HTTPS listening port for built-in services
httpsPort.default = ${defaultHttpsPort}
httpsPort.systemProperty = ${propertyPrefix}.httpsPort

interfaceTags.visible = false
interfaceTags.description = Available named interfaces and their corresponding address pattern lists.  This is intended to be edited using the special GUI in the SSM.
interfaceTags.default = loopback(127.0.0.1)
interfaceTags.clusterProperty = interfaceTags

httpSessionName.default = ssgsessionid
httpSessionName.description = Session parameter and cookie name to be used by tomcat for session identification.
httpSessionName.systemProperty = ${propertyPrefix}.httpSessionId

#
# The port used for internode communications in a cluster
#
clusterPortOld.visible = false
clusterPortOld.description = Inter-Node communication port for clusters
clusterPortOld.default = 0
clusterPortOld.clusterProperty = cluster.internodePort
clusterPortOld.validation.type = integer
clusterPortOld.validation.min = 0
clusterPortOld.validation.max = 65535

clusterNodePort.description = Inter-Node communication port for clusters
clusterNodePort.default = 2124
clusterNodePort.mutable = true

clusterAdminAppletPort.description = The port used for Browser-based Administration.
clusterAdminAppletPort.default = 9443
clusterAdminAppletPort.clusterProperty = cluster.adminAppletPort
clusterAdminAppletPort.mutable = true
clusterAdminAppletPort.validation.type = integer
clusterAdminAppletPort.validation.min = 1
clusterAdminAppletPort.validation.max = 65535

#
# The host used for accessing the cluster
#
defaultClusterHost.default =
defaultClusterHost.systemProperty = com.l7tech.server.defaultClusterHostname

clusterHost.description = External hostname for the cluster
clusterHost.default = ${defaultClusterHost}
clusterHost.clusterProperty = cluster.hostname

#
# Following two settings should be modified if the cluster is configured in such a
# way that port forwarding is used
#
clusterhttpport.description = External HTTP port for the cluster
clusterhttpport.default = ${httpPort}
clusterhttpport.systemProperty = ${propertyPrefix}.clusterHttpPort
clusterhttpport.clusterProperty = cluster.httpPort
clusterhttpport.validation.type = integer
clusterhttpport.validation.min = 1
clusterhttpport.validation.max = 65535

clusterhttpsport.description = External HTTPS port for the cluster
clusterhttpsport.default = ${httpsPort}
clusterhttpsport.systemProperty = ${propertyPrefix}.clusterHttpsPort
clusterhttpsport.clusterProperty = cluster.httpsPort
clusterhttpsport.validation.type = integer
clusterhttpsport.validation.min = 1
clusterhttpsport.validation.max = 65535

clusterMasterNode.description = The identifier of the master node in the cluster.
clusterMasterNode.clusterProperty = cluster.masterNodeId
clusterMasterNode.visible = false

# hostname (defaults to OS hostname)
hostname.description = Hostname
hostname.systemProperty = ${propertyPrefix}.hostname

# system properties path
systemPropertiesPath.description = System properties path
systemPropertiesPath.default = ${configDirectory}${fs}system.properties
systemPropertiesPath.systemProperty = ${propertyPrefix}.systemPropertiesPath

#custom assertions (file name or resource name)
custom.assertions.file = custom_assertions.properties
#custom assertions modules dir
custom.assertions.modules.description = Directory in which to find custom assertion jar files
custom.assertions.modules.default = ${ssg.run}${fs}modules${fs}lib
custom.assertions.modules.systemProperty = ${propertyPrefix}.custom.assertions.modules
#custom assertions working dir
custom.assertions.temp.description = Directory where custom assertions extract dependent jars upon load
custom.assertions.temp.default = ${ssg.var}${fs}modules
custom.assertions.temp.systemProperty = ${propertyPrefix}.custom.assertions.temp
#enable/disable custom assertions hot-swap
custom.assertions.rescan.enable.description = Enable or disable custom assertion modules hot-swap.
custom.assertions.rescan.enable.default = true
custom.assertions.rescan.enable.systemProperty = ${propertyPrefix}.custom.assertions.rescan.enable
#custom assertions scanner timeout
custom.assertions.rescan.millis.description = Milliseconds in between checks to see if the custom assertion modules directory timestamp has changed.
custom.assertions.rescan.millis.default = 4523
custom.assertions.rescan.millis.systemProperty = ${propertyPrefix}.custom.assertions.rescan.millis
#enable/disable custom assertions scanner
custom.assertions.scan.disable.description = Enable or disable custom assertion modules scanner.
custom.assertions.scan.disable.default = false
custom.assertions.scan.disable.systemProperty = ${propertyPrefix}.custom.assertions.scan.disable

# ldap fallback timeout
# the time (in ms) for which the ldap connector will not try to reconnect to
# a particular ldap url when the connection failed
ldap.reconnect.timeout.description = LDAP reconnect timeout. Number of milliseconds (between 0 and 999999) to wait before retrying a connection to an unresponsive LDAP server.
ldap.reconnect.timeout.default = 60000
ldap.reconnect.timeout.systemProperty = ${propertyPrefix}.ldap.reconnect.timeout
ldap.reconnect.timeout.clusterProperty = ldap.reconnect.timeout
ldap.reconnect.timeout.validation.regex = \\d{1,6}

ldapConnectionTimeout.description = LDAP connection timeout.  A value less than or equal to zero seconds means to use the network protocol's (i.e., TCP's) timeout value.
ldapConnectionTimeout.default = 5s
ldapConnectionTimeout.clusterProperty = ldap.connection.timeout
ldapConnectionTimeout.validation.type = timeUnit

ldapReadTimeout.description =  LDAP read timeout.  A value less than or equal to zero seconds means it will wait for the response infinitely until it is received.
ldapReadTimeout.default = 30s
ldapReadTimeout.clusterProperty = ldap.read.timeout
ldapReadTimeout.validation.type = timeUnit

ldapSimpleUsernamePattern.description = Regular expression that any username must match when being combined into a DN using the Simple LDAP provider.
ldapSimpleUsernamePattern.default = ^[\\p{Alnum}\\.\\-\\_]+$
ldapSimpleUsernamePattern.clusterProperty = ldap.simple.username.pattern

ldapReferral.description = How LDAP referrals should be handled.  Possible values are "follow" or "ignore". (default=follow)
ldapReferral.default = follow
ldapReferral.clusterProperty = ldap.referral
ldapReferral.validation.regex = follow|ignore|throw

ldapIgnorePartialResultException.description = Whether a PartialResultException should be ignored if encountered while iterating an LDAP search result. (default=true)
ldapIgnorePartialResultException.systemProperty = ${propertyPrefix}.ldap.ignorePartialResultException
ldapIgnorePartialResultException.default = true
ldapIgnorePartialResultException.validation.regex = ${regex.boolean}

# serverconfig name must be same as cluster property name for this property
trace.policy.guid.description = GUID of internal policy to invoke after each assertion finished, when debug tracing is enabled for a published service (default=empty)
trace.policy.guid.default =
trace.policy.guid.clusterProperty = trace.policy.guid
trace.policy.guid.visible = false

# Audit settings
audit.external.name.description = Name of the datasource to use for external audit persistence.
audit.external.name.default =
audit.external.name.clusterProperty = audit.external.name

audit.sink.policy.guid.description = GUID of internal policy to invoke when flushing audit messages, or empty to use internal audit database (default=empty)
audit.sink.policy.guid.default =
audit.sink.policy.guid.clusterProperty = audit.sink.policy.guid
audit.sink.policy.guid.visible = false

audit.lookup.policy.guid.description = GUID of internal policy to invoke when retrieving audit messages from an external source, or empty to use internal audit database (default=empty)
audit.lookup.policy.guid.default =
audit.lookup.policy.guid.clusterProperty = audit.lookup.policy.guid
audit.lookup.policy.guid.visible = false

# Though this is a hidden property, it is being used by a customer to turn auditing off programatically
# and so any change must be mentioned in release notes or communicated to the customer in question
audit.sink.alwaysSaveInternal.description = If true, audit records will always be saved to the internal database, even if they were successfully processed via a configured audit sink policy. (default=false)
audit.sink.alwaysSaveInternal.default = false
audit.sink.alwaysSaveInternal.clusterProperty = audit.sink.alwaysSaveInternal
audit.sink.alwaysSaveInternal.visible = false
audit.sink.alwaysSaveInternal.validation.regex = ${regex.boolean}

# Though this is a hidden property, it is being used by a customer to turn auditing off programatically
# and so any change must be mentioned in release notes or communicated to the customer in question
audit.sink.fallbackToInternal.description = If true, audit records will be saved to the internal database if auditing to a configured audit sink fails.  If false, an error message will be logged and the audit record will be lost. (default=true)
audit.sink.fallbackToInternal.default = true
audit.sink.fallbackToInternal.clusterProperty = audit.sink.fallbackToInternal
audit.sink.fallbackToInternal.validation.regex = ${regex.boolean}

audit.sink.url.description = Default URL to which audit records will be posted via HTTP, if the default audit sink policy is enabled.  (default = http://localhost:4680/ )
audit.sink.url.default = http://localhost:4680/
audit.sink.url.clusterProperty = audit.sink.url

audit.lockMessages.description = Should audit messages be locked after registration of known messages (boolean)
audit.lockMessages.default = true
audit.lockMessages.systemProperty = com.l7tech.gateway.common.audit.lockMessages

auditMessageThreshold.description = Minimum level required of a Message Audit Record for it to be saved to the database (Level)
auditMessageThreshold.default = WARNING
auditMessageThreshold.systemProperty = ${propertyPrefix}.audit.messageThreshold
auditMessageThreshold.clusterProperty = audit.messageThreshold

auditAdminThreshold.description = Minimum level required of an Admin Audit Record for it to be saved to the database (Level)
auditAdminThreshold.default = INFO
auditAdminThreshold.systemProperty = ${propertyPrefix}.audit.adminThreshold
auditAdminThreshold.clusterProperty = audit.adminThreshold

# associated logs threshold
auditAssociatedLogsThreshold.default = INFO
auditAssociatedLogsThreshold.description = Minimum level required of an Audit Detail Message for it to be saved to the database (Level)
auditAssociatedLogsThreshold.clusterProperty = audit.detailThreshold

# client component system logs threshold
auditClientSystemLogsThreshold.default = WARNING
auditClientSystemLogsThreshold.description = Minimum level required of an System Audit Record for a client component for it to be saved to the database (Level)
auditClientSystemLogsThreshold.clusterProperty = audit.clientServicesThreshold

auditHintingEnabled.description = Enable audit messages to provide hints for audited information, such as request XML (true/false)
auditHintingEnabled.default = false
auditHintingEnabled.systemProperty = ${propertyPrefix}.audit.hinting
auditHintingEnabled.clusterProperty = audit.hinting
auditHintingEnabled.validation.regex = ${regex.boolean}

auditAssertionStatusEnabled.description = Use the highest assertion status level when checking if a record should be saved (true/false)
auditAssertionStatusEnabled.default = true
auditAssertionStatusEnabled.systemProperty = ${propertyPrefix}.audit.assertionStatus
auditAssertionStatusEnabled.clusterProperty = audit.assertionStatus
auditAssertionStatusEnabled.validation.regex = ${regex.boolean}

auditAssociatedLogsThresholdRespected.description = Use the audit detail level when checking if a record should be saved (true/false)
auditAssociatedLogsThresholdRespected.default = true
auditAssociatedLogsThresholdRespected.systemProperty = ${propertyPrefix}.audit.detailThresholdRespected
auditAssociatedLogsThresholdRespected.clusterProperty = audit.detailThresholdRespected
auditAssociatedLogsThresholdRespected.validation.regex = ${regex.boolean}

# audit logging format
auditLogFormatServiceHeader.description = Format for the first log message of a service audit
auditLogFormatServiceHeader.default = Processing request for service: {3}
auditLogFormatServiceHeader.clusterProperty = audit.log.service.headerFormat

auditLogFormatServiceFooter.description = Format for the final (summary) log message of a service audit
auditLogFormatServiceFooter.default = {1}
auditLogFormatServiceFooter.clusterProperty = audit.log.service.footerFormat

auditLogFormatServiceDetail.description = Format for details related to a service audit
auditLogFormatServiceDetail.default = {0}: {1}
auditLogFormatServiceDetail.clusterProperty = audit.log.service.detailFormat

auditLogFormatOther.description = Format used for other (non-service) audit logs (i.e. System/Admin audits)
auditLogFormatOther.default = {1}
auditLogFormatOther.clusterProperty = audit.log.other.format

auditLogFormatOtherDetail.description = Format used for other (non-service) audit details (i.e. System/Admin audits)
auditLogFormatOtherDetail.default = {0}: {1}
auditLogFormatOtherDetail.clusterProperty = audit.log.other.detailFormat

# default = 1 week
auditPurgeMinimumAge.description = Minimum age of Audit Records that can be purged (Hours)
auditPurgeMinimumAge.default = 168
auditPurgeMinimumAge.systemProperty = ${propertyPrefix}.audit.purgeMinimumAge
auditPurgeMinimumAge.clusterProperty = audit.purgeMinimumAge
auditPurgeMinimumAge.validation.type = integer

auditSigningEnabled.description = Sign audited data (true/false)
auditSigningEnabled.default = false
auditSigningEnabled.systemProperty = ${propertyPrefix}.audit.sign
auditSigningEnabled.clusterProperty = audit.signing
auditSigningEnabled.validation.regex = ${regex.boolean}

auditBatchExternal.description = Should audit information be batched when logging (true/false)
auditBatchExternal.default = true
auditBatchExternal.systemProperty = ${propertyPrefix}.audit.batchExternal
auditBatchExternal.clusterProperty = audit.batchExternal
auditBatchExternal.validation.regex = ${regex.boolean}

audit.originalMainPart.enable.description = Enable saving the original document for requests and responses.  This enables use of the .originalMainPart suffix for Message variables.  Note: Enabling this option reduces performance and may double the quantity of memory used during message processing.  Consider reducing the maximum concurrency to compensate. (true/false; default = false)
audit.originalMainPart.enable.default = false
audit.originalMainPart.enable.systemProperty = com.l7tech.message.enableOriginalDocument
audit.originalMainPart.enable.clusterProperty = audit.originalMainPart.enable
audit.originalMainPart.enable.validation.regex = ${regex.boolean}

audit.adminExceptions.auditPermissionDenied.description = Should permission denials for administrative users be audited (true/false)
audit.adminExceptions.auditPermissionDenied.default = true
audit.adminExceptions.auditPermissionDenied.clusterProperty = audit.adminExceptions.auditPermissionDenied
audit.adminExceptions.auditPermissionDenied.visible = false
audit.adminExceptions.auditPermissionDenied.validation.regex = ${regex.boolean}

audit.adminExceptions.excludes.description = List of exception classes that should be excluded from auditing during administrative calls (space separated list)
audit.adminExceptions.excludes.default =
audit.adminExceptions.excludes.clusterProperty = audit.adminExceptions.excludes
audit.adminExceptions.excludes.visible = false

audit.includeClusterPropertyValues.description = Should audit values of cluster property changes (true/false)
audit.includeClusterPropertyValues.default = false
audit.includeClusterPropertyValues.clusterProperty = audit.includeClusterPropertyValues
audit.includeClusterPropertyValues.validation.regex = ${regex.boolean}

logBuffer.messageSize.description = Maximum permitted size for unformatted log message (characters)
logBuffer.messageSize.default = 4096
logBuffer.messageSize.systemProperty = ${propertyPrefix}.logBuffer.messageSize
logBuffer.messageSize.clusterProperty = log.buffer.messageSizeLimit
logBuffer.messageSize.validation.type = integer

logBuffer.paramSize.description = Maximum permitted size for unformatted log message parameter (characters)
logBuffer.paramSize.default = 4096
logBuffer.paramSize.systemProperty = ${propertyPrefix}.logBuffer.paramSize
logBuffer.paramSize.clusterProperty = log.buffer.parameterSizeLimit
logBuffer.paramSize.validation.type = integer

auditArchiverTimerPeriod.description = Time period in seconds for scheduling the AuditArchiver task, or 0 to disable.
auditArchiverTimerPeriod.default = 600
auditArchiverTimerPeriod.clusterProperty = audit.archiverTimerPeriod
auditArchiverTimerPeriod.validation.type = integer

auditArchiverStaleTimeout.description = Timeout, in minutes, after which an "in progress" archive job is considered stale and dead, so that other nodes can steal the lock.
auditArchiverStaleTimeout.default = 120
auditArchiverStaleTimeout.clusterProperty = audit.archiverStaleTimeout
auditArchiverStaleTimeout.validation.type = integer

auditArchiverBatchSize.description = Number of audit records to be processed by one archiver job. Max 10000.
auditArchiverBatchSize.default = 1000
auditArchiverBatchSize.clusterProperty = audit.archiverBatchSize
auditArchiverBatchSize.validation.type = integer
auditArchiverBatchSize.validation.max = 10000

auditArchiverInProgress.description = Used as the underlying mechanism with the ClusterLock; not exposed in the UI.
auditArchiverInProgress.default =
auditArchiverInProgress.clusterProperty = audit.archiverInProgress
auditArchiverInProgress.visible = false

auditArchiverShutdownThreshold.description = The Gateway will either shut down and/or stop auditing once disk space usage exceeds this threshold (in percentage). The action taken is set in the audit.managementStrategy cluster property. Default value is 90 (percent).
auditArchiverShutdownThreshold.default = 90
auditArchiverShutdownThreshold.clusterProperty = audit.archiverShutdownThreshold
auditArchiverShutdownThreshold.validation.type = integer
auditArchiverShutdownThreshold.validation.min = 0
auditArchiverShutdownThreshold.validation.max = 100

auditArchiverWarningThreshold.description = The AuditArchiver will issue an early warning to alert users if the current database usage (percent) is above this threshold.
auditArchiverWarningThreshold.default = 50
auditArchiverWarningThreshold.clusterProperty = audit.archiverWarningThreshold
auditArchiverWarningThreshold.validation.type = integer
auditArchiverWarningThreshold.validation.min = 0
auditArchiverWarningThreshold.validation.max = 100

auditArchiverStartThreshold.description = Archiving of audit records will start when database disk usage (percentage) is above this threshold.
auditArchiverStartThreshold.default = 75
auditArchiverStartThreshold.clusterProperty = audit.archiverStartThreshold
auditArchiverStartThreshold.validation.type = integer
auditArchiverStartThreshold.validation.min = 0
auditArchiverStartThreshold.validation.max = 100

auditArchiverStopThreshold.description = Archiving of audit records will stop when database disk usage (percentage) drops below this threshold.
auditArchiverStopThreshold.default = 50
auditArchiverStopThreshold.clusterProperty = audit.archiverStopThreshold
auditArchiverStopThreshold.validation.type = integer
auditArchiverStopThreshold.validation.min = 0
auditArchiverStopThreshold.validation.max = 100

auditArchiverFtpConfig.description = The serialized form of the FTP configuration where the archiver backs up the audit logs; not exposed in UI.
auditArchiverFtpConfig.default =
auditArchiverFtpConfig.clusterProperty = audit.archiver.ftp.config
auditArchiverFtpConfig.visible = false

auditArchiverFtpFileprefix.description = The prefix for the audit archives file to be uploaded.
auditArchiverFtpFileprefix.default = SSGAuditArchive-
auditArchiverFtpFileprefix.clusterProperty = audit.archiver.ftp.fileprefix

auditArchiverFtpMaxUploadFileSize.description = Maximum file size to be uploaded (bytes). Should be large enough to accommodate the largest audit record, and smaller than the FTP server's filesize limit, if any.
auditArchiverFtpMaxUploadFileSize.default = 2000000000
auditArchiverFtpMaxUploadFileSize.clusterProperty = audit.archiver.ftp.maxfilesize
auditArchiverFtpMaxUploadFileSize.validation.type = long

auditManagementStrategy.description = Specify how the Gateway should respond when the database exceeds the threshold defined in the audit.archivershutdownthreshold cluster property:\n  * STOP: Gateway stops processing requests and terminates audit logging.\n  * BYPASS: Gateway continues processing requests but terminates audit logging. Internal Gateway logging continues, with a SEVERE-level message that audit logging has stopped.\nDefault value is STOP.
auditManagementStrategy.default = STOP
auditManagementStrategy.clusterProperty = audit.managementStrategy
auditManagementStrategy.validation.regex = STOP|BYPASS

# default = /ssg/var/attachments
attachmentDirectory.description = Directory in which to cache large SOAP attachments
attachmentDirectory.default = ${ssg.var}${fs}attachments
attachmentDirectory.systemProperty = ${propertyPrefix}.attachmentDirectory

# default = /ssg/var/messageCache
messageCacheDirectory.description = Directory in which to cache large response messages from the backend
messageCacheDirectory.default = ${ssg.var}${fs}messageCache
messageCacheDirectory.systemProperty = ${propertyPrefix}.messageCacheDirectory

# default = /ssg/modules/assertions
modularAssertionsDirectory.description = Directory in which to find modular assertion jarfiles
modularAssertionsDirectory.default = ${ssg.run}${fs}modules${fs}assertions
modularAssertionsDirectory.systemProperty = ${propertyPrefix}.modularAssertionsDirectory

modularAssertionsRescanMillis.description = Milliseconds in between checks to see if the modules directory timestamp has changed
modularAssertionsRescanMillis.default = 4523
modularAssertionsRescanMillis.systemProperty = ${propertyPrefix}.modularAssertionsRescanMillis

modularAssertionsFileExtensions.description = Space separated list of file extensions (including leading dot) that will be considered as modular assertions.  Set to a single dash to disable scanning for modules
modularAssertionsFileExtensions.default = .jar .assertion .ass .assn .aar
modularAssertionsFileExtensions.systemProperty = ${propertyPrefix}.modularAssertionsFileExtensions

# default = 131071
attachmentDiskThreshold.description = Threshold for size of attachments in a single request to keep in RAM (Bytes)
attachmentDiskThreshold.default = 1048576
attachmentDiskThreshold.systemProperty = ${propertyPrefix}.attachmentDiskThreshold
attachmentDiskThreshold.clusterProperty = attachment.diskThreshold
attachmentDiskThreshold.validation.type = integer

# default = 9096
messageCacheDiskThreshold.description = Threshold for size of messages to be cached on disk (Bytes)
messageCacheDiskThreshold.default = 8096
messageCacheDiskThreshold.systemProperty = ${propertyPrefix}.messageCacheDiskThreshold
messageCacheDiskThreshold.clusterProperty = messageCache.diskThreshold
messageCacheDiskThreshold.validation.type = integer

messageCacheResetGeneration.description = Incrementing the generation number clears all message caches created under a different generation number.
messageCacheResetGeneration.default = 0
messageCacheResetGeneration.systemProperty = ${propertyPrefix}.messageCacheResetGeneration
messageCacheResetGeneration.clusterProperty = messageCache.resetGeneration

# Symantec AntiVirus ScanEngine (savseEnable = yes to enable scanning)
savseEnable.description = Whether or not this gateway has access to a sav scan engine to do virus scanning
savseEnable.default = no
savseEnable.systemProperty = ${propertyPrefix}.savseEnable

# The hostname of the sav se
savseHost.description = The hostname of the sav scan engine that this gateway can connect to
savseHost.default = 127.0.0.1
savseHost.systemProperty = ${propertyPrefix}.savseHost

# The port of the sav se
savsePort.description = The port number associated with the savseHost property
savsePort.default = 7777
savsePort.systemProperty = ${propertyPrefix}.savsePort

metricsFineInterval.description = Time interval for Service Metrics fine resolution bins (Milliseconds). (Note: A cluster-wide restart is required for changes to apply.)
metricsFineInterval.default = 5000
metricsFineInterval.systemProperty = com.l7tech.service.metrics.fineBinInterval
metricsFineInterval.clusterProperty = metrics.fineInterval
metricsFineInterval.validation.type = long

# passthrough filter for wsdl and policy downloads (requests for such documents will not require authentication
# if they come from an ip address below mentioned)
# for example, a value could look like "127.0.0.1 192.168" and would allow localhost as well as anything starting with 192.168
passthroughDownloads.description = Remote IPs of requestors allowed to download WSDL and policy documents without credentials (Space separated list)
passthroughDownloads.default = 127.0.0.1
passthroughDownloads.systemProperty = com.l7tech.service.passthroughdownloads
passthroughDownloads.clusterProperty = service.passthroughdownloads

service.disabledServiceDownloads.description = Which requestors can download WSDL and policy documents for disabled services. Use "none" to forbid, "all" for all requestors or "passthrough" to permit requestors defined by "service.passthroughdownloads" (none|passthrough|all)
service.disabledServiceDownloads.default = none
service.disabledServiceDownloads.clusterProperty = service.disabledDownloads
service.disabledServiceDownloads.validation.regex = none|all|passthrough

service.anonFederatedPolicies.description = Treat policies containing all federated identity assertions as though they contained no identity assertions, for purposes of checking whether a policy allows anonymous access.  In an identity bridging use case, this allows an XVC from another trust domain to download the policy for a federated service.  (true/false)
service.anonFederatedPolicies.default = true
service.anonFederatedPolicies.clusterProperty = service.anonFederatedPolicies
service.anonFederatedPolicies.validation.regex = ${regex.boolean}

# IO timeout settings
ioInReadTimeout.description = IO timeout for incoming requests (Milliseconds)
ioInReadTimeout.default = 60000
ioInReadTimeout.systemProperty = ${propertyPrefix}.timeout
ioInReadTimeout.clusterProperty = io.timeout
ioInReadTimeout.validation.type = long

ioInSlowReadThreshold.description = IO timeout for incoming request rate checking (Milliseconds)
ioInSlowReadThreshold.default = 60000
ioInSlowReadThreshold.systemProperty = ${propertyPrefix}.rateTimeout
ioInSlowReadThreshold.clusterProperty = io.rateTimeout
ioInSlowReadThreshold.validation.type = long

ioInSlowReadRate.description = Minimum permissible rate for incoming requests (Bytes per second)
ioInSlowReadRate.default = 1024
ioInSlowReadRate.systemProperty = ${propertyPrefix}.rateLimit
ioInSlowReadRate.clusterProperty = io.rateLimit
ioInSlowReadRate.validation.type = long

ioOutConnectionTimeout.description = IO timeout for outbound connection (Milliseconds)
ioOutConnectionTimeout.default = 30000
ioOutConnectionTimeout.systemProperty = ${propertyPrefix}.outConnectTimeout
ioOutConnectionTimeout.clusterProperty = io.outConnectTimeout
ioOutConnectionTimeout.validation.type = long

ioOutReadTimeout.description = IO timeout for outbound response (Milliseconds)
ioOutReadTimeout.default = 60000
ioOutReadTimeout.systemProperty = ${propertyPrefix}.outTimeout
ioOutReadTimeout.clusterProperty = io.outTimeout
ioOutReadTimeout.validation.type = long

ioFailoverServerRetryDelay.description = The delay before retrying a failed server when using a "Round-Robin" or "Ordered Sticky with Failover" failover strategy. This setting is used by assertions with a failover strategy such as the Route via HTTP(S), Route via SecureSpan Bridge, and Scan Using ICAP-Enabled Antivirus assertions. A value of zero means the default delay for the selected failover strategy is used (Milliseconds)
ioFailoverServerRetryDelay.default = 0
ioFailoverServerRetryDelay.clusterProperty = io.failoverServerRetryDelay
ioFailoverServerRetryDelay.systemProperty = com.l7tech.common.io.failover.robin.retryMillis
ioFailoverServerRetryDelay.validation.type = integer
ioFailoverServerRetryDelay.validation.min = 0

ioHttpsHostVerify.description = Verify server host names against certificate name (true/false)
ioHttpsHostVerify.default = true
ioHttpsHostVerify.clusterProperty = io.httpsHostVerify
ioHttpsHostVerify.validation.regex = ${regex.boolean}

ioHttpsHostAllowWildcard.description = Allow wildcards when verifying hostnames (true/false)
ioHttpsHostAllowWildcard.default = false
ioHttpsHostAllowWildcard.clusterProperty = io.httpsHostAllowWildcard
ioHttpsHostAllowWildcard.validation.regex = ${regex.boolean}

ioHttpsAcceptedClientCa.description = A list of certificate PEM strings, delimited with the character ','. When set, this will be presented by the SSL listeners as a list of trusted client CA names.
ioHttpsAcceptedClientCa.clusterProperty=io.httpsAcceptedClientCa
ioHttpsAcceptedClientCa.systemProperty=com.l7tech.security.ssl.acceptedclientca
ioHttpsAcceptedClientCa.visible=false

io.https.response.truncationProtection.disable.description = Set to true to disable response truncation attack protection for outbound HTTPS.  (true/false; default=false)
io.https.response.truncationProtection.disable.default = false
io.https.response.truncationProtection.disable.clusterProperty = io.https.response.truncationProtection.disable
io.https.response.truncationProtection.disable.validation.regex = ${regex.boolean}

ioHttpUseExpectContinue.description = Use an HTTP 1.1 Expect/Continue handshake (true/false)
ioHttpUseExpectContinue.default = false
ioHttpUseExpectContinue.clusterProperty = io.httpExpectContinue
ioHttpUseExpectContinue.validation.regex = ${regex.boolean}

ioHttpNoKeepAlive.description = Disable HTTP Keep-Alive connections for outbound HTTP connections (other than routing assertions) (true/false)
ioHttpNoKeepAlive.default = false
ioHttpNoKeepAlive.clusterProperty = io.httpDisableKeepAlive
ioHttpNoKeepAlive.validation.regex = ${regex.boolean}

ioHttpHeadersToSkip.description = List of HTTP headers to skip when passing outbound request or inbound response headers (comma-separated list)
ioHttpHeadersToSkip.default = Connection, Content-Encoding, Content-Length, Content-Type, Date, Keep-Alive, Server, Transfer-Encoding, Host
ioHttpHeadersToSkip.clusterProperty = io.httpHeadersToSkip
ioHttpHeadersToSkip.systemProperty = com.l7tech.policy.assertion.HttpPassthroughRuleSet.headersToSkip
ioHttpHeadersToSkip.visible = false

ioHttpVersion.description = The HTTP version to use (1.0/1.1)
ioHttpVersion.default = 1.1
ioHttpVersion.clusterProperty = io.httpVersion
ioHttpVersion.validation.regex = 1.0|1.1

ioHttpDefaultContentType.description = The value of the "Content-Type" HTTP header to use if a response does not have a "Content-Type" header (no default value).
ioHttpDefaultContentType.clusterProperty = io.httpDefaultContentType
ioHttpDefaultContentType.systemProperty = ${propertyPrefix}.ioHttpDefaultContentType

ioHttpDefaultContentTypeCharset.description = The value of the "Content-Type" HTTP header charset to use if a response does not have a "Content-Type" header charset (no default value).
ioHttpDefaultContentTypeCharset.clusterProperty = io.httpDefaultContentTypeCharset
ioHttpDefaultContentTypeCharset.systemProperty = ${propertyPrefix}.ioHttpDefaultContentTypeCharset
ioHttpDefaultContentTypeCharset.visible = false

ioHttpResponseStreaming.description = True to allow streaming of HTTP responses when possible (true/false, default true)
ioHttpResponseStreaming.default = true
ioHttpResponseStreaming.clusterProperty = io.httpResponseStreaming
ioHttpResponseStreaming.validation.regex = ${regex.boolean}

ioHttpResponseStreamUnlimited.description = Ignore the message size limit when streaming HTTP responses (true/false, default true)
ioHttpResponseStreamUnlimited.default = true
ioHttpResponseStreamUnlimited.clusterProperty = io.httpResponseStreamUnlimited
ioHttpResponseStreamUnlimited.validation.regex = ${regex.boolean}

ioHttpPoolMaxIdleTime.description = Time an idle thread will wait for additional work before shutting down (milliseconds)
ioHttpPoolMaxIdleTime.default = 60000
ioHttpPoolMaxIdleTime.systemProperty = ${propertyPrefix}.ioHttpPoolMaxIdleTime
ioHttpPoolMaxIdleTime.validation.type = long

ioHttpPoolMaxConcurrency.description = Maximum number of concurrent active HTTP connections.  This is a hard upper limit.
ioHttpPoolMaxConcurrency.default = 750
ioHttpPoolMaxConcurrency.systemProperty = ${propertyPrefix}.ioHttpPoolMaxConcurrency
ioHttpPoolMaxConcurrency.clusterProperty = io.httpMaxConcurrency
ioHttpPoolMaxConcurrency.validation.type = integer

ioHttpPoolMinSpareThreads.description = Core number of concurrent active HTTP connections.  This is a soft limit that can be temporarily exceeded if necessary.  A negative number means to use a fraction of io.httpMaxConcurrency (ie, -5 would mean one fifth of the maximum).
ioHttpPoolMinSpareThreads.default = 500
ioHttpPoolMinSpareThreads.systemProperty = ${propertyPrefix}.ioHttpPoolMinSpareThreads
ioHttpPoolMinSpareThreads.clusterProperty = io.httpCoreConcurrency
ioHttpPoolMinSpareThreads.validation.type = integer

ioHttpProxy.description = Default HTTP Proxy configuration.
ioHttpProxy.systemProperty = ${propertyPrefix}.ioHttpProxy
ioHttpProxy.clusterProperty = ioHttpProxy
ioHttpProxy.visible = false

ioHttpConnectionIdleInterval.description = Interval between checks for outbound HTTP connection timeout (timeunit)
ioHttpConnectionIdleInterval.default = 5s
ioHttpConnectionIdleInterval.systemProperty = com.l7tech.server.transport.http.httpConnectionIdleInterval
ioHttpConnectionIdleInterval.clusterProperty = io.httpConnectionIdleInterval
ioHttpConnectionIdleInterval.validation.type = timeUnit
ioHttpConnectionIdleInterval.visible = false

ioHttpConnectionIdleTimeout.description = Maximum idle time for outbound HTTP connections, 0 for no timeout (timeunit)
ioHttpConnectionIdleTimeout.default = 5s
ioHttpConnectionIdleTimeout.systemProperty = com.l7tech.server.transport.http.httpConnectionIdleTimeout
ioHttpConnectionIdleTimeout.clusterProperty = io.httpConnectionIdleTimeout
ioHttpConnectionIdleTimeout.validation.type = timeUnit
ioHttpConnectionIdleTimeout.visible = false

ioHttpConnectionTestingEnabled.description = Should idle outbound HTTP connections be tested to ensure they are valid (boolean)
ioHttpConnectionTestingEnabled.default = true
ioHttpConnectionTestingEnabled.systemProperty = com.l7tech.common.http.prov.apache.staleCheckEnabled
ioHttpConnectionTestingEnabled.clusterProperty = io.httpConnectionTestingEnabled
ioHttpConnectionTestingEnabled.validation.regex = ${regex.boolean}
ioHttpConnectionTestingEnabled.visible = false

ioHttpQueryUseSemicolonAsSeparator.description = When set to 'true' semicolon is used as a http query separator in addition to '&'. Default is 'false'
ioHttpQueryUseSemicolonAsSeparator.default = false
ioHttpQueryUseSemicolonAsSeparator.systemProperty = com.l7tech.http.useSemicolonAsSeparator
ioHttpQueryUseSemicolonAsSeparator.clusterProperty = io.httpQueryUseSemicolonAsSeparator
ioHttpQueryUseSemicolonAsSeparator.validation.regex = ${regex.boolean}
ioHttpQueryUseSemicolonAsSeparator.visible = false

ioEnableAutoChallenge.description = Enable Auto Challenge when preemptive authentication is used. Default is 'false'
ioEnableAutoChallenge.default = false
ioEnableAutoChallenge.systemProperty = com.l7tech.common.http.prov.apache.CommonsHttpClient.enableAutoChallenge
ioEnableAutoChallenge.clusterProperty = io.httpEnableAutoChallenge
ioEnableAutoChallenge.validation.regex = ${regex.boolean}
ioEnableAutoChallenge.visible = false

ioJmsErrorSleep.description = Time to sleep after a connection error for an inbound JMS Queue (timeunit)
ioJmsErrorSleep.default = 60s
ioJmsErrorSleep.clusterProperty = jms.connectErrorSleep
ioJmsErrorSleep.validation.type = timeUnit

ioJmsResponseTimeout.description = Timeout for JMS routing to wait on the replyTo queue in milliseconds, default 10 seconds.
ioJmsResponseTimeout.default = 10000
ioJmsResponseTimeout.clusterProperty = jms.responseTimeout
ioJmsResponseTimeout.validation.type = long

ioJmsConnectionCacheMaxAge.description = Maximum age for cached JMS connections or 0 for no limit (timeunit)
ioJmsConnectionCacheMaxAge.default = 10m
ioJmsConnectionCacheMaxAge.clusterProperty = io.jmsConnectionCacheMaxAge
ioJmsConnectionCacheMaxAge.validation.type = timeUnit

ioJmsConnectionCacheMaxIdleTime.description = The maximum time an idle JMS connection will be cached or 0 for no limit (timeunit)
ioJmsConnectionCacheMaxIdleTime.default = 5m
ioJmsConnectionCacheMaxIdleTime.clusterProperty = io.jmsConnectionCacheMaxIdleTime
ioJmsConnectionCacheMaxIdleTime.validation.type = timeUnit

ioJmsConnectionIdleTime.description = The maximum time an idle JMS connection will stay in the connection pool when the number of idle connections exceeds the specified idle connection limit. Enter 0 or less for no limit (timeunit)
ioJmsConnectionIdleTime.default = 5m
ioJmsConnectionIdleTime.clusterProperty = io.jmsConnectionIdleTime
ioJmsConnectionIdleTime.validation.type = timeUnit

ioJmsConnectionCacheSize.description = The number of JMS connections to cache, this is not a hard limit, 0 for no caching (Integer)
ioJmsConnectionCacheSize.default = 100
ioJmsConnectionCacheSize.clusterProperty = io.jmsConnectionCacheMaxSize
ioJmsConnectionCacheSize.validation.type = integer

ioJmsConnectionPoolSize.description = The maximum JMS Connection pool size. Can be set in between 1 and 10000. Default is 1.
ioJmsConnectionPoolSize.default = 1
ioJmsConnectionPoolSize.clusterProperty = io.jmsConnectionPoolSize
ioJmsConnectionPoolSize.validation.type = integer
ioJmsConnectionPoolSize.validation.min = 1
ioJmsConnectionPoolSize.validation.max = 10000

ioJmsConnectionMinIdle.description = The minimum number of reserved idle connections in the connection pool (maximum 10000). Default 0
ioJmsConnectionMinIdle.default = 0
ioJmsConnectionMinIdle.clusterProperty = io.jmsConnectionMinIdle
ioJmsConnectionMinIdle.validation.type = integer
ioJmsConnectionMinIdle.validation.min = 0
ioJmsConnectionMinIdle.validation.max = 10000

ioJmsConnectionMaxWait.description = Maximum waiting time while acquiring JMS Connection. Enter 0 or less for no limit (timeunit).
ioJmsConnectionMaxWait.default = 5s
ioJmsConnectionMaxWait.clusterProperty = io.jmsConnectionMaxWait
ioJmsConnectionMaxWait.validation.type = timeUnit
ioJmsConnectionMaxWait.validation.max = 999999999

ioJmsConnectionTimeBetweenEviction.description = Determines the interval in milliseconds between pool cleanup thread runs. Default is 10 seconds (timeunit).
ioJmsConnectionTimeBetweenEviction.default  = 10s
ioJmsConnectionTimeBetweenEviction.clusterProperty = io.jmsConnectionTimeBetweenEviction
ioJmsConnectionTimeBetweenEviction.validation.type = timeUnit
ioJmsConnectionTimeBetweenEviction.validation.min = 0

ioJmsConnectionEvictionBatchSize.description = The amount of expired idle connections to be collected during each run of the JMS connection pool cleanup task. Can be between 1 and 10000. Default value is 1
ioJmsConnectionEvictionBatchSize.default = 1
ioJmsConnectionEvictionBatchSize.clusterProperty = io.jmsConnectionEvictionBatchSize
ioJmsConnectionEvictionBatchSize.validation.type = integer
ioJmsConnectionEvictionBatchSize.validation.min = 1
ioJmsConnectionEvictionBatchSize.validation.max = 10000

ioJmsSessionPoolSize.description = Specify the maximum number of sessions that can be allocated by the session pool (maximum 10000). Enter -1 to indicate no limit. Default is 8.
ioJmsSessionPoolSize.default = 8
ioJmsSessionPoolSize.clusterProperty = io.jmsSessionPoolSize
ioJmsSessionPoolSize.validation.type = integer
ioJmsSessionPoolSize.validation.min = -1
ioJmsSessionPoolSize.validation.max = 10000

ioJmsSessionMaxIdle.description = The maximum number of sessions that can sit idle in the session pool (maximum 10000). Enter -1 to indicate no limit. Default 8
ioJmsSessionMaxIdle.default = 8
ioJmsSessionMaxIdle.clusterProperty = io.jmsSessionMaxIdle
ioJmsSessionMaxIdle.validation.type = integer
ioJmsSessionMaxIdle.validation.min = -1
ioJmsSessionMaxIdle.validation.max = 10000

ioJmsSessionMaxWait.description = The maximum period of time to wait for an idle session when the pool is exhausted. Enter 0 or less for no limit (timeunit). Default 5 seconds.
ioJmsSessionMaxWait.default = 5s
ioJmsSessionMaxWait.clusterProperty = io.jmsSessionMaxWait
ioJmsSessionMaxWait.validation.type = timeUnit
ioJmsSessionMaxWait.validation.max = 999999999

ioJmsEndpointListenerFactory.description = The endpoint listener type to use (Simple|Pooled)
ioJmsEndpointListenerFactory.default = Pooled
ioJmsEndpointListenerFactory.clusterProperty = io.jmsEndpointListenerFactory
ioJmsEndpointListenerFactory.visible = false

ioJmsMessageMaxBytes.description = Maximum number of bytes permitted for a JMS message, or 0 for unlimited (Integer)
ioJmsMessageMaxBytes.default = 2621440
ioJmsMessageMaxBytes.systemProperty = ${propertyPrefix}.jmsMessageMaxBytes
ioJmsMessageMaxBytes.clusterProperty = io.jmsMessageMaxBytes
ioJmsMessageMaxBytes.validation.type = long
ioJmsMessageMaxBytes.validation.min = 0

ioJmsRoutingRetrySleep.description = Time to sleep after a connection error for an outbound JMS Queue (timeunit)
ioJmsRoutingRetrySleep.default = 1s
ioJmsRoutingRetrySleep.systemProperty = com.l7tech.server.policy.assertion.jmsRoutingRetryDelay
ioJmsRoutingRetrySleep.clusterProperty = io.jmsRoutingRetrySleep
ioJmsRoutingRetrySleep.validation.type = timeUnit
ioJmsRoutingRetrySleep.validation.min = 0

ioJmsRoutingMaxRetries.description = Maximum number of connection attempts for an outbound JMS Queue.
ioJmsRoutingMaxRetries.default = 5
ioJmsRoutingMaxRetries.systemProperty = com.l7tech.server.policy.assertion.jmsRoutingMaxRetries
ioJmsRoutingMaxRetries.clusterProperty = io.jmsRoutingMaxRetries
ioJmsRoutingMaxRetries.validation.type = integer
ioJmsRoutingMaxRetries.validation.min = 1

ioJmsConsumerConnections.description = Number of JMS consumer connections for an inbound JMS Queue.
ioJmsConsumerConnections.default = 1
ioJmsConsumerConnections.systemProperty = ${propertyPrefix}.jmsConsumerConnections
ioJmsConsumerConnections.clusterProperty = io.jmsConsumerConnections
ioJmsConsumerConnections.validation.type = integer
ioJmsConsumerConnections.validation.min = 1
ioJmsConsumerConnections.validation.max = 10000

ioMqRoutingRetrySleep.description = Time to sleep after a connection error for an outbound MQ Queue (timeunit)
ioMqRoutingRetrySleep.default = 1s
ioMqRoutingRetrySleep.systemProperty = com.l7tech.external.assertions.mqnative.server.routingRetryDelay
ioMqRoutingRetrySleep.clusterProperty = io.mqRoutingRetrySleep
ioMqRoutingRetrySleep.validation.type = timeUnit
ioMqRoutingRetrySleep.validation.min = 0

ioMqRoutingMaxRetries.description = Maximum number of connection attempts for an outbound MQ Queue.
ioMqRoutingMaxRetries.default = 5
ioMqRoutingMaxRetries.systemProperty = com.l7tech.external.assertions.mqnative.server.routingMaxRetries
ioMqRoutingMaxRetries.clusterProperty = io.mqRoutingMaxRetries
ioMqRoutingMaxRetries.validation.type = integer
ioMqRoutingMaxRetries.validation.min = 1

ioMqMessageMaxBytes.description = Maximum number of bytes permitted for a MQ Native Queue message, or 0 for unlimited (Integer)
ioMqMessageMaxBytes.default = 2621440
ioMqMessageMaxBytes.systemProperty = ${propertyPrefix}.mqMessageMaxBytes
ioMqMessageMaxBytes.clusterProperty = io.mqMessageMaxBytes
ioMqMessageMaxBytes.validation.type = long
ioMqMessageMaxBytes.validation.min = 0

ioMqRoutingSetAllContext.description = Whether or not to set MQPMO_SET_ALL_CONTEXT option in the PutMsgOpts parameter when a message is put on a queue (true/false)
ioMqRoutingSetAllContext.default = false
ioMqRoutingSetAllContext.systemProperty = com.l7tech.external.assertions.mqnative.server.setAllContext
ioMqRoutingSetAllContext.clusterProperty = io.mqRoutingSetAllContext
ioMqRoutingSetAllContext.validation.regex = ${regex.boolean}

ioMqIncludeReplyToQueueManagerName.description=Enable / Disable specification of the replyToQueueManagerName in a reply MQ Native Queue Message from an inbound MQ Queue when the property is included in the request Message.
ioMqIncludeReplyToQueueManagerName.default=true
ioMqIncludeReplyToQueueManagerName.systemProperty = ${propertyPrefix}.includeReplyToQueueManagerName
ioMqIncludeReplyToQueueManagerName.clusterProperty=io.mqIncludeReplyToQueueManagerName
ioMqIncludeReplyToQueueManagerName.validation.regex=${regex.boolean}

ioMqConvertMessageApplicationDataFormat.description=Enable / Disable conversion of MQ Message application data by inclusion of MQGMO_CONVERT flag in MQGET calls.
ioMqConvertMessageApplicationDataFormat.default=true
ioMqConvertMessageApplicationDataFormat.systemProperty = ${propertyPrefix}.convertMessageApplicationDataFormat
ioMqConvertMessageApplicationDataFormat.clusterProperty=io.mqConvertMessageApplicationDataFormat
ioMqConvertMessageApplicationDataFormat.validation.regex=${regex.boolean}

ioMqForceReturnPropertiesInMQRFH2Header.description=Force MQ Message Properties to be returned in the MQRFH2 header by inclusion of the MQGMO_PROPERTIES_FORCE_MQRFH2 flag in MQGET calls. Note that enabling this setting changes the context variables required to reference MQ Message properties.
ioMqForceReturnPropertiesInMQRFH2Header.default=false
ioMqForceReturnPropertiesInMQRFH2Header.systemProperty = ${propertyPrefix}.forceReturnPropertiesInMQRFH2Header
ioMqForceReturnPropertiesInMQRFH2Header.clusterProperty=io.mqForceReturnPropertiesInMQRFH2Header
ioMqForceReturnPropertiesInMQRFH2Header.validation.regex=${regex.boolean}

ioEmailMessageMaxBytes.description = Maximum number of bytes permitted for an email message, or 0 for unlimited (Integer)
ioEmailMessageMaxBytes.default = 2621440
ioEmailMessageMaxBytes.clusterProperty = io.emailMessageMaxBytes
ioEmailMessageMaxBytes.validation.type = long
ioEmailMessageMaxBytes.validation.min = 0

email.useDefaultSsl.description=Whether or not to use the default SSL implementation for Send Email assertion.
email.useDefaultSsl.default=false
email.useDefaultSsl.clusterProperty=email.useDefaultSsl
email.useDefaultSsl.systemProperty = com.l7tech.server.policy.emailalert.useDefaultSsl
email.useDefaultSsl.validation.regex=${regex.boolean}

email.attachments.maxSize.description = Maximum size of an attachment in bytes. Default value is -1 i.e., no limit.
email.attachments.maxSize.default = -1
email.attachments.maxSize.clusterProperty = email.attachments.maxSize
email.attachments.maxSize.validation.type = integer
email.attachments.maxSize.validation.min = -1
email.attachments.maxSize.validation.max = 2147483647

ioStaleCheckCount.description = Number of stale checked connections per interval (Integer)
ioStaleCheckCount.default = 1
ioStaleCheckCount.systemProperty = com.l7tech.common.http.prov.apache.CommonsHttpClient.staleCheckCount
ioStaleCheckCount.clusterProperty = io.staleCheckCount
ioStaleCheckCount.validation.type = integer

ioStaleCheckHosts.description = Maximum number of stale checked hosts (Integer)
ioStaleCheckHosts.default = 10
ioStaleCheckHosts.systemProperty = com.l7tech.common.http.prov.apache.CommonsHttpClient.staleCheckHosts
ioStaleCheckHosts.clusterProperty = io.staleCheckHosts
ioStaleCheckHosts.validation.type = integer

ioXmlPartMaxBytes.description = Maximum number of bytes permitted in the XML part of a message, or 0 for unlimited (Integer)
ioXmlPartMaxBytes.default = 2621440
ioXmlPartMaxBytes.systemProperty = ${propertyPrefix}.xmlPartMaxBytes
ioXmlPartMaxBytes.clusterProperty = io.xmlPartMaxBytes
ioXmlPartMaxBytes.validation.type = long

io.httpParamsMaxFormPostBytes.description = Maximum number of bytes to buffer when processing an HTTP form post (application/x-www-form-urlencoded) (Integer, default=5242880)
io.httpParamsMaxFormPostBytes.default = 5242880
io.httpParamsMaxFormPostBytes.systemProperty = com.l7tech.message.httpParamsMaxFormPost
io.httpParamsMaxFormPostBytes.clusterProperty = io.httpParamsMaxFormPostBytes
io.httpParamsMaxFormPostBytes.validation.type = integer

ioAttachmentSignedMaxBytes.description = Maximum number of bytes permitted in each signed attachment, or 0 for unlimited (Integer)
ioAttachmentSignedMaxBytes.default = 5242880
ioAttachmentSignedMaxBytes.clusterProperty = io.signedPartMaxBytes
ioAttachmentSignedMaxBytes.validation.type = long

ioMailConnectTimeout.description = IO timeout for outbound connection to mail server (timeunit)
ioMailConnectTimeout.default = 30s
ioMailConnectTimeout.clusterProperty = mail.outConnectTimeout
ioMailConnectTimeout.validation.type = timeUnit

ioMailReadTimeout.description = IO timeout for outbound communication with mail server (timeunit)
ioMailReadTimeout.default = 60s
ioMailReadTimeout.clusterProperty = mail.outTimeout
ioMailReadTimeout.validation.type = timeUnit

ioMailInConnectTimeout.description = IO timeout for inbound connection from mail server (timeunit)
ioMailInConnectTimeout.default = 30s
ioMailInConnectTimeout.clusterProperty = mail.inConnectTimeout
ioMailInConnectTimeout.validation.type = timeUnit

ioMailInTimeout.description = IO timeout for inbound communication with mail server (timeunit)
ioMailInTimeout.default = 60s
ioMailInTimeout.clusterProperty = mail.inTimeout
ioMailInTimeout.validation.type = timeUnit

ioAlwaysValidateContentType.description = Always perform full validation of Content-Type headers (true/false, default false). Requires gateway restart.
ioAlwaysValidateContentType.default = false
ioAlwaysValidateContentType.clusterProperty = io.alwaysValidateContentType
ioAlwaysValidateContentType.systemProperty = com.l7tech.common.mime.alwaysValidateContentType
ioAlwaysValidateContentType.visible = false
ioAlwaysValidateContentType.validation.regex = ${regex.boolean}

ioDebugSsl.description = Log debug information for SSL and TLS operations (true/false)
ioDebugSsl.default = false
ioDebugSsl.clusterProperty = io.debugSsl
ioDebugSsl.validation.regex = ${regex.boolean}

ioDebugSslValue.description = Value to use for SSL and TLS debugging.
ioDebugSslValue.default = ssl
ioDebugSslValue.clusterProperty = io.debugSslValue
ioDebugSslValue.visible = false

# Old name of this setting, but defaults live here -- new one points at this one for defaults
xsltMaxCacheEntries.description = Maximum number of cached stylesheets loaded from URLs, 0 for no caching (Integer). Requires gateway restart.
xsltMaxCacheEntries.default = 100
xsltMaxCacheEntries.systemProperty = ${propertyPrefix}.xsltcache.maxEntries
xsltMaxCacheEntries.clusterProperty = xsltcache.maxEntries
xsltMaxCacheEntries.validation.type = integer

# Old name of this setting, but defaults live here -- new one points at this one for defaults
xsltMaxCacheAge.description = Maximum age of cached stylesheets loaded from URLs (Milliseconds). Requires gateway restart.
xsltMaxCacheAge.default = 300000
xsltMaxCacheAge.systemProperty = ${propertyPrefix}.xsltcache.maxAge
xsltMaxCacheAge.clusterProperty = xsltcache.maxAge
xsltMaxCacheAge.validation.type = long

xsltMaxStaleCacheAge.description = Maximum age of stale (expired) cached stylesheets loaded from URLs, -1 for no expiry (Milliseconds). Requires gateway restart.
xsltMaxStaleCacheAge.default = -1
xsltMaxStaleCacheAge.systemProperty = ${propertyPrefix}.xsltcache.maxStaleAge
xsltMaxStaleCacheAge.clusterProperty = xsltcache.maxStaleAge
xsltMaxStaleCacheAge.validation.type = long

xslt.engine.force20.description = Force use of the XSLT 2.0 engine when processing XSLT 1.0 stylesheets in software (true/false, default=false). Requires gateway restart.
xslt.engine.force20.default = false
xslt.engine.force20.systemProperty = com.l7tech.xml.xslt.useSaxon
xslt.engine.force20.clusterProperty = xslt.engine.force20
xslt.engine.force20.validation.regex = ${regex.boolean}

schemaMaxCacheAge.description = Maximum age of cached XML Schema documents loaded from URLs (Milliseconds).
schemaMaxCacheAge.default = 30000
schemaMaxCacheAge.systemProperty = ${propertyPrefix}.schemacache.maxAge
schemaMaxCacheAge.clusterProperty = schemacache.maxAge
schemaMaxCacheAge.validation.type = long

schemaMaxStaleCacheAge.description = Maximum age of stale (expired) cached XML Schema documents loaded from URLs, -1 for no expiry (Milliseconds).
schemaMaxStaleCacheAge.default = -1
schemaMaxStaleCacheAge.systemProperty = ${propertyPrefix}.schemacache.maxStaleAge
schemaMaxStaleCacheAge.clusterProperty = schemacache.maxStaleAge
schemaMaxStaleCacheAge.validation.type = long

schemaMaxCacheEntries.description = Maximum number of cached XML schema documents loaded from URLs, 0 for no caching (Integer).
schemaMaxCacheEntries.default = 100
schemaMaxCacheEntries.systemProperty = ${propertyPrefix}.schemacache.maxEntries
schemaMaxCacheEntries.clusterProperty = schemacache.maxEntries
schemaMaxCacheEntries.validation.type = integer

schemaRecompileLatency.description = Minimum time that must elapse in between two consecutive rebuilds of the hardware schema table (Milliseconds). This prevents continuous rebuilding.
schemaRecompileLatency.default = 10000
schemaRecompileLatency.systemProperty = ${propertyPrefix}.schemacache.recompileLatency
schemaRecompileLatency.clusterProperty = schemacache.recompileLatency
schemaRecompileLatency.validation.type = long

schemaRecompileMinAge.description = Time after a schema becomes hardware eligible to wait for additional schemas to become eligible before triggering a batch rebuild of the hardware schema table (Milliseconds). Schema status changes often occur in clumps.
schemaRecompileMinAge.default = 500
schemaRecompileMinAge.systemProperty = ${propertyPrefix}.schemacache.recompileMinAge
schemaRecompileMinAge.clusterProperty = schemacache.recompileMinAge
schemaRecompileMinAge.validation.type = long

schemaRecompileMaxAge.description = Maximum time a needed schema hardware cache rebuild can be held to wait for additional schemas to stop arriving (Milliseconds)
schemaRecompileMaxAge.default = 20000
schemaRecompileMaxAge.systemProperty = ${propertyPrefix}.schemacache.recompileMaxAge
schemaRecompileMaxAge.clusterProperty = schemacache.recompileMaxAge
schemaRecompileMaxAge.validation.type = long

schemaCacheMaxSchemaSize.description = Maximum size in bytes of a Schema document download, or 0 for unlimited (Integer)
schemaCacheMaxSchemaSize.default = ${documentDownload.maxSize}
schemaCacheMaxSchemaSize.systemProperty = ${propertyPrefix}.schemacache.maxSchemaSize
schemaCacheMaxSchemaSize.clusterProperty = schemacache.maxSchemaSize
schemaCacheMaxSchemaSize.validation.type = long

schema.remoteResourceRegex.description = Regular expression to match URLs from which download of remote XML Schema dependencies is permitted.
schema.remoteResourceRegex.default = .*
schema.remoteResourceRegex.systemProperty = ${propertyPrefix}.schema.remoteResourceRegex
schema.remoteResourceRegex.clusterProperty = schema.remoteResourceRegex

ephemeralKeyMaxCacheEntries.description = Maximum number of cached ephemeral key thumbprints per-node, or 0 to disable ephemeral key caching (Integer)
ephemeralKeyMaxCacheEntries.default = 1000
ephemeralKeyMaxCacheEntries.systemProperty = ${propertyPrefix}.ekeycache.maxEntries
ephemeralKeyMaxCacheEntries.clusterProperty = ekeycache.maxEntries
ephemeralKeyMaxCacheEntries.validation.type = integer

defaultfaultlevel.description = Level of details in SOAP faults returned by the SSG (can be overridden by FaultLevel assertion). Values are 0 for drop connection, 1 for template, 2 for generic, 3 for medium details, 4 for full details.
defaultfaultlevel.default = 2
defaultfaultlevel.systemProperty = ${propertyPrefix}.fault.level
defaultfaultlevel.clusterProperty = soapfault.level
defaultfaultlevel.validation.regex = [0-4]

defaultfaulttemplate.description = Template used for SOAP faults returned by the SSG (Text). This is only relevant when soapfault.level is set to 1 for template.
defaultfaulttemplate.default = <s:Envelope xmlns:s="http://schemas.xmlsoap.org/soap/envelope/"><s:Body><s:Fault><faultcode>s:Client</faultcode><faultstring>Client Error</faultstring></s:Fault></s:Body></s:Envelope>
defaultfaulttemplate.systemProperty = ${propertyPrefix}.fault.template
defaultfaulttemplate.clusterProperty = soapfault.template

defaultfaulttemplateContentType.description=Template content type used for custom SOAP faults e.g. application/json. This is only relevant when soapfault.level is set to 1 for template.
defaultfaulttemplateContentType.clusterProperty = soapfault.template.contentType

defaultfaultpolicyurl.description = Whether or not the SSG includes the policy download URL when returning SOAP faults (true/false)
defaultfaultpolicyurl.default = true
defaultfaultpolicyurl.systemProperty = ${propertyPrefix}.fault.policyurl
defaultfaultpolicyurl.clusterProperty = soapfault.policyurl
defaultfaultpolicyurl.validation.regex = ${regex.boolean}

defaultfaultsign.description = Whether or not the SSG signs the SOAP body when returning SOAP faults (true/false)
defaultfaultsign.default = false
defaultfaultsign.systemProperty = ${propertyPrefix}.fault.sign
defaultfaultsign.clusterProperty = soapfault.sign
defaultfaultsign.validation.regex = ${regex.boolean}

defaultfaultkeyalias.description = The alias of the private key to use when signing SOAP faults. This is only relevant when soapfault.sign is set to "true".
defaultfaultkeyalias.systemProperty = ${propertyPrefix}.fault.privateKeyAlias
defaultfaultkeyalias.clusterProperty = soapfault.privateKeyAlias

uddi.result.max_rows.description = The maximum number of records to retrieve for any inquiry.
uddi.result.max_rows.clusterProperty = uddi.limit
uddi.result.max_rows.default = 100
uddi.result.max_rows.validation.type = integer
uddi.result.batch_size.description = The number of records to retrieve at a time (Integer). (This value is effective only if less than or equal to the uddi.limit value.)
uddi.result.batch_size.clusterProperty = uddi.batch
uddi.result.batch_size.default = 100
uddi.result.batch_size.validation.type = integer
uddi.policyUrlTemplate.description = Template for building WS-Policy Attachment URL.
uddi.policyUrlTemplate.clusterProperty = uddi.policyUrlTemplate
uddi.policyUrlTemplate.default = http://{0}:{1}/ssg/policy/disco?serviceoid={3}&fulldoc={4}&inline={5}
uddi.centrasite.activesoa.target.description = The target to reference for CentraSite ActiveSOA UDDI Registry metrics.
uddi.centrasite.activesoa.target.clusterProperty = uddi.centrasite.activesoa.target
uddi.connectTimeout.description = IO timeout for UDDI connection (Milliseconds)
uddi.connectTimeout.clusterProperty = uddi.connectTimeout
uddi.connectTimeout.default = 30000
uddi.connectTimeout.validation.type = long
uddi.timeout.description = IO timeout for UDDI response (Milliseconds)
uddi.timeout.clusterProperty = uddi.timeout
uddi.timeout.default = 60000
uddi.timeout.validation.type = long
uddi.wsdlpublish.maxretries.description = Maximum number of retry attempts when publishing Gateway WSDL information to UDDI
uddi.wsdlpublish.maxretries.clusterProperty = uddi.wsdlpublish.maxretries
uddi.wsdlpublish.maxretries.default = 3
uddi.wsdlpublish.maxretries.validation.type = integer

# setting for auto republishing to uddi when external urls change
uddi.autorepublish.default = true
uddi.autorepublish.description = Republish to UDDI as needed e.g. when the cluster hostname or port number changes
uddi.autorepublish.clusterProperty = uddi.auto_republish
uddi.autorepublish.systemProperty = ${propertyPrefix}.uddi.auto_republish
uddi.autorepublish.validation.regex = ${regex.boolean}

# Active SOA specific cluster properties
uddi.centrasite.activesoa.virtual.service.tmodelkey.description = tModelKey to add to proxied business services in ActiveSOA.
uddi.centrasite.activesoa.virtual.service.tmodelkey.clusterProperty = uddi.centrasite.activesoa.virtual.service.tmodelkey
uddi.centrasite.activesoa.virtual.service.tmodelkey.default = uddi:9de0173b-5117-11de-8cf9-da0192ff3739

uddi.systinet.gif.management.system.description = keyValue for GIF 'uddi:systinet.com:management:system' keyedReference
uddi.systinet.gif.management.system.clusterProperty = uddi.systinet.gif.management.system
uddi.systinet.gif.management.system.default = Layer7 Gateway
uddi.systinet.gif.management.system.visible = false

# This setting is no longer used (should now be configured via manager log sink UI)
trafficLoggerEnabled.description = Whether or not traffic should be recorded (true/false)
trafficLoggerEnabled.default = false
trafficLoggerEnabled.clusterProperty = trafficlogger.enabled
trafficLoggerEnabled.systemProperty = ${propertyPrefix}.trafficlogger.enabled
trafficLoggerEnabled.visible = false
trafficLoggerEnabled.validation.regex = ${regex.boolean}

trafficLoggerDetail.description = Template for logged information related to the request (Text)
trafficLoggerDetail.default = ${request.time}, ${request.soap.namespace}, ${request.soap.operationname}, ${response.http.status}
trafficLoggerDetail.clusterProperty = trafficlogger.detail
trafficLoggerDetail.systemProperty = ${propertyPrefix}.trafficlogger.detail

# This setting is no longer used (should now be configured via manager log sink UI)
trafficLoggerPattern.description = File path in the style of java.util.logging.FileHandler.pattern; see java.util.logging (Text)
trafficLoggerPattern.default = ${ssgHome}${fs}logs${fs}traffic_%g_%u.log
trafficLoggerPattern.clusterProperty = trafficlogger.pattern
trafficLoggerPattern.systemProperty = ${propertyPrefix}.trafficlogger.pattern
trafficLoggerPattern.visible = false

# This setting is no longer used (should now be configured via manager log sink UI)
trafficLoggerLimit.description = Approximate maximum size for log files (Bytes). If this is zero, then there is no limit
trafficLoggerLimit.default = 5242880
trafficLoggerLimit.clusterProperty = trafficlogger.limit
trafficLoggerLimit.systemProperty = ${propertyPrefix}.trafficlogger.limit
trafficLoggerLimit.visible = false

# This setting is no longer used (should now be configured via manager log sink UI)
trafficLoggerCount.description = Number of output files (Integer)
trafficLoggerCount.default = 2
trafficLoggerCount.clusterProperty = trafficlogger.count
trafficLoggerCount.systemProperty = ${propertyPrefix}.trafficlogger.count
trafficLoggerCount.visible = false

trafficLoggerRecordReq.description = Append the contents of the request received by the Gateway at the end of each record (true/false)
trafficLoggerRecordReq.default = false
trafficLoggerRecordReq.clusterProperty = trafficlogger.recordreq
trafficLoggerRecordReq.systemProperty = ${propertyPrefix}.trafficlogger.recordreq
trafficLoggerRecordReq.validation.regex = ${regex.boolean}

trafficLoggerRecordRes.description = Append the contents of the response returned by the Gateway at the end of each record (true/false)
trafficLoggerRecordRes.default = false
trafficLoggerRecordRes.clusterProperty = trafficlogger.recordres
trafficLoggerRecordRes.systemProperty = ${propertyPrefix}.trafficlogger.recordres
trafficLoggerRecordRes.validation.regex = ${regex.boolean}

trafficLoggerSelective.description = Whether the traffic logging is selective (true) or globally turned on/off (false)
trafficLoggerSelective.default = false
trafficLoggerSelective.clusterProperty = trafficlogger.selective
trafficLoggerSelective.systemProperty = ${propertyPrefix}.trafficlogger.selective
trafficLoggerSelective.validation.regex = ${regex.boolean}

pingServletMode.description = Set the permission mode of the Ping Servlet (OFF | REQUIRE_CREDS | OPEN | MONITOR)
pingServletMode.default = REQUIRE_CREDS
pingServletMode.clusterProperty = pingServlet.mode
pingServletMode.systemProperty = ${propertyPrefix}.pingServlet.mode
pingServletMode.validation.regex = \\s*(OFF|REQUIRE_CREDS|OPEN|MONITOR)\\s*

serviceMetricsEnabled.description = Enable collection of service metrics in the Gateway database (true/false)
serviceMetricsEnabled.default = true
serviceMetricsEnabled.clusterProperty = serviceMetrics.enabled
serviceMetricsEnabled.systemProperty = com.l7tech.service.metrics.enabled
serviceMetricsEnabled.validation.regex = ${regex.boolean}

wsdlImportFixupEnabled.default = true
wsdlImportFixupEnabled.systemProperty = com.l7tech.service.wsdlimportfix.enabled

wsdlImportProxyEnabled.description = Permit download of WSDL dependencies (WSDL/Schema). When enabled, available WSDL dependencies can be downloaded (true/false)
wsdlImportProxyEnabled.default = false
wsdlImportProxyEnabled.clusterProperty = service.wsdlDependenciesEnabled
wsdlImportProxyEnabled.validation.regex = ${regex.boolean}

wsdlProxy.allowInsecureHttpBasic.description = Permit WSDL download authentication using HTTP Basic over HTTP, by default only HTTPS is permitted (true/false)
wsdlProxy.allowInsecureHttpBasic.default = false
wsdlProxy.allowInsecureHttpBasic.systemProperty = ${propertyPrefix}.wsdlProxy.allowInsecureHttpBasic
wsdlProxy.allowInsecureHttpBasic.clusterProperty = wsdlProxy.allowInsecureHttpBasic
wsdlProxy.allowInsecureHttpBasic.validation.regex = ${regex.boolean}
wsdlProxy.allowInsecureHttpBasic.visible = false

wsdlQuery.description = Permit download of WSDL using '?wsdl' URL suffix. When enabled, WSDL documents can be downloaded using the Service's resolution path (true/false)
wsdlQuery.default = true
wsdlQuery.clusterProperty = service.wsdlQueryEnabled
wsdlQuery.validation.regex = ${regex.boolean}

schemaSoftwareFallback.description = If true, in the event of a hardware schema validation failure, the validation will be retried in software
schemaSoftwareFallback.default = true
schemaSoftwareFallback.systemProperty = ${propertyPrefix}.schema.softwareFallback
schemaSoftwareFallback.clusterProperty = schema.softwareFallback
schemaSoftwareFallback.validation.regex = ${regex.boolean}

schema.hardwareTargetNamespaces.description = XML Schemas that will always be loaded to hardware, identified by their target namespace (space separated list)
schema.hardwareTargetNamespaces.default = http://schemas.xmlsoap.org/soap/envelope/\nhttp://www.w3.org/2003/05/soap-envelope
schema.hardwareTargetNamespaces.systemProperty = ${propertyPrefix}.schema.hardwareTargetNamespaces
schema.hardwareTargetNamespaces.clusterProperty = schema.hardwareTargetNamespaces

schema.allowDoctype.description = Allow use of a document type definition in XML Schemas (true/false)
schema.allowDoctype.default = false
schema.allowDoctype.systemProperty = ${propertyPrefix}.schema.allowDoctype
schema.allowDoctype.clusterProperty = schema.allowDoctype
schema.allowDoctype.validation.regex = ${regex.boolean}

samlBeforeOffsetMinute.description = The number of minutes (should be a positive integer) to offset the Not-Before aspect of the validity of SAML statements created by the token service
samlBeforeOffsetMinute.default = 2
samlBeforeOffsetMinute.clusterProperty = samlAssertion.NotBeforeOffsetMinutes
samlBeforeOffsetMinute.systemProperty = ${propertyPrefix}.saml.notbeforeoffsetmin
samlBeforeOffsetMinute.validation.type = integer

samlAfterOffsetMinute.description = The number of minutes (should be a positive integer) to offset the Not-On-Or-After aspect of the validity of SAML statements created by the token service
samlAfterOffsetMinute.default = 5
samlAfterOffsetMinute.clusterProperty = samlAssertion.NotAfterOffsetMinutes
samlAfterOffsetMinute.systemProperty = ${propertyPrefix}.saml.notafteroffsetmin
samlAfterOffsetMinute.validation.type = integer

service.validateWssTimestamps.description = Should built-in services validate WS-Security timestamps (true/false)
service.validateWssTimestamps.default = true
service.validateWssTimestamps.clusterProperty = service.validateWssTimestamps
service.validateWssTimestamps.systemProperty = com.l7tech.server.servicesValidateWssTimestamps
service.validateWssTimestamps.validation.regex = ${regex.boolean}

samlValidateBeforeOffsetMinutes.description = The number of minutes to subtract from a SAML assertion's NotBefore restriction during validation.  This can be used to relax the validity window to allow for clock skew.  (default=0)
samlValidateBeforeOffsetMinutes.default = 0
samlValidateBeforeOffsetMinutes.clusterProperty = samlAssertion.validate.notBeforeOffsetMin
samlValidateBeforeOffsetMinutes.systemProperty = ${propertyPrefix}.saml.validate.notBeforeOffsetMin
samlValidateBeforeOffsetMinutes.validation.type = integer

samlValidateAfterOffsetMinutes.description = The number of minutes to add to a SAML assertion's NotOnOrAfter restriction during validation.  This can be used to relax the validity window to allow for clock skew.  (default=0)
samlValidateAfterOffsetMinutes.default = 0
samlValidateAfterOffsetMinutes.clusterProperty = samlAssertion.validate.notOnOrAfterOffsetMin
samlValidateAfterOffsetMinutes.systemProperty = ${propertyPrefix}.saml.validate.notOnOrAfterOffsetMin
samlValidateAfterOffsetMinutes.validation.type = integer

samlGenerateIncludeDNSAddress.description = Should the subject locality for SAML authentication statements include a DNS address (true/false)
samlGenerateIncludeDNSAddress.default = false
samlGenerateIncludeDNSAddress.clusterProperty = saml.generation.includeDNSAddress
samlGenerateIncludeDNSAddress.systemProperty = com.l7tech.security.saml.enableDNS
samlGenerateIncludeDNSAddress.validation.regex = ${regex.boolean}

pkixValidation.identity.description = Default certificate validation setting for identity providers (validate/validatepath/revocation)
pkixValidation.identity.default = validate
pkixValidation.identity.clusterProperty = pkix.validation.identityProvider
pkixValidation.identity.validation.regex = validate|validatepath|revocation

pkixValidation.routing.description = Default certificate validation setting for message routing (validate/validatepath/revocation)
pkixValidation.routing.default = validate
pkixValidation.routing.clusterProperty = pkix.validation.routing
pkixValidation.routing.validation.regex = validate|validatepath|revocation

pkixValidation.other.description = Default certificate validation setting for other uses (validate/validatepath/revocation)
pkixValidation.other.default = validate
pkixValidation.other.clusterProperty = pkix.validation.other
pkixValidation.other.validation.regex = validate|validatepath|revocation

pkixTrust.useDefaultAnchors.description = Should well known Certificate Authorities be included as Trust Anchors (true/false)
pkixTrust.useDefaultAnchors.default = false
pkixTrust.useDefaultAnchors.clusterProperty = pkix.useDefaultTrustAnchors
pkixTrust.useDefaultAnchors.validation.regex = ${regex.boolean}
pkixTrust.useDefaultAnchors.visible = false

pkixTrust.permittedCriticalExtensions.description = List of critical extensions that should be permitted when validating certificates (space separated list of OIDs)
pkixTrust.permittedCriticalExtensions.default =
pkixTrust.permittedCriticalExtensions.clusterProperty = pkix.permittedCriticalExtensions

pkixCRL.expiry.description = Default setting for CRL expiry age (timeunit)
pkixCRL.expiry.default = 1h
pkixCRL.expiry.clusterProperty = pkix.crl.defaultExpiryAge
pkixCRL.expiry.validation.type = timeUnit

pkixCRL.cache.expiry.description = CRL cache expiry age (timeunit)
pkixCRL.cache.expiry.default = 5m
pkixCRL.cache.expiry.clusterProperty = pkix.crl.cacheExpiryAge
pkixCRL.cache.expiry.validation.type = timeUnit

pkixCRL.cache.preexpiry.description = CRL cache refresh pre-expiry age (timeunit)
pkixCRL.cache.preexpiry.default = 1m
pkixCRL.cache.preexpiry.clusterProperty = pkix.crl.cachePreExpiryAge
pkixCRL.cache.preexpiry.visible = false
pkixCRL.cache.preexpiry.validation.type = timeUnit

pkixCRL.cache.threads.description = CRL cache refresh worker thread count, or 0 to disable.
pkixCRL.cache.threads.default = 3
pkixCRL.cache.threads.clusterProperty = pkix.crl.cachePreExpiryThreads
pkixCRL.cache.threads.visible = false
pkixCRL.cache.threads.validation.type = integer

pkixCRL.minExpiryAge.description = Minimum allowed value for CRL expiry age (timeunit)
pkixCRL.minExpiryAge.default = 1h
pkixCRL.minExpiryAge.clusterProperty = pkix.crl.minExpiryAge
pkixCRL.minExpiryAge.validation.type = timeUnit

pkixCRL.maxExpiryAge.description = Maximum allowed value for CRL expiry age (timeunit)
pkixCRL.maxExpiryAge.default = 7d
pkixCRL.maxExpiryAge.clusterProperty = pkix.crl.maxExpiryAge
pkixCRL.maxExpiryAge.validation.type = timeUnit

pkixCRL.maxSize.description = Maximum size in bytes for a CRL, or 0 for unlimited (Integer).
pkixCRL.maxSize.default = 1048576
pkixCRL.maxSize.clusterProperty = pkix.crl.maxSize
pkixCRL.maxSize.systemProperty = ${propertyPrefix}.pkix.crlMaxSize
pkixCRL.maxSize.validation.type = long

pkixOCSP.expiry.description = Default setting for OCSP response expiry age (timeunit)
pkixOCSP.expiry.default = 1m
pkixOCSP.expiry.clusterProperty = pkix.ocsp.defaultExpiryAge
pkixOCSP.expiry.validation.type = timeUnit

pkixOCSP.minExpiryAge.description = Minimum allowed value for OCSP response expiry age (timeunit)
pkixOCSP.minExpiryAge.default = 1s
pkixOCSP.minExpiryAge.clusterProperty = pkix.ocsp.minExpiryAge
pkixOCSP.minExpiryAge.validation.type = timeUnit

pkixOCSP.maxExpiryAge.description = Maximum allowed value for OCSP response expiry age (timeunit)
pkixOCSP.maxExpiryAge.default = 15m
pkixOCSP.maxExpiryAge.clusterProperty = pkix.ocsp.maxExpiryAge
pkixOCSP.maxExpiryAge.validation.type = timeUnit

pkixOCSP.useNonce.description = Include a nonce in OCSP requests (true/false)
pkixOCSP.useNonce.default = true
pkixOCSP.useNonce.clusterProperty = pkix.ocsp.useNonce
pkixOCSP.useNonce.validation.regex = ${regex.boolean}

pkix.csr.defaultExpiryAge.description = The default certificate expiry to use for issued user certificates (days)
pkix.csr.defaultExpiryAge.default = 730
pkix.csr.defaultExpiryAge.clusterProperty = pkix.csr.defaultExpiryAge
pkix.csr.defaultExpiryAge.validation.type = integer
pkix.csr.defaultExpiryAge.validation.min = 1
pkix.csr.defaultExpiryAge.validation.max = 100000

keyStoreDefaultSslKey.description = Keystore ID and alias of default SSL key, colon delimited.  A keystore ID of -1 means "unspecified".
keyStoreDefaultSslKey.default = -1:SSL
keyStoreDefaultSslKey.clusterProperty = keyStore.defaultSsl.alias
keyStoreDefaultSslKey.systemProperty = ${propertyPrefix}.keyStore.defaultSsl.alias
keyStoreDefaultSslKey.visible = false

keyStoreDefaultCaKey.description = Keystore ID and alias of default CA key, colon delimited.  A keystore ID of -1 means "unspecified".
keyStoreDefaultCaKey.default =
keyStoreDefaultCaKey.clusterProperty = keyStore.defaultCa.alias
keyStoreDefaultCaKey.systemProperty = ${propertyPrefix}.keyStore.defaultCa.alias
keyStoreDefaultCaKey.visible = false

keyStoreAuditViewerKey.description = Keystore ID and alias of audit viewer decryption key, colon delimited.  A keystore ID of -1 means "unspecified".
keyStoreAuditViewerKey.default =
keyStoreAuditViewerKey.clusterProperty = keyStore.auditViewer.alias
keyStoreAuditViewerKey.systemProperty = ${propertyPrefix}.keyStore.auditViewer.alias
keyStoreAuditViewerKey.visible = false

keyStoreAuditSigningKey.description = Keystore ID and alias of default audit signing key, colon delimited.  A keystore ID of -1 means "unspecified".
keyStoreAuditSigningKey.default =
keyStoreAuditSigningKey.clusterProperty = keyStore.auditSigning.alias
keyStoreAuditSigningKey.systemProperty = ${propertyPrefix}.keyStore.auditSigning.alias
keyStoreAuditSigningKey.visible = false

keyStoreSearchForAlias.description = If a key alias isn't found in the expected keystore, search all other keystores as well (true/false)
keyStoreSearchForAlias.default = true
keyStoreSearchForAlias.clusterProperty = keyStore.searchForAlias
keyStoreSearchForAlias.validation.regex = ${regex.boolean}

keyStore.certgen.signWithSha1.description = If true, use SHA-1 by default for the message digest when signing certificates.  If false, use SHA-384 if available.  (true/false)
keyStore.certgen.signWithSha1.default = false
keyStore.certgen.signWithSha1.clusterProperty = keyStore.signWithSha1
keyStore.certgen.signWithSha1.systemProperty = com.l7tech.security.cert.alwaysSignWithSha1
keyStore.certgen.signWithSha1.validation.regex = ${regex.boolean}

# Note: not a cluster property
keyStore.luna.pinFinder.default=com.l7tech.server.security.keystore.luna.GatewayLunaPinFinder
keyStore.luna.pinFinder.systemProperty=com.l7tech.lunaPinFinder

keyStore.luna.encryptedLunaPin.description = Luna client PIN, encrypted by GatewayLunaPinFinder (string; no default)
keyStore.luna.encryptedLunaPin.visible=false
keyStore.luna.encryptedLunaPin.systemProperty=com.l7tech.encryptedLunaPin
keyStore.luna.encryptedLunaPin.clusterProperty=keyStore.luna.encryptedLunaPin

keyStore.luna.lunaSlotNum.description = Luna slot number, or -1 to let LunaTokenManager choose one (integer; default -1)
keyStore.luna.lunaSlotNum.visible=false
keyStore.luna.lunaSlotNum.default=-1
keyStore.luna.lunaSlotNum.systemProperty=com.l7tech.lunaSlotNum
keyStore.luna.lunaSlotNum.clusterProperty=keyStore.luna.lunaSlotNum

keyStore.luna.installAsLeastPreference.description = Whether to install the Luna provider as the least-preference security provider. (boolean; default false)
keyStore.luna.installAsLeastPreference.visible=false
keyStore.luna.installAsLeastPreference.default=false
keyStore.luna.installAsLeastPreference.systemProperty=com.l7tech.luna.installAsLeastPreference
keyStore.luna.installAsLeastPreference.clusterProperty=keyStore.luna.installAsLeastPreference
keyStore.luna.installAsLeastPreference.validation.regex = ${regex.boolean}

license.expiryWarnAge.description = Time in days before a license/SSL expiry warning is displayed (eg 30d)
license.expiryWarnAge.default = 30d
license.expiryWarnAge.clusterProperty = license.expiryWarningPeriod
license.expiryWarnAge.validation.type = timeUnit

trustedCert.expiryCheckPeriod.description = The delay to wait between successive Trusted Cert expiry checks
trustedCert.expiryCheckPeriod.default = 12h
trustedCert.expiryCheckPeriod.clusterProperty = trustedCert.expiryCheckPeriod
trustedCert.expiryCheckPeriod.validation.type = timeUnit

trustedCert.expiryFineAge.description = The period prior to the expiry of the Certificate in a Trusted Cert Entry that the Gateway should start logging/auditing FINE-level messages
trustedCert.expiryFineAge.default = 30d
trustedCert.expiryFineAge.clusterProperty = trustedCert.expiryFineAge
trustedCert.expiryFineAge.validation.type = timeUnit

trustedCert.expiryInfoAge.description = The period prior to the expiry of the Certificate in a Trusted Cert Entry that the Gateway should start logging/auditing INFO-level messages
trustedCert.expiryInfoAge.default = 7d
trustedCert.expiryInfoAge.clusterProperty = trustedCert.expiryInfoAge
trustedCert.expiryInfoAge.validation.type = timeUnit

trustedCert.expiryWarningAge.description = The period prior to the expiry of the Certificate in a Trusted Cert Entry that the Gateway should start logging/auditing WARNING-level messages
trustedCert.expiryWarningAge.default = 2d
trustedCert.expiryWarningAge.clusterProperty = trustedCert.expiryWarningAge
trustedCert.expiryWarningAge.validation.type = timeUnit

serverPolicyValidation.maxConcurrency.description = Maximum number of server-side policy validation jobs that may be active simultaneously.
serverPolicyValidation.maxConcurrency.default = 15
serverPolicyValidation.maxConcurrency.clusterProperty = policyValidation.maxConcurrency
serverPolicyValidation.maxConcurrency.validation.type = integer

policyValidation.maxPaths.description = Maximum number of possible paths through a policy before the policy is considered to be too complex to attempt server-side validation.
policyValidation.maxPaths.default = 500000
policyValidation.maxPaths.clusterProperty = policyValidation.maxPaths
policyValidation.maxPaths.validation.type = integer

policyVersioningMaxRevisions.description = Maximum number of policy revisions to retain. Only revisions that are not active and which do not have a comment count toward the maximum.
policyVersioningMaxRevisions.default = 20
policyVersioningMaxRevisions.clusterProperty = policyVersioning.maxRevisions
policyVersioningMaxRevisions.validation.type = integer

soapRejectMustUnderstand.description = If true, SOAP messages containing an unrecognized SOAP header addressed to the Gateway with mustUnderstand="1" will be rejected immediately (true/false)
soapRejectMustUnderstand.default = true
soapRejectMustUnderstand.clusterProperty = soap.rejectMustUnderstand
soapRejectMustUnderstand.validation.regex = ${regex.boolean}

soap.actors.description = Additional SOAP (1.1) Actors for Security headers that will be processed by the Gateway (space separated list)
soap.actors.default = secure_span\nhttp://www.layer7tech.com/ws/policy
soap.actors.systemProperty = com.l7tech.xml.soap.actors
soap.actors.clusterProperty = soap.actors

soap.roles.description = Additional SOAP (1.2) Roles for Security headers that will be processed by the Gateway (space separated list)
soap.roles.default = secure_span\nhttp://www.layer7tech.com/ws/policy
soap.roles.systemProperty = com.l7tech.xml.soap.roles
soap.roles.clusterProperty = soap.roles

template.strictMode.description = If true, using nonexistent variables in a template can cause assertions or policy processing to fail.  If false (the default) an empty string is used instead.
template.strictMode.default = false
template.strictMode.systemProperty = ${propertyPrefix}.template.strictMode
template.strictMode.clusterProperty = template.strictMode
template.strictMode.validation.regex = ${regex.boolean}

template.defaultMultivalueDelimiter.description = The delimiter to use between values when a multivalued variable is interpolated
template.defaultMultivalueDelimiter.default = ", "
template.defaultMultivalueDelimiter.systemProperty = ${propertyPrefix}.template.defaultMultivalueDelimiter
template.defaultMultivalueDelimiter.clusterProperty = template.defaultMultivalueDelimiter

# Keep legacy system property name but use new name for cluster property name and serverconfig property name
template.partBodyMaxSize.description = Maximum size of message part bodies to interpolate in memory (bytes; default=5242880)
template.partBodyMaxSize.default = 5242880
template.partBodyMaxSize.validation.type = integer
template.partBodyMaxSize.clusterProperty = template.partBodyMaxSize
template.partBodyMaxSize.systemProperty = ${propertyPrefix}.policy.variable.partInfoBodyMaxSize

# The auth cache tunings need to default to their old system properties, but let their cluster properties take precedence
defaultAuthCacheMaxSuccessTime.default = 60000
defaultAuthCacheMaxSuccessTime.systemProperty = ${propertyPrefix}.identity.AuthCache.maxSuccessTime
authCacheMaxSuccessTime.description = Milliseconds to cache successful authentications
authCacheMaxSuccessTime.default = ${defaultAuthCacheMaxSuccessTime}
authCacheMaxSuccessTime.clusterProperty = authCache.maxSuccessTime
authCacheMaxSuccessTime.validation.type = long

defaultAuthCacheMaxFailureTime.default = 30000
defaultAuthCacheMaxFailureTime.systemProperty = ${propertyPrefix}.identity.AuthCache.maxFailureTime
authCacheMaxFailureTime.description = Milliseconds to cache failed authentications
authCacheMaxFailureTime.default = ${defaultAuthCacheMaxFailureTime}
authCacheMaxFailureTime.clusterProperty = authCache.maxFailureTime
authCacheMaxFailureTime.validation.type = long

defaultAuthCacheSuccessCacheSize.default = 2000
defaultAuthCacheSuccessCacheSize.systemProperty = ${propertyPrefix}.identity.AuthCache.successCacheSize
authCacheSuccessCacheSize.description = The cache size for successful authentications
authCacheSuccessCacheSize.default = ${defaultAuthCacheSuccessCacheSize}
authCacheSuccessCacheSize.clusterProperty = authCache.successCacheSize
authCacheSuccessCacheSize.validation.type = integer

defaultAuthCacheFailureCacheSize.default = 200
defaultAuthCacheFailureCacheSize.systemProperty = ${propertyPrefix}.identity.AuthCache.failureCacheSize
authCacheFailureCacheSize.description = The cache size for failed authentications
authCacheFailureCacheSize.default = ${defaultAuthCacheFailureCacheSize}
authCacheFailureCacheSize.clusterProperty = authCache.failureCacheSize
authCacheFailureCacheSize.validation.type = integer

defaultAuthCacheGroupMembershipCacheSize.default = 5000
defaultAuthCacheGroupMembershipCacheSize.systemProperty = ${propertyPrefix}.identity.AuthCache.groupMembershipCacheSize
authCacheGroupMembershipCacheSize.description = The cache size for group memberships
authCacheGroupMembershipCacheSize.default = ${defaultAuthCacheGroupMembershipCacheSize}
authCacheGroupMembershipCacheSize.clusterProperty = authCache.groupMembershipCacheSize
authCacheGroupMembershipCacheSize.validation.type = integer

principalSessionCacheSize.description = Maximum number of principals to keep in cache
principalSessionCacheSize.default = 1000
principalSessionCacheSize.clusterProperty = principalSessionCache.cacheSize
principalSessionCacheSize.validation.type = integer

principalSessionCacheMaxTime.description = Milliseconds to cache successful principal validations
principalSessionCacheMaxTime.default = 300000
principalSessionCacheMaxTime.clusterProperty = principalSessionCache.maxTime
principalSessionCacheMaxTime.validation.type = long

principalSessionCacheMaxPrincipalGroups.description = Number of groups per principal to store in the cache
principalSessionCacheMaxPrincipalGroups.default = 1000
principalSessionCacheMaxPrincipalGroups.clusterProperty = principalSessionCache.maxPrincipalGroups
principalSessionCacheMaxPrincipalGroups.validation.type = integer

jmsListenerThreadLimit.description=The global limit on the number of processing threads that can be created to work off all JMS endpoints. Value must be >= 5.
jmsListenerThreadLimit.default=25
jmsListenerThreadLimit.clusterProperty=jms.listenerThreadLimit
jmsListenerThreadLimit.validation.type = integer
jmsListenerThreadLimit.validation.min = 5

emailListenerThreadLimit.description=The global limit on the number of processing threads that can be created to work off all Email endpoints. Value must be >= 5.
emailListenerThreadLimit.default=25
emailListenerThreadLimit.clusterProperty=email.listenerThreadLimit
emailListenerThreadLimit.validation.type = integer
emailListenerThreadLimit.validation.min = 5

sftpMessageProcessingThreadLimit.description=The global limit on the number of processing threads for SFTP requests (integer)
sftpMessageProcessingThreadLimit.default=20
sftpMessageProcessingThreadLimit.clusterProperty=sftp.messageProcessingThreadLimit
sftpMessageProcessingThreadLimit.validation.type = integer
sftpMessageProcessingThreadLimit.validation.min = 1
sftpMessageProcessingThreadLimit.validation.max = 1000
sftpMessageProcessingThreadLimit.visible = false

transportManageableMetadataTypes.description=The message transport metadata types (i.e. protocol headers or properties) for which policy may add or remove key-value entries.
transportManageableMetadataTypes.default=HTTP Header\
\nJMS Property\
\nJMS Header
transportManageableMetadataTypes.clusterProperty=transport.metadata.manageableTypes
transportManageableMetadataTypes.visible=false

# FTP(S) Listen Port default configuration properties
ftp.sessionIdleTimeout.description=The default number of seconds allowed during which no network activity occurs before an FTP session is closed due to inactivity, or 0 for unlimited (Integer).
ftp.sessionIdleTimeout.default=60
ftp.sessionIdleTimeout.clusterProperty=ftp.sessionIdleTimeout
ftp.sessionIdleTimeout.validation.type = integer
ftp.sessionIdleTimeout.validation.min = 0

ftp.maxRequestProcessingThreads.description=The default maximum number of threads an FTP listener may create to process client requests (Integer).
ftp.maxRequestProcessingThreads.default=10
ftp.maxRequestProcessingThreads.clusterProperty=ftp.maxRequestProcessingThreads
ftp.maxRequestProcessingThreads.validation.type = integer
ftp.maxRequestProcessingThreads.validation.min = 0

ftp.anonymousLoginsEnabled.description=The default setting of whether anonymous logins should be enabled (true/false).
ftp.anonymousLoginsEnabled.default=true
ftp.anonymousLoginsEnabled.clusterProperty=ftp.anonymousLoginsEnabled
ftp.anonymousLoginsEnabled.validation.regex = ${regex.boolean}

ftp.maxAnonymousLogins.description=The default maximum number of concurrently logged in anonymous users, or 0 for unlimited (Integer).
ftp.maxAnonymousLogins.default=10
ftp.maxAnonymousLogins.clusterProperty=ftp.maxAnonymousLogins
ftp.maxAnonymousLogins.validation.type = integer
ftp.maxAnonymousLogins.validation.min = 0

ftp.maxConcurrentLogins.description=The default maximum number of concurrently logged in users, including anonymous users, or 0 for unlimited (Integer).
ftp.maxConcurrentLogins.default=10
ftp.maxConcurrentLogins.clusterProperty=ftp.maxConcurrentLogins
ftp.maxConcurrentLogins.validation.type = integer
ftp.maxConcurrentLogins.validation.min = 0

ftp.userMaxConcurrentLogins.description=The default maximum number of concurrent logins per user, or 0 for unlimited (Integer).
ftp.userMaxConcurrentLogins.default=10
ftp.userMaxConcurrentLogins.clusterProperty=ftp.userMaxConcurrentLogins
ftp.userMaxConcurrentLogins.validation.type = integer
ftp.userMaxConcurrentLogins.validation.min = 0

ftp.userMaxConcurrentLoginsPerIp.description=The default maximum number of concurrent logins per user, per IP address, or 0 for unlimited (Integer).
ftp.userMaxConcurrentLoginsPerIp.default=10
ftp.userMaxConcurrentLoginsPerIp.clusterProperty=ftp.userMaxConcurrentLoginsPerIp
ftp.userMaxConcurrentLoginsPerIp.validation.type = integer
ftp.userMaxConcurrentLoginsPerIp.validation.min = 0

sshResponseDownloadThreadLimit.description=The global limit on the number of response download threads for SSH2 routing (integer)
sshResponseDownloadThreadLimit.default=20
sshResponseDownloadThreadLimit.clusterProperty=ssh.responseDownloadThreadLimit
sshResponseDownloadThreadLimit.validation.type = integer
sshResponseDownloadThreadLimit.validation.min = 1
sshResponseDownloadThreadLimit.validation.max = 1000
sshResponseDownloadThreadLimit.visible = false

sshRoutingEnabledCiphers.description = The list of ciphers to enable for SSH2 routing, permitted values are "aes128-ctr", "aes192-ctr", "aes256-ctr", "aes128-cbc", "aes192-cbc", "aes256-cbc", "blowfish-cbc", "3des-cbc" (Comma delimited)
sshRoutingEnabledCiphers.default= aes128-ctr, aes128-cbc, 3des-cbc, blowfish-cbc, aes192-ctr, aes192-cbc, aes256-ctr, aes256-cbc
sshRoutingEnabledCiphers.clusterProperty = ssh.routingEnabledCiphers
sshRoutingEnabledCiphers.validation.regex = (aes128-ctr|aes192-ctr|aes256-ctr|aes128-cbc|aes192-cbc|aes256-cbc|blowfish-cbc|3des-cbc|none)(\\s*,\\s*(aes128-ctr|aes192-ctr|aes256-ctr|aes128-cbc|aes192-cbc|aes256-cbc|blowfish-cbc|3des-cbc|none))*

sftpRoutingExplicitlyValidateDeleteFile.description=This will explicitly check to see if the file attempted to be deleted exists, and it is a file.
sftpRoutingExplicitlyValidateDeleteFile.default=true
sftpRoutingExplicitlyValidateDeleteFile.clusterProperty=sftp.routingExplicitlyValidateDeleteFile
sftpRoutingExplicitlyValidateDeleteFile.validation.regex = ${regex.boolean}

sftpRoutingExplicitlyValidateDeleteDir.description=This will explicitly check to see if the directory attempted to be deleted exists, and it is a directory.
sftpRoutingExplicitlyValidateDeleteDir.default=true
sftpRoutingExplicitlyValidateDeleteDir.clusterProperty=sftp.routingExplicitlyValidateDeleteDir
sftpRoutingExplicitlyValidateDeleteDir.validation.regex = ${regex.boolean}

sftpRoutingExplicitlyValidateMkdir.description=This will explicitly check to see if a directory of the same name exists before attempting to create it.
sftpRoutingExplicitlyValidateMkdir.default=true
sftpRoutingExplicitlyValidateMkdir.clusterProperty=sftp.routingExplicitlyValidateMkdir
sftpRoutingExplicitlyValidateMkdir.validation.regex = ${regex.boolean}

ssh.session.pool.maxActive.description=The maximum number of sessions (per key) that can allocated by the pool (checked out to client threads) at one time. When -1, there is no limit to the number of sessions per key. When maxActive is reached, the session pool is said to be exhausted. When exhausted the assertion will fail. Min -1, Max 1000
ssh.session.pool.maxActive.default=10
ssh.session.pool.maxActive.clusterProperty=ssh.session.pool.maxActive
ssh.session.pool.maxActive.validation.type = integer
ssh.session.pool.maxActive.validation.min = -1
ssh.session.pool.maxActive.validation.max = 1000
ssh.session.pool.maxActive.visible=true

ssh.session.pool.whenExhaustedAction.description=Specifies the behavior of the borrowObject method when a keyed pool is exhausted. Either FAIL, GROW, or BLOCK
ssh.session.pool.whenExhaustedAction.default=FAIL
ssh.session.pool.whenExhaustedAction.clusterProperty=ssh.session.pool.whenExhaustedAction
ssh.session.pool.whenExhaustedAction.validation.regex=FAIL|GROW|BLOCK
ssh.session.pool.whenExhaustedAction.visible=false

ssh.session.pool.maxWait.description=The maximum amount of time (in milliseconds) the borrowObject(K) method should block before throwing an exception when the pool is exhausted and the "when exhausted" action is WHEN_EXHAUSTED_BLOCK. When less than or equal to 0, the borrowObject(K) method may block indefinitely.
ssh.session.pool.maxWait.default=60000
ssh.session.pool.maxWait.clusterProperty=ssh.session.pool.maxWait
ssh.session.pool.maxWait.validation.type = long
ssh.session.pool.maxWait.validation.min = 0
ssh.session.pool.maxWait.visible=false

ssh.session.pool.maxIdle.description=The maximum number of objects that can sit idle in the pool (per key) at any time. When negative, there is no limit to the number of objects that may be idle per key. Min -1, Max 1000
ssh.session.pool.maxIdle.default=-1
ssh.session.pool.maxIdle.clusterProperty=ssh.session.pool.maxIdle
ssh.session.pool.maxIdle.validation.type = integer
ssh.session.pool.maxIdle.validation.min = -1
ssh.session.pool.maxIdle.validation.max = 1000
ssh.session.pool.maxIdle.visible=false

ssh.session.pool.maxTotal.description=A global limit on the number of objects that can be in circulation (active or idle) within the combined set of pools. When non-positive, there is no limit to the total number of objects in circulation. When maxTotal is exceeded, all keyed pools are exhausted.
ssh.session.pool.maxTotal.default=-1
ssh.session.pool.maxTotal.clusterProperty=ssh.session.pool.maxTotal
ssh.session.pool.maxTotal.validation.type = integer
ssh.session.pool.maxTotal.validation.min = -1
ssh.session.pool.maxTotal.validation.max = 1000
ssh.session.pool.maxTotal.visible=false

ssh.session.pool.minIdle.description=A target value for the minimum number of idle objects (per key) that should always be available. Min 0, Max 1000. Note the min idle property does not work as expected in the GenericKeyedObjectPool. It gets checked after an eviction run is made. If during the eviction run all sessions for a given key are evicted the key will be removed from the pool and the min idle will not apply to that key as it will no longer be in the pool.
ssh.session.pool.minIdle.default=0
ssh.session.pool.minIdle.clusterProperty=ssh.session.pool.minIdle
ssh.session.pool.minIdle.validation.type = integer
ssh.session.pool.minIdle.validation.min = 0
ssh.session.pool.minIdle.validation.max = 1000
ssh.session.pool.minIdle.visible=false

ssh.session.pool.timeBetweenEvictionRunsMillis.description=The amount of time (in milliseconds) to sleep between examining idle objects for eviction. Milliseconds
ssh.session.pool.timeBetweenEvictionRunsMillis.default=1800000
ssh.session.pool.timeBetweenEvictionRunsMillis.clusterProperty=ssh.session.pool.timeBetweenEvictionRunsMillis
ssh.session.pool.timeBetweenEvictionRunsMillis.validation.type = long
ssh.session.pool.timeBetweenEvictionRunsMillis.validation.min = 0
ssh.session.pool.timeBetweenEvictionRunsMillis.visible=true

ssh.session.pool.numTestsPerEvictionRun.description=The number of idle objects to examine per run within the idle object eviction thread (if any)
ssh.session.pool.numTestsPerEvictionRun.default=-1
ssh.session.pool.numTestsPerEvictionRun.clusterProperty=ssh.session.pool.numTestsPerEvictionRun
ssh.session.pool.numTestsPerEvictionRun.validation.type = integer
ssh.session.pool.numTestsPerEvictionRun.validation.min = -1
ssh.session.pool.numTestsPerEvictionRun.validation.max = 1000
ssh.session.pool.numTestsPerEvictionRun.visible=false

ssh.session.pool.minEvictableIdleTimeMillis.description=The minimum number of milliseconds an object can sit idle in the pool before it is eligible for eviction. Milliseconds, min -1
ssh.session.pool.minEvictableIdleTimeMillis.default=600000
ssh.session.pool.minEvictableIdleTimeMillis.clusterProperty=ssh.session.pool.minEvictableIdleTimeMillis
ssh.session.pool.minEvictableIdleTimeMillis.validation.type = long
ssh.session.pool.minEvictableIdleTimeMillis.validation.min = -1
ssh.session.pool.minEvictableIdleTimeMillis.visible=true

customerMapping.addToGatewayAuditEvents.description=Add customer mapping information into the gateway audit, so the user can view the information in Gateway Audit Events window. (true/false)
customerMapping.addToGatewayAuditEvents.default=true
customerMapping.addToGatewayAuditEvents.clusterProperty=customerMapping.addToGatewayAuditEvents
customerMapping.addToGatewayAuditEvents.visible=false
customerMapping.addToGatewayAuditEvents.validation.regex = ${regex.boolean}

customerMapping.addToServiceMetrics.description=Add customer mapping information into the service_metrics table, so the user can apply the information in the Dashboard. (true/false)
customerMapping.addToServiceMetrics.default=true
customerMapping.addToServiceMetrics.clusterProperty=customerMapping.addToServiceMetrics
customerMapping.addToServiceMetrics.visible=false
customerMapping.addToServiceMetrics.validation.regex = ${regex.boolean}

services.certificateDiscoveryEnabled.description=Enabling certificate discovery allows XML VPN Clients and Bridge Routing Assertions that send requests to this Gateway to securely discover this Gateway's SSL certificate without user intervention (true/false).
services.certificateDiscoveryEnabled.default=true
services.certificateDiscoveryEnabled.clusterProperty=services.certificateDiscoveryEnabled
services.certificateDiscoveryEnabled.validation.regex = ${regex.boolean}

admin.certificateDiscoveryEnabled.description=Enabling certificate discovery allows the Policy Manager to securely discover this Gateway's SSL certificate without user intervention (true/false).
admin.certificateDiscoveryEnabled.default=true
admin.certificateDiscoveryEnabled.clusterProperty=admin.certificateDiscoveryEnabled
admin.certificateDiscoveryEnabled.validation.regex = ${regex.boolean}

admin.esmRequestSizeLimit.description = The size limit in bytes for ESM administration and Node Control requests, or 0 for unlimited (Integer)
admin.esmRequestSizeLimit.default = 10485760
admin.esmRequestSizeLimit.systemProperty = ${propertyPrefix}.admin.ws.requestSizeLimit
admin.esmRequestSizeLimit.clusterProperty = admin.esmRequestSizeLimit
admin.esmRequestSizeLimit.validation.type = long

admin.esmInterfaceTag.description = Name of the Interface Tag used to identify the IP address for ESM administration requests.
admin.esmInterfaceTag.default =
admin.esmInterfaceTag.systemProperty = ${propertyPrefix}.admin.esmInterfaceTag
admin.esmInterfaceTag.clusterProperty = admin.esmInterfaceTag

admin.esmPort.description = External HTTPS port for ESM administration requests.
admin.esmPort.default = ${clusterhttpsport}
admin.esmPort.systemProperty = ${propertyPrefix}.admin.esmPort
admin.esmPort.clusterProperty = admin.esmPort
admin.esmPort.validation.type = integer
admin.esmPort.validation.min = 1
admin.esmPort.validation.max = 65535

processControllerPresent.description = Nodes in this cluster are managed processes (true/false).
processControllerPresent.visible = false
processControllerPresent.clusterProperty = node.processControllerPresent
processControllerPresent.systemProperty = ${propertyPrefix}.processControllerPresent
processControllerPresent.default = false
processControllerPresent.validation.regex = ${regex.boolean}

processControllerPort.description = Port number for internal communication with the process manager.
processControllerPort.visible = false
processControllerPort.clusterProperty = node.processControllerPort
processControllerPort.systemProperty = ${propertyPrefix}.processControllerPort
processControllerPort.default = 8765
processControllerPort.validation.type = integer
processControllerPort.validation.min = 1
processControllerPort.validation.max = 65535

processControllerDefaultExternalPort.description = Default value for the node management port.
processControllerDefaultExternalPort.systemProperty = ${propertyPrefix}.processControllerPort
processControllerDefaultExternalPort.default = 8765

processControllerExternalPort.description = Port number for ESM remote management of cluster node process managers.
processControllerExternalPort.clusterProperty = node.processControllerExternalPort
processControllerExternalPort.systemProperty = ${propertyPrefix}.processControllerExternalPort
processControllerExternalPort.default = ${processControllerDefaultExternalPort}
processControllerExternalPort.validation.type = integer
processControllerExternalPort.validation.min = 1
processControllerExternalPort.validation.max = 65535

logon.warningBanner.description=Warning message that will be displayed to the user upon successful login to the Policy Manager. By default, this cluster property is empty, which will result in no warning banner being displayed.
logon.warningBanner.default=
logon.warningBanner.clusterProperty=logon.warningBanner

logon.maxAllowableAttempts.description=Maximum number of failed login attempts before the account is locked.   Default is set to 5 attempts max.
logon.maxAllowableAttempts.default=5
logon.maxAllowableAttempts.clusterProperty=logon.maxAllowableAttempts
logon.maxAllowableAttempts.validation.type = integer

logon.lockoutTime.description=The time interval that the locked account will have to wait before next possible login retry after lock out.  The default time is set to 1200 seconds (20 min).  Value should be entered in seconds.
logon.lockoutTime.default=1200
logon.lockoutTime.clusterProperty=logon.lockoutTime
logon.lockoutTime.validation.type = long

logon.sessionExpiry.description = The time interval a session can be inactive for.  Default is 30 minutes.  Value should be entered in minutes.
logon.sessionExpiry.default = 30
logon.sessionExpiry.clusterProperty = logon.sessionExpiry
logon.sessionExpiry.validation.type = integer

logon.inactivityPeriod.description=The time interval an administrative user account could be inactive for.  Default is 35 days  Value should be entered in days.
logon.inactivityPeriod.default=35
logon.inactivityPeriod.clusterProperty=logon.inactivityPeriod
logon.inactivityPeriod.validation.type = integer

#Property is deprecated, leaving in for backwards compatibility
security.stig.enabled.default=true
security.stig.enabled.systemProperty=${propertyPrefix}.stigEnabled

security.policyManager.forbidPasswordWhenCertPresent.description = Use certificate to authenticate when present.
security.policyManager.forbidPasswordWhenCertPresent.default=${security.stig.enabled}
security.policyManager.forbidPasswordWhenCertPresent.clusterProperty=security.policyManager.forbidPasswordWhenCertPresent
security.policyManager.forbidPasswordWhenCertPresent.visible=false

krb5Keytab.description = Kerberos keytab file data
krb5Keytab.visible = false
krb5Keytab.clusterProperty = krb5.keytab

keytabValidate.description = Validate Kerberos keytab file
keytabValidate.visible = false
keytabValidate.clusterProperty = krb5.keytab.validate


krb5Realm.description=The Realm value in the Kerberos configuration file krb5.conf.
krb5Realm.clusterProperty=krb5.realm

krb5KDC.description=The KDC value in the Kerberos configuration file krb5.conf. Supports a list of comma-separated (,) IP addresses where the first in the list is the preferred host.
krb5KDC.clusterProperty=krb5.kdc

defaultKrb5TicketCacheLifetime.default=3600
krb5TicketCacheLifetime.systemProperty=com.l7tech.common.security.kerberos.lifetime

kerberos.krb5Config.overwrite.description = Allow SSG to overwrite the existing krb5.conf file or generate a new one. Default is true.
kerberos.krb5Config.overwrite.default = true
kerberos.krb5Config.overwrite.clusterProperty = kerberos.krb5Config.overwrite
kerberos.krb5Config.overwrite.validation.regex = ${regex.boolean}

kerberos.referral.limit.description = Maximum number of referral TGT that SSG can request until it finds the true realm of the user. 0 - means no referrals. Default is 5.
kerberos.referral.limit.default = 5
kerberos.referral.limit.clusterProperty = kerberos.referral.limit
kerberos.referral.limit.validation.type = integer
kerberos.referral.limit.validation.min = 0

kerberos.cache.size.description = The maximum number of referral kerberos tickets retained in the cache. 0 for no cache and -1 for no limit.  Default is 0.\n\
  The maximum number should be big enough to store the entire chain of referral tickets.
kerberos.cache.size.default = 0
kerberos.cache.size.clusterProperty = kerberos.cache.size
kerberos.cache.size.validation.type = integer
kerberos.cache.size.validation.min = -1

kerberos.cache.timeToLive.description = The maximum amount of time in seconds when ticket stored in the cache. 0 for immediate expiry, -1 for no limit. Default is 0.\n\
    This setting is global to the entire cache, although each individual ticket can have its own time-to-live value.
kerberos.cache.timeToLive.default = 0
kerberos.cache.timeToLive.clusterProperty = kerberos.cache.timeToLive
kerberos.cache.timeToLive.validation.type = integer
kerberos.cache.timeToLive.validation.min = -1

policyorganization.maxFolderDepth.default=8
policyorganization.maxFolderDepth.systemProperty=${propertyPrefix}.maxFolderDepth

maxLdapSearchResultSize.description = The maximum number of results to return in an LDAP Identity Provider search (Integer).
maxLdapSearchResultSize.default = 1000
maxLdapSearchResultSize.clusterProperty = ldap.searchMaxResults
maxLdapSearchResultSize.systemProperty = ${propertyPrefix}.maxLdapSearchResultSize
maxLdapSearchResultSize.validation.type = integer

ldap.group.searchMaxResults.description = The maximum number of results to return in an LDAP group membership search (Integer).
ldap.group.searchMaxResults.default = ${maxLdapSearchResultSize}
ldap.group.searchMaxResults.clusterProperty = ldap.group.searchMaxResults
ldap.group.searchMaxResults.systemProperty = ${propertyPrefix}.maxGroupLdapSearchResultSize
ldap.group.searchMaxResults.validation.type = integer

ldapCertIndexInterval.description=Milliseconds in between LDAP certificate indexing.
ldapCertIndexInterval.default=600000
ldapCertIndexInterval.clusterProperty=ldap.certificateIndex.interval
ldapCertIndexInterval.validation.type = long

ldapCertCacheLifetime.description=Milliseconds to keep LDAP certificates in the LDAP certificate cache.
ldapCertCacheLifetime.default=600000
ldapCertCacheLifetime.clusterProperty=ldap.certificate.cachetime
ldapCertCacheLifetime.validation.type = long

ldapCaseInsensitiveComparison.description=Compare LDAP attribute values in a case insensitive manner.
ldapCaseInsensitiveComparison.default=true
ldapCaseInsensitiveComparison.clusterProperty=ldap.attributecomparison.caseinsensitive
ldapCaseInsensitiveComparison.visible=false
ldapCaseInsensitiveComparison.validation.regex = ${regex.boolean}

request.compress.gzip.allow.description=Allow GZIP compressed requests (true/false)
request.compress.gzip.allow.default=true
request.compress.gzip.allow.clusterProperty=request.compress.gzip.allow
request.compress.gzip.allow.validation.regex = ${regex.boolean}

request.compress.gzip.soapFaultRejection.description = When a GZIP compressed request is rejected, should a SOAP Fault response be sent (true/false)
request.compress.gzip.soapFaultRejection.default = true
request.compress.gzip.soapFaultRejection.clusterProperty = request.compress.gzip.soapFaultRejection
request.compress.gzip.soapFaultRejection.validation.regex = ${regex.boolean}
request.compress.gzip.soapFaultRejection.visible = false

response.compress.gzip.allow.description = Allow GZIP compressed responses (true/false)
response.compress.gzip.allow.default = true
response.compress.gzip.allow.clusterProperty = response.compress.gzip.allow
response.compress.gzip.allow.validation.regex = ${regex.boolean}

timestampCreatedFutureGrace.description = To accommodate clock skew, WSS timestamp created dates are permitted to be up to this far in the future (milliseconds).
timestampCreatedFutureGrace.default = 60000
timestampCreatedFutureGrace.systemProperty = ${propertyPrefix}.policy.assertion.xmlsec.ServerRequestWssTimestamp.createdFutureGrace
timestampCreatedFutureGrace.clusterProperty = security.wss.timestamp.createdFutureGrace
timestampCreatedFutureGrace.validation.type = long

timestampExpiresPastGrace.description = To accommodate clock skew, WSS timestamp expiry dates are permitted to be up to this far in the past (milliseconds).
timestampExpiresPastGrace.default = 60000
timestampExpiresPastGrace.systemProperty = ${propertyPrefix}.policy.assertion.xmlsec.ServerRequestWssTimestamp.expiresPastGrace
timestampExpiresPastGrace.clusterProperty = security.wss.timestamp.expiresPastGrace
timestampExpiresPastGrace.validation.type = long

security.xml.dsig.permittedDigestAlgorithms.description = List of message digest algorithm names that will be respected when verifying XML digital signatures.  DigestMethod and SignatureMethod references that require algorithms not on this list will not be respected.  (Comma delimited; default="MD5,SHA,SHA-1,SHA-256,SHA-384,SHA-512")
security.xml.dsig.permittedDigestAlgorithms.default = MD5,SHA,SHA-1,SHA-256,SHA-384,SHA-512
security.xml.dsig.permittedDigestAlgorithms.clusterProperty = security.xml.dsig.permittedDigestAlgorithms
security.xml.dsig.permittedDigestAlgorithms.systemProperty = com.l7tech.security.xml.dsig.permittedDigestAlgorithms

security.xml.dsig.permittedTransformAlgorithms.description = List of transform algorithm URIs that will be permitted when verifying XML digital signatures. Transforms that require algorithms not on this list will fail (Comma delimited)
security.xml.dsig.permittedTransformAlgorithms.clusterProperty = security.xml.dsig.permittedTransformAlgorithms
security.xml.dsig.permittedTransformAlgorithms.systemProperty = com.l7tech.security.xml.dsig.permittedTransformAlgorithms
security.xml.dsig.permittedTransformAlgorithms..visible = false
security.xml.dsig.permittedTransformAlgorithms.default = \
  http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#STR-Transform,\
  http://docs.oasis-open.org/wss/2004/XX/oasis-2004XX-wss-swa-profile-1.0#Attachment-Complete-Transform,\
  http://docs.oasis-open.org/wss/2004/XX/oasis-2004XX-wss-swa-profile-1.0#Attachment-Content-Only-Transform,\
  http://www.w3.org/2000/09/xmldsig#enveloped-signature,\
  http://www.w3.org/2001/10/xml-exc-c14n#,\
  http://www.w3.org/2001/10/xml-exc-c14n#WithComments

security.xml.dsig.idAttributeNames.description = Attribute names that will be recognized as ID attributes for purposes of locating Signature Reference URI targets during WS-Security processing.  The special prefix "local" matches the namespace URI against the owning element rather than the attribute.
security.xml.dsig.idAttributeNames.default = {http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd}Id\n\
 {http://schemas.xmlsoap.org/ws/2002/07/utility}Id\n\
 {http://schemas.xmlsoap.org/ws/2003/06/utility}Id\n\
 {urn:oasis:names:tc:SAML:1.0:assertion}local:AssertionID\n\
 {urn:oasis:names:tc:SAML:2.0:assertion}local:ID\n\
 Id\n\
 id\n\
 ID\n
security.xml.dsig.idAttributeNames.clusterProperty = security.xml.dsig.idAttributeNames
security.xml.dsig.idAttributeNames.systemProperty = com.l7tech.common.security.xml.idAttributeConfig

security.xml.xenc.encryptEmptyElements.description = Whether the Encrypt Element assertion should encrypt the content of empty elements. Set this to "false" to leave empty elements unencrypted. Setting this to "false" restores pre-v6.1.5 behaviour and is required for interoperability with earlier versions of the SecureSpan XML VPN Client. (true/false; default=true)
security.xml.xenc.encryptEmptyElements.clusterProperty = security.xml.xenc.encryptEmptyElements
security.xml.xenc.encryptEmptyElements.systemProperty = com.l7tech.security.xml.encryptEmptyElements
security.xml.xenc.encryptEmptyElements.default = true
security.xml.xenc.encryptEmptyElements.validation.regex = ${regex.boolean}

security.xml.xenc.decryptionAlwaysSucceeds.description = Whether attempts to decrypt XML must always appear to succeed, once the Gateway has gotten as far as obtaining the symmetric key and attempting to decrypt the CipherValue.  XML that cannot be decrypted will be replaced with a dummy element named "L7xenc:DecryptionFault" in the "http://layer7tech.com/ns/xenc/decryptionfault" namespace.  This makes it more difficult for an attacker to use the Gateway as a decryption oracle. (true/false; default=true)
security.xml.xenc.decryptionAlwaysSucceeds.clusterProperty = security.xml.xenc.decryptionAlwaysSucceeds
security.xml.xenc.decryptionAlwaysSucceeds.systemProperty = com.l7tech.security.xml.decryptionAlwaysSucceeds
security.xml.xenc.decryptionAlwaysSucceeds.default = true
security.xml.xenc.decryptionAlwaysSucceeds.validation.regex = ${regex.boolean}

security.xml.xenc.blacklist.enabled.description = Whether symmetric keys that fail to successfully decrypt XML are blacklisted on this node for a period of time.  This makes it more difficult to use the Gateway as a decryption oracle. (true/false; default=true)
security.xml.xenc.blacklist.enabled.clusterProperty = security.xml.xenc.blacklist.enabled
security.xml.xenc.blacklist.enabled.systemProperty = com.l7tech.security.xml.xenc.decryptionKeyBlacklist.enabled
security.xml.xenc.blacklist.enabled.default = true
security.xml.xenc.blacklist.enabled.validation.regex = ${regex.boolean}

security.xml.xenc.blacklist.failWhenFull.description = If true, all XML decryption attempts will immediately fail, should the decryption key blacklist become full.  (true/false; default=false)
security.xml.xenc.blacklist.failWhenFull.clusterProperty = security.xml.xenc.blacklist.failWhenFull
security.xml.xenc.blacklist.failWhenFull.systemProperty = com.l7tech.security.xml.xenc.decryptionKeyBlacklist.failWhenFull
security.xml.xenc.blacklist.failWhenFull.default = false
security.xml.xenc.blacklist.failWhenFull.validation.regex = ${regex.boolean}

security.xml.xenc.blacklist.maxFailures.description = Maximum number of XML decryption attempts that may fail before a key is blacklisted on a node (integer; default=5)
security.xml.xenc.blacklist.maxFailures.clusterProperty = security.xml.xenc.blacklist.maxFailures
security.xml.xenc.blacklist.maxFailures.systemProperty = com.l7tech.security.xml.xenc.decryptionKeyBlacklist.maxFailures
security.xml.xenc.blacklist.maxFailures.default = 5
security.xml.xenc.blacklist.maxFailures.validation.type = integer
security.xml.xenc.blacklist.maxFailures.validation.min = 0

security.xml.xenc.blacklist.capacity.description = Number of entries permitted in the decryption key blacklist (integer; default=50000)
security.xml.xenc.blacklist.capacity.clusterProperty = security.xml.xenc.blacklist.capacity
security.xml.xenc.blacklist.capacity.systemProperty = com.l7tech.security.xml.xenc.decryptionKeyBlacklist.capacity
security.xml.xenc.blacklist.capacity.default = 50000
security.xml.xenc.blacklist.capacity.validation.type = integer
security.xml.xenc.blacklist.capacity.validation.min = 0

security.xml.xenc.blacklist.maxAge.description = Minimum time a blacklisted key should remain on the blacklist.  Notwithstanding this setting, the blacklist is cleared when a node is restarted.  (timeunit; default=7d)
security.xml.xenc.blacklist.maxAge.clusterProperty = security.xml.xenc.blacklist.maxAge
security.xml.xenc.blacklist.maxAge.systemProperty = com.l7tech.security.xml.xenc.decryptionKeyBlacklist.maxAge
security.xml.xenc.blacklist.maxAge.default = 7d
security.xml.xenc.blacklist.maxAge.validation.type = timeUnit

wsdmNotificationEnabled.description = Enable WSDM subscription notifications (true/false)
wsdmNotificationEnabled.default = true
wsdmNotificationEnabled.clusterProperty = wsdm.notification.enabled
wsdmNotificationEnabled.validation.regex = ${regex.boolean}

wsdmNotificationInterval.description = The interval between WSDM subscription notification attempts (in milliseconds). Note that this only applies to metrics notifications; status changes are sent as they occur.
wsdmNotificationInterval.default = 60000
wsdmNotificationInterval.clusterProperty = wsdm.notification.interval
wsdmNotificationInterval.validation.type = long

pkix.keyUsagePolicy.description=Policy for enforcement of X.509 Key Usage and Extended Key Usage extensions (XML string; empty to use system default policy)
pkix.keyUsagePolicy.default=
pkix.keyUsagePolicy.systemProperty=com.l7tech.pkix.keyUsagePolicy
pkix.keyUsagePolicy.clusterProperty=pkix.keyUsagePolicy

pkix.keyUsage.description=Whether X.509 Key Usage and Extended Key Usage extensions should be enforced per the pkix.keyUsagePolicy. (values IGNORE and ENFORCE; default ENFORCE)
pkix.keyUsage.default=ENFORCE
pkix.keyUsage.systemProperty=com.l7tech.pkix.keyUsage
pkix.keyUsage.clusterProperty=pkix.keyUsage
pkix.keyUsage.validation.regex=\\s*(IGNORE|ENFORCE)\\s*

wss.secureConversation.defaultSessionDuration.description=The default duration for WS-SecureConversation sessions (timeunit)
wss.secureConversation.defaultSessionDuration.default=2h
wss.secureConversation.defaultSessionDuration.clusterProperty=wss.secureConversation.defaultSessionDuration
wss.secureConversation.defaultSessionDuration.validation.type = timeUnit

wss.secureConversation.maxSessions.description=The maximum number of WS-SecureConversation sessions.
wss.secureConversation.maxSessions.default=10000
wss.secureConversation.maxSessions.clusterProperty=wss.secureConversation.maxSessions
wss.secureConversation.maxSessions.validation.type=integer

wss.secureConversation.clusterSessions.description = Should WS-SecureConversation sessions be shared amongst cluster nodes (true/false)
wss.secureConversation.clusterSessions.default = false
wss.secureConversation.clusterSessions.clusterProperty = wss.secureConversation.clusterSessions
wss.secureConversation.clusterSessions.validation.regex = ${regex.boolean}

wss.secureConversation.clusterSessionsCleanupInterval.description = Interval between successive maintenance of WS-SecureConversation sessions (timeunit)
wss.secureConversation.clusterSessionsCleanupInterval.default = 33407ms
wss.secureConversation.clusterSessionsCleanupInterval.visible = false
wss.secureConversation.clusterSessionsCleanupInterval.clusterProperty = wss.secureConversation.clusterSessionsCleanupInterval
wss.secureConversation.clusterSessionsCleanupInterval.validation.type = timeUnit

outbound.secureConversation.defaultSessionDuration.description=The default duration for Outbound WS-SecureConversation sessions (timeunit)
outbound.secureConversation.defaultSessionDuration.default=2h
outbound.secureConversation.defaultSessionDuration.clusterProperty=outbound.secureConversation.defaultSessionDuration
outbound.secureConversation.defaultSessionDuration.validation.type = timeUnit

outbound.secureConversation.maxSessions.description=The maximum number of Outbound WS-SecureConversation sessions.
outbound.secureConversation.maxSessions.default=10000
outbound.secureConversation.maxSessions.clusterProperty=outbound.secureConversation.maxSessions
outbound.secureConversation.maxSessions.validation.type=integer

outbound.secureConversation.sessionPreExpiryAge.description=The pre-expiry age (timeunit; default 1 minute) for outbound secure conversation sessions.
outbound.secureConversation.sessionPreExpiryAge.default=1m
outbound.secureConversation.sessionPreExpiryAge.clusterProperty=outbound.secureConversation.sessionPreExpiryAge
outbound.secureConversation.sessionPreExpiryAge.validation.type = timeUnit

wss.decorator.mustUnderstand.description=Whether Security headers should be generated with mustUnderstand asserted (true/false; default true)
wss.decorator.mustUnderstand.default=true
wss.decorator.mustUnderstand.systemProperty=com.l7tech.common.security.xml.decorator.secHdrMustUnderstand
wss.decorator.mustUnderstand.clusterProperty=wss.decorator.mustUnderstand
wss.decorator.mustUnderstand.validation.regex = ${regex.boolean}

wss.processor.allowMultipleTimestampSignatures.description = Whether Security headers should be permitted to contain multiple Signatures covering the timestamp (true/false; default false)
wss.processor.allowMultipleTimestampSignatures.default = false
wss.processor.allowMultipleTimestampSignatures.clusterProperty = wss.processor.allowMultipleTimestampSignatures
wss.processor.allowMultipleTimestampSignatures.validation.regex = ${regex.boolean}

wss.processor.allowUnknownBinarySecurityTokens.description = Should Binary Security Tokens of an unknown type be permitted or cause security processing to fail (true/false; default false).
wss.processor.allowUnknownBinarySecurityTokens.default = false
wss.processor.allowUnknownBinarySecurityTokens.clusterProperty = wss.processor.allowUnknownBinarySecurityTokens
wss.processor.allowUnknownBinarySecurityTokens.validation.regex = ${regex.boolean}

wss.processor.strictSignatureConfirmationValidation.description = Strict enforcement of signature confirmation validation, default true.
wss.processor.strictSignatureConfirmationValidation.default = true
wss.processor.strictSignatureConfirmationValidation.clusterProperty = wss.processor.strictSignatureConfirmationValidation
wss.processor.strictSignatureConfirmationValidation.validation.regex = ${regex.boolean}

wss.processor.enableDeferredRequestProcessing.description = Allow deferred WS-Security processing of the request message (true/false; default true)
wss.processor.enableDeferredRequestProcessing.default = true
wss.processor.enableDeferredRequestProcessing.visible = false
wss.processor.enableDeferredRequestProcessing.clusterProperty = wss.processor.enableDeferredRequestProcessing
wss.processor.enableDeferredRequestProcessing.validation.regex = ${regex.boolean}

wss.decorator.digsig.messagedigest.description=Specify the default digital signature message digest algorithm used by the WSS decorator and the non-SOAP sign XML element assertion (SHA-1, SHA-256, SHA-384, or SHA-512; default SHA-1)
wss.decorator.digsig.messagedigest.default=SHA-1
wss.decorator.digsig.messagedigest.clusterProperty=wss.decorator.digsig.messagedigest
wss.decorator.digsig.messagedigest.systemProperty=com.l7tech.security.xml.decorator.digsig.messagedigest

wss.decorator.soapActorNamespaced.description = Should the SOAP 1.1 actor attribute created by the WSS decorator be in the SOAP namespace (true/false; default true)
wss.decorator.soapActorNamespaced.default = true
wss.decorator.soapActorNamespaced.clusterProperty = wss.decorator.soap.soapActorNamespaced
wss.decorator.soapActorNamespaced.systemProperty = com.l7tech.security.xml.decorator.soap.soapActorNamespaced
wss.decorator.soapActorNamespaced.validation.regex = ${regex.boolean}

wss.decorator.wsTrust200502TypeIndex.description = WS-Trust 2005/02 request type index, 0 for standard, 1 for IBM TFIM (Tivoli Federated Identity Manager) compatibility.
wss.decorator.wsTrust200502TypeIndex.default = 0
wss.decorator.wsTrust200502TypeIndex.clusterProperty = wss.decorator.wsTrustRequestTypeIndex
wss.decorator.wsTrust200502TypeIndex.systemProperty = com.l7tech.common.security.wstrust.requestTypeIndex
wss.decorator.wsTrust200502TypeIndex.validation.type=integer

wss.decorator.timestamp.omitNanos.description = Should WS-Security timestamps created dates omit nanoseconds (true/false)
wss.decorator.timestamp.omitNanos.default = false
wss.decorator.timestamp.omitNanos.clusterProperty = wss.decorator.omitNanos
wss.decorator.timestamp.omitNanos.systemProperty = com.l7tech.server.timestamp.omitNanos
wss.decorator.timestamp.omitNanos.validation.regex = ${regex.boolean}

namespaces.wss10Extras.description = Namespaces to treat as WS-Security 1.0 equivalent (space separated list)
namespaces.wss10Extras.default = http://schemas.xmlsoap.org/ws/2002/12/secext http://schemas.xmlsoap.org/ws/2002/07/secext http://schemas.xmlsoap.org/ws/2002/xx/secext http://schemas.xmlsoap.org/ws/2003/06/secext
namespaces.wss10Extras.clusterProperty = namespaces.wss10Extras
namespaces.wss10Extras.systemProperty = com.l7tech.util.wss10ExtraNs
namespaces.wss10Extras.visible = false

namespaces.wsu10Extras.description = Namespaces to treat as WS-Security 1.0 utility equivalent (space separated list)
namespaces.wsu10Extras.default = http://schemas.xmlsoap.org/ws/2002/07/utility http://schemas.xmlsoap.org/ws/2003/06/utility
namespaces.wsu10Extras.clusterProperty = namespaces.wsu10Extras
namespaces.wsu10Extras.systemProperty = com.l7tech.util.wsu10ExtraNs
namespaces.wsu10Extras.visible = false

namespaces.soap11Extras.description = Namespaces to treat as SOAP 1.1 equivalent (space separated list)
namespaces.soap11Extras.default = http://www.w3.org/2001/06/soap-envelope http://www.w3.org/2001/09/soap-envelope urn:schemas-xmlsoap-org:soap.v1
namespaces.soap11Extras.clusterProperty = namespaces.soap11Extras
namespaces.soap11Extras.systemProperty = com.l7tech.util.soap11ExtraNs
namespaces.soap11Extras.visible = false

security.fips.enabled.description = Enable only FIPS-compliant cryptographic algorithms.  (true/false)
security.fips.enabled.default=false
security.fips.enabled.clusterProperty=security.fips.enabled
security.fips.enabled.systemProperty=com.l7tech.security.fips.enabled
security.fips.enabled.validation.regex = ${regex.boolean}

security.pcidss.enabled.description= Enable PCI-DSS. (true/false)
security.pcidss.enabled.default= false
security.pcidss.enabled.clusterProperty=security.pcidss.enabled
security.pcidss.enabled.validation.regex = ${regex.boolean}

rbac.autoRole.manageService.autoCreate.description=Whether a Manage Service role should be auto-created when a new Published Service is created (true/false; default true)
rbac.autoRole.manageService.autoCreate.default=true
rbac.autoRole.manageService.autoCreate.clusterProperty=rbac.autoRole.manageService.autoCreate
rbac.autoRole.manageService.autoCreate.validation.regex=${regex.boolean}

rbac.autoRole.managePolicy.autoCreate.description=Whether a Manage Policy role should be auto-created when a new Policy is created (true/false; default true)
rbac.autoRole.managePolicy.autoCreate.default=true
rbac.autoRole.managePolicy.autoCreate.clusterProperty=rbac.autoRole.managePolicy.autoCreate
rbac.autoRole.managePolicy.autoCreate.validation.regex=${regex.boolean}

rbac.autoRole.manageProvider.autoCreate.description=Whether a Manage Identity Provider role should be auto-created a new Identity Provider is created (true/false; default true)
rbac.autoRole.manageProvider.autoCreate.default=true
rbac.autoRole.manageProvider.autoCreate.clusterProperty=rbac.autoRole.manageProvider.autoCreate
rbac.autoRole.manageProvider.autoCreate.validation.regex=${regex.boolean}

rbac.autoRole.manageFolder.autoCreate.description=Whether a Manage Folder role should be auto-created when a new Folder is created (true/false; default true)
rbac.autoRole.manageFolder.autoCreate.default=true
rbac.autoRole.manageFolder.autoCreate.clusterProperty=rbac.autoRole.manageFolder.autoCreate
rbac.autoRole.manageFolder.autoCreate.validation.regex=${regex.boolean}

rbac.autoRole.viewFolder.autoCreate.description=Whether a View Folder role should be auto-created when a new Folder is created (true/false; default true)
rbac.autoRole.viewFolder.autoCreate.default=true
rbac.autoRole.viewFolder.autoCreate.clusterProperty=rbac.autoRole.viewFolder.autoCreate
rbac.autoRole.viewFolder.autoCreate.validation.regex=${regex.boolean}

rbac.autoRole.manageZone.autoCreate.description=Whether a Manage Zone role should be auto-created a new Security Zone is created (true/false; default true)
rbac.autoRole.manageZone.autoCreate.default=true
rbac.autoRole.manageZone.autoCreate.clusterProperty=rbac.autoRole.manageZone.autoCreate
rbac.autoRole.manageZone.autoCreate.validation.regex=${regex.boolean}

rbac.autoRole.viewZone.autoCreate.description=Whether a View Zone role should be auto-created a new Security Zone is created (true/false; default true)
rbac.autoRole.viewZone.autoCreate.default=true
rbac.autoRole.viewZone.autoCreate.clusterProperty=rbac.autoRole.viewZone.autoCreate
rbac.autoRole.viewZone.autoCreate.validation.regex=${regex.boolean}

rbac.autoRole.viewSink.autoCreate.description=Whether a View Log Sink role should be auto-created a new Log Sink is created (true/false; default true)
rbac.autoRole.viewSink.autoCreate.default=true
rbac.autoRole.viewSink.autoCreate.clusterProperty=rbac.autoRole.viewSink.autoCreate
rbac.autoRole.viewSink.autoCreate.validation.regex=${regex.boolean}

rbac.autoRole.manageService.autoAssign.description=Whether a non-admin user should be added to the auto-created Manage Service role when they successfully create a new Published Service (true/false; default true)
rbac.autoRole.manageService.autoAssign.default=true
rbac.autoRole.manageService.autoAssign.clusterProperty=rbac.autoRole.manageService.autoAssign
rbac.autoRole.manageService.autoAssign.validation.regex=${regex.boolean}

rbac.autoRole.managePolicy.autoAssign.description=Whether a non-admin user should be added to the auto-created Manage Policy role when they successfully create a new Policy (true/false; default true)
rbac.autoRole.managePolicy.autoAssign.default=true
rbac.autoRole.managePolicy.autoAssign.clusterProperty=rbac.autoRole.managePolicy.autoAssign
rbac.autoRole.managePolicy.autoAssign.validation.regex=${regex.boolean}

rbac.autoRole.manageProvider.autoAssign.description=Whether a non-admin user should be added to the auto-created Manage Identity Provider role when they successfully create a new Identity Provider (true/false; default true)
rbac.autoRole.manageProvider.autoAssign.default=true
rbac.autoRole.manageProvider.autoAssign.clusterProperty=rbac.autoRole.manageProvider.autoAssign
rbac.autoRole.manageProvider.autoAssign.validation.regex=${regex.boolean}

# //todo move into modular assertion meta()
jdbcQuery.maxRecords.defaultValue.description=Default maximum number of records allowed to return from querying (records; default 10)
jdbcQuery.maxRecords.defaultValue.default=10
jdbcQuery.maxRecords.defaultValue.clusterProperty=jdbcQuery.maxRecords.defaultValue
jdbcQuery.maxRecords.defaultValue.validation.type=integer

jdbcQuery.maxClobSizeOut.description=Maximum allowed size in bytes for a CLOB output variable from a Procedure or Function call. Default is 10MB, minimum is 0 (unlimited).
jdbcQuery.maxClobSizeOut.default=10485760
jdbcQuery.maxClobSizeOut.clusterProperty=jdbcQuery.maxClobSizeOut
jdbcQuery.maxClobSizeOut.validation.type=long

jdbcQuery.maxBlobSizeOut.description=Maximum allowed size in bytes for a BLOB output variable from a Procedure or Function call. Default is 10MB, minimum is 0 (unlimited).
jdbcQuery.maxBlobSizeOut.default=10485760
jdbcQuery.maxBlobSizeOut.clusterProperty=jdbcQuery.maxBlobSizeOut
jdbcQuery.maxBlobSizeOut.validation.type=long

jdbcQueryManager.cacheMetaData.enable.description=Permit or disallow caching of procedure / function meta data. If enabled lazy caching will happen as meta data is downloaded. Connections referenced via a context variable will always require lazy caching.
jdbcQueryManager.cacheMetaData.enable.default=true
jdbcQueryManager.cacheMetaData.enable.clusterProperty=jdbcQueryManager.cacheMetaData.enable
jdbcQueryManager.cacheMetaData.enable.validation.regex=${regex.boolean}

jdbcQueryManager.cacheMetaDataTask.enable.description=Enable / Disable background task to eagerly cache procedure / function meta data.
jdbcQueryManager.cacheMetaDataTask.enable.default=true
jdbcQueryManager.cacheMetaDataTask.enable.clusterProperty=jdbcQueryManager.cacheMetaDataTask.enable
jdbcQueryManager.cacheMetaDataTask.enable.validation.regex=${regex.boolean}

jdbcQueryManager.cacheRefreshInterval.description=Interval in milliseconds between when background task to update meta data cache is ran. Default is 600000 (10 minutes), minimum is 0 (no refresh).
jdbcQueryManager.cacheRefreshInterval.default=600000
jdbcQueryManager.cacheRefreshInterval.clusterProperty=jdbcQueryManager.cacheRefreshInterval
jdbcQueryManager.cacheRefreshInterval.validation.type=long

jdbcQueryManager.cacheCleanUpInterval.description=Interval in milliseconds between when background clean up task to clear cached exceptions is ran. Default is 60000 (1 minute), minimum is 0 (no cache clean up).
jdbcQueryManager.cacheCleanUpInterval.default=60000
jdbcQueryManager.cacheCleanUpInterval.clusterProperty=jdbcQueryManager.cacheCleanUpInterval
jdbcQueryManager.cacheCleanUpInterval.validation.type=long

jdbcQueryManager.cacheStaleTimeout.description=Maximum meta data cache age in seconds. Any cached meta data older than this value will be cleared from the cache. Default is 1800 (30 minutes), minimum is 0 (no stale timeout).
jdbcQueryManager.cacheStaleTimeout.default=1800
jdbcQueryManager.cacheStaleTimeout.clusterProperty=jdbcQueryManager.cacheStaleTimeout
jdbcQueryManager.cacheStaleTimeout.validation.type=long

jdbcQueryManager.cacheKeyNoUsageExpiration.description=Maximum expiration in seconds for a managed meta data cache key. Default is 2678400 (31 days), minimum is 0 (no expiration).
jdbcQueryManager.cacheKeyNoUsageExpiration.default=2678400
jdbcQueryManager.cacheKeyNoUsageExpiration.clusterProperty=jdbcQueryManager.cacheKeyNoUsageExpiration
jdbcQueryManager.cacheKeyNoUsageExpiration.validation.type=long

jdbcQueryManager.minCacheConcurrency.description=The number of threads the background cache meta data task uses. Default is 10, maximum value is 200, minimum value is 1.
jdbcQueryManager.minCacheConcurrency.default=10
jdbcQueryManager.minCacheConcurrency.clusterProperty=jdbcQueryManager.minCacheConcurrency
jdbcQueryManager.minCacheConcurrency.validation.type=integer

jdbcQueryManager.maxGatewayStatementTimeout.description=Maximum Statement query time in seconds allowed on the Gateway. Default is 300 seconds (5 minutes), minimum value is 1.
jdbcQueryManager.maxGatewayStatementTimeout.default=300
jdbcQueryManager.maxGatewayStatementTimeout.clusterProperty=jdbcQueryManager.maxGatewayStatementTimeout
jdbcQueryManager.maxGatewayStatementTimeout.validation.type=integer

jdbcQueryManager.cacheTaskStatementTimeout.description=Maximum Statement query time in seconds allowed for queries from the meta data cache background task. Default is 120 seconds, minimum is 0 (use gateway wide time out).
jdbcQueryManager.cacheTaskStatementTimeout.default=120
jdbcQueryManager.cacheTaskStatementTimeout.clusterProperty=jdbcQueryManager.cacheTaskStatementTimeout
jdbcQueryManager.cacheTaskStatementTimeout.validation.type=integer

jdbcConnection.pooling.maxPoolSize.defaultValue.description=Default maximum number of Connections a pool will maintain at any given time (connections; default 15)
jdbcConnection.pooling.maxPoolSize.defaultValue.default=15
jdbcConnection.pooling.maxPoolSize.defaultValue.clusterProperty=jdbcConnection.pooling.maxPoolSize.defaultValue
jdbcConnection.pooling.maxPoolSize.defaultValue.validation.type=integer

jdbcConnection.pooling.minPoolSize.defaultValue.description=Default minimum number of Connections a pool will maintain at any given time (connections; default 3)
jdbcConnection.pooling.minPoolSize.defaultValue.default=3
jdbcConnection.pooling.minPoolSize.defaultValue.clusterProperty=jdbcConnection.pooling.minPoolSize.defaultValue
jdbcConnection.pooling.minPoolSize.defaultValue.validation.type=integer

jdbcConnection.driverClass.defaultList.description=The default list of supported database driver classes (a list of driver classes).  Each driver class is separated by a new line character.
jdbcConnection.driverClass.defaultList.default=com.mysql.jdbc.Driver\ncom.l7tech.jdbc.mysql.MySQLDriver\ncom.l7tech.jdbc.db2.DB2Driver\ncom.l7tech.jdbc.oracle.OracleDriver\ncom.l7tech.jdbc.sqlserver.SQLServerDriver
jdbcConnection.driverClass.defaultList.clusterProperty=jdbcConnection.driverClass.defaultList

jdbcConnection.driverClass.whiteList.description=The list of database driver classes which the JDBC Query Assertion is allowed to use (ie, a white list).  Note: these driver classes may not be supported.  Each driver class is separated by a new line character.
jdbcConnection.driverClass.whiteList.default=com.mysql.jdbc.Driver\ncom.l7tech.jdbc.mysql.MySQLDriver\ncom.l7tech.jdbc.db2.DB2Driver\ncom.l7tech.jdbc.oracle.OracleDriver\ncom.l7tech.jdbc.sqlserver.SQLServerDriver
jdbcConnection.driverClass.whiteList.systemProperty=${propertyPrefix}.jdbcDriver

jdbcConnection.driverClass.whiteListValidate.description= Validate that the driver class used in a JDBC Connection was registered in the JDBC driver white list. Default is true.
jdbcConnection.driverClass.whiteListValidate.default= true
jdbcConnection.driverClass.whiteListValidate.systemProperty=${propertyPrefix}.jdbcDriverValidate
jdbcConnection.driverClass.whiteListValidate.validation.regex=${regex.boolean}

builtinService.snmpQuery.enabled.description=Enable/disable the built-in service, "HTTP-based SNMP query service" (true/false; default true)
builtinService.snmpQuery.enabled.default=true
builtinService.snmpQuery.enabled.clusterProperty=builtinService.snmpQuery.enabled
builtinService.snmpQuery.enabled.validation.regex = ${regex.boolean}

# 10485760 = 1024 * 1024 * 10
documentDownload.maxSize.description=Maximum default size in bytes of a document download, or 0 for unlimited (Integer). Default is 10MB.
documentDownload.maxSize.default=10485760
documentDownload.maxSize.systemProperty=${propertyPrefix}.documentDownload.maxSize
documentDownload.maxSize.validation.type=long

wsdlDocMaxDownloadSize.description = Maximum size in bytes of a WSDL document download, or 0 for unlimited (Integer).
wsdlDocMaxDownloadSize.default = ${documentDownload.maxSize}
wsdlDocMaxDownloadSize.clusterProperty = wsdlDownload.maxSize
wsdlDocMaxDownloadSize.validation.type=long

xslDocMaxDownloadSize.description = Maximum size in bytes of a XSL document download, or 0 for unlimited (Integer).
xslDocMaxDownloadSize.default = ${documentDownload.maxSize}
xslDocMaxDownloadSize.clusterProperty = xslDownload.maxSize
xslDocMaxDownloadSize.validation.type=long

otherTextualContentTypes.description=Other textual content types. Default are (text, xml, json and form encoded). Each content type must be on a new line and may include a charset e.g. application/custom; charset="UTF-8"
otherTextualContentTypes.clusterProperty = contentType.otherTextualTypes

audit.setDetailLevel.SEVERE.description=Set the audit detail level for all listed audit codes to 'SEVERE'. Space separated list.
audit.setDetailLevel.SEVERE.clusterProperty=audit.setDetailLevel.SEVERE
audit.setDetailLevel.SEVERE.visible=false

audit.setDetailLevel.WARNING.description=Set the audit detail level for all listed audit codes to 'WARNING'. Space separated list.
audit.setDetailLevel.WARNING.clusterProperty=audit.setDetailLevel.WARNING
audit.setDetailLevel.WARNING.visible=false

audit.setDetailLevel.INFO.description=Set the audit detail level for all listed audit codes to 'INFO'. Space separated list.
audit.setDetailLevel.INFO.clusterProperty=audit.setDetailLevel.INFO
audit.setDetailLevel.INFO.visible=false

audit.setDetailLevel.CONFIG.description=Set the audit detail level for all listed audit codes to 'CONFIG'. Space separated list.
audit.setDetailLevel.CONFIG.clusterProperty=audit.setDetailLevel.CONFIG
audit.setDetailLevel.CONFIG.visible=false

audit.setDetailLevel.FINE.description=Set the audit detail level for all listed audit codes to 'FINE'. Space separated list.
audit.setDetailLevel.FINE.clusterProperty=audit.setDetailLevel.FINE
audit.setDetailLevel.FINE.visible=false

audit.setDetailLevel.FINER.description=Set the audit detail level for all listed audit codes to 'FINER'. Space separated list.
audit.setDetailLevel.FINER.clusterProperty=audit.setDetailLevel.FINER
audit.setDetailLevel.FINER.visible=false

audit.setDetailLevel.FINEST.description=Set the audit detail level for all listed audit codes to 'FINEST'. Space separated list.
audit.setDetailLevel.FINEST.clusterProperty=audit.setDetailLevel.FINEST
audit.setDetailLevel.FINEST.visible=false

audit.auditDetailExcludeList.description=The audit detail messages never to audit. Space separated list.
audit.auditDetailExcludeList.clusterProperty=audit.auditDetailExcludeList
audit.auditDetailExcludeList.visible=false

audit.validateSignature.maxrecords.description=The maximum amount of audit records signatures to validate at a time. Min 100. Max 1000.
audit.validateSignature.maxrecords.clusterProperty=audit.validateSignature.maxrecords
audit.validateSignature.maxrecords.default=100
audit.validateSignature.maxrecords.visible=false
audit.validateSignature.maxrecords.validation.type=integer
audit.validateSignature.maxrecords.validation.min=100
audit.validateSignature.maxrecords.validation.max=1000

audit.search.maxMessageSize.description=The maximum audited message in bytes the Gateway will read into memory when searching. Default 2.5MB. Min 1KB . Max 20MB.
audit.search.maxMessageSize.clusterProperty=audit.search.maxMessageSize
audit.search.maxMessageSize.default=2621440
audit.search.maxMessageSize.visible=false
audit.search.maxMessageSize.validation.type=long
audit.search.maxMessageSize.validation.min=1024
audit.search.maxMessageSize.validation.max=20971520

audit.messageSizeLimit.description=The maximum audit message in bytes the gateway will record or 0 for no limit
audit.messageSizeLimit.default=10485760
audit.messageSizeLimit.clusterProperty=audit.messageSizeLimit
audit.messageSizeLimit.validation.type=long
audit.messageSizeLimit.validation.min=0

audit.lookup.cache.messageSizeLimit.description=The maximum audit message in bytes the gateway will cache from the audit lookup policy or 0 for no limit. Default 10MB
audit.lookup.cache.messageSizeLimit.default=10485760
audit.lookup.cache.messageSizeLimit.clusterProperty=audit.lookup.cache.messageSizeLimit
audit.lookup.cache.messageSizeLimit.validation.type=long
audit.lookup.cache.messageSizeLimit.validation.min=0

httpDigest.enable.description=Enable storage of digest password compatible with HTTP Digest
httpDigest.enable.clusterProperty=httpDigest.enable
httpDigest.enable.default=false
httpDigest.enable.visible=false

audit.export.group_concat_max_len.description=Session value for MySQL group_concat_max_len server variable set when exporting audits. Minimum value is 1024 bytes.
audit.export.group_concat_max_len.clusterProperty=audit.export.group_concat_max_len
audit.export.group_concat_max_len.default=1048576

db.replicationDelayCheckInterval.description = Interval between updates (and checking) of the replicated sequence value, zero to disable monitoring (timeunit)
db.replicationDelayCheckInterval.default = 10s
db.replicationDelayCheckInterval.clusterProperty = db.replicationDelayCheckInterval
db.replicationDelayCheckInterval.visible = false
db.replicationDelayCheckInterval.validation.type = timeUnit

db.replicationDelayThreshold.description = Threshold for auditing a warning due to slow or failed replication, zero to disable audits (timeunit)
db.replicationDelayThreshold.default = 60s
db.replicationDelayThreshold.clusterProperty = db.replicationDelayThreshold
db.replicationDelayThreshold.validation.type = timeUnit

db.replicationErrorAuditInterval.description = The minimum interval between successive database replication failure audits (timeunit)
db.replicationErrorAuditInterval.default = 60m
db.replicationErrorAuditInterval.clusterProperty = db.replicationErrorAuditInterval
db.replicationErrorAuditInterval.validation.type = timeUnit

datetime.customFormats.description=Custom Date/Time input format values separated by semicolon
datetime.customFormats.default=<Timestamp>;\
  \n<Millisecond Timestamp>;\
  \n<Second Timestamp>;\
  \nyyyy-MM-dd'T'HH:mm:ss.SSSXXX;\
  \nyyyy-MM-dd'T'HH:mm:ss.SSXXX;\
  \nyyyy-MM-dd'T'HH:mm:ss.SXXX;\
  \nyyyy-MM-dd'T'HH:mm:ssXXX;\
  \nyyyy-MM-dd'T'HH:mmXXX;\
  \nyyyy-MM-dd;\
  \nyyyy-MM;\
  \nyyyy;\
  \nEEE, dd MMM yyyy HH:mm:ss z;\
  \nEEE, dd MMM yy HH:mm:ss Z;\
  \nEEE, dd-MMM-yy HH:mm:ss z;\
  \nEEE MMM dd HH:mm:ss yyyy
datetime.customFormats.clusterProperty = datetime.customFormats

datetime.autoFormats.description=Simple Date Formats followed by a space then the Regular Expression that will match it. All expressions must begin with ^ and end with $
datetime.autoFormats.default=yyyy-MM-dd'T'HH:mm:ss.SSSXXX ^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}(?:Z|(?:\\+|-)\\d{2}:\\d{2})$\
  \nyyyy-MM-dd'T'HH:mm:ss.SSXXX ^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{2}(?:Z|(?:\\+|-)\\d{2}:\\d{2})$\
  \nyyyy-MM-dd'T'HH:mm:ss.SXXX ^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{1}(?:Z|(?:\\+|-)\\d{2}:\\d{2})$\
  \nyyyy-MM-dd'T'HH:mm:ssXXX ^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:Z|(?:\\+|-)\\d{2}:\\d{2})$\
  \nyyyy-MM-dd'T'HH:mmXXX ^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}(?:Z|(?:\\+|-)\\d{2}:\\d{2})$\
  \nyyyy-MM-dd ^\\d{4}-\\d{2}-\\d{2}$\
  \nyyyy-MM ^\\d{4}-\\d{2}$\
  \nyyyy ^\\d{4}$\
  \nEEE, dd MMM yyyy HH:mm:ss z ^[a-zA-Z]{3},\\s\\d{2}\\s[a-zA-Z]{3}\\s\\d{4}\\s\\d{2}:\\d{2}:\\d{2}\\s(?:[a-zA-Z]{3}|(?:\\+|-)\\d{4})$\
  \nEEE, dd MMM yy HH:mm:ss Z ^[a-zA-Z]{3},\\s\\d{2}\\s[a-zA-Z]{3}\\s\\d{2}\\s\\d{2}:\\d{2}:\\d{2}\\s(?:[a-zA-Z]{3}|(?:\\+|-)\\d{4})$ \
  \nEEE, dd-MMM-yy HH:mm:ss z ^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday),\\s\\d{2}-[a-zA-Z]{3}-\\d{2}\\s\\d{2}:\\d{2}:\\d{2}\\s(?:[a-zA-Z]{3}|(?:\\+|-)\\d{4})$\
  \nEEE MMM dd HH:mm:ss yyyy ^[a-zA-Z]{3}\\s[a-zA-Z]{3}\\s(\\d{2}|\\s\\d)\\s\\d{2}:\\d{2}:\\d{2}\\s\\d{4}$
datetime.autoFormats.clusterProperty = datetime.autoFormats
datetime.autoFormats.visible = false

commons.httpclient.ntlm.flags.description=NTLM negotiate flags in HEX. 0x0 sets to standard negotiate flags value. This property should be only used if the AD server performing NTLM authentication is so obscure that it doesn't support default NTLM settings. Please refer to NTLM spec (http://msdn.microsoft.com/en-us/library/cc236621%28v=PROT.13%29.aspx) about the flag value
commons.httpclient.ntlm.flags.default=0x0
commons.httpclient.ntlm.flags.clusterProperty = commons.httpclient.ntlm.flags
commons.httpclient.ntlm.flags.visible = false

throughputQuota.enforce_max_quota.description = Enforce the maximum throughput quota value
throughputQuota.enforce_max_quota.default=false
throughputQuota.enforce_max_quota.clusterProperty = throughputquota.enforce_max_quota
throughputQuota.enforce_max_quota.visible = false
throughputQuota.enforce_max_quota.validation.regex = ${regex.boolean}

throughputQuota.max_throughput_quota.description = Maximum throughput quota value. Only applies when maximum quota is enforced.
throughputQuota.max_throughput_quota.default=2147483647
throughputQuota.max_throughput_quota.clusterProperty = throughputquota.max_throughput_quota
throughputQuota.max_throughput_quota.visible = false
throughputQuota.max_throughput_quota.validation.type = long

io.httpChallengeOrder.description=Define legacy order challenges in HTTP response. Values are: \n"reverse" order: NTLM, Negotiate, Digest, Basic \n"windows" order: Negotiate, NTLM, Digest, Basic
io.httpChallengeOrder.default=windows
io.httpChallengeOrder.clusterProperty = io.httpChallengeOrder

ioHttpHeaderSearchRule.description=If set the gateway selects one header according to search rules and ignores all others with the same name found in HTTP response.\nThis is useful if a non-RFC compliant server sends multiple Content-Type headers.\nAccepted values are: off, first, last, 0, 1, 2, 3, ..., -1, -2, -3, ...
ioHttpHeaderSearchRule.default = off
ioHttpHeaderSearchRule.clusterProperty = io.httpHeaderSearchRule
ioHttpHeaderSearchRule.visible = false

smAgentConfig.description=SiteMinder Agent Configuration cluster property
smAgentConfig.default =
smAgentConfig.clusterProperty = siteminder12.agent.configuration
smAgentConfig.visible = false

siteminder.cache.resourceCache.size.description=The number of entries to cache in the Resource Cache, 0 for no caching (Integer).Default is 10 entries.
siteminder.cache.resourceCache.size.default=10
siteminder.cache.resourceCache.size.clusterProperty=siteminder.cache.resourceCache.size
siteminder.cache.resourceCache.size.validation.type=integer
siteminder.cache.resourceCache.size.validation.min=0

siteminder.cache.resourceCache.maxAge.description=Maximum age of entries in the Resource Cache (Milliseconds).Default is 300000.
siteminder.cache.resourceCache.maxAge.default=300000
siteminder.cache.resourceCache.maxAge.clusterProperty=siteminder.cache.resourceCache.maxAge
siteminder.cache.resourceCache.maxAge.validation.type=integer
siteminder.cache.resourceCache.maxAge.validation.min=0

siteminder.cache.authenticationCache.size.description=The number of entries to cache in the Authentication Cache, 0 for no caching (Integer).Default is 10 entries.
siteminder.cache.authenticationCache.size.default=10
siteminder.cache.authenticationCache.size.clusterProperty=siteminder.cache.authenticationCache.size
siteminder.cache.authenticationCache.size.validation.type=integer
siteminder.cache.authenticationCache.size.validation.min=0

siteminder.cache.authenticationCache.maxAge.description=Maximum age of entries in the Authentication Cache (Milliseconds).Default is 3600000.
siteminder.cache.authenticationCache.maxAge.default=3600000
siteminder.cache.authenticationCache.maxAge.clusterProperty=siteminder.cache.authenticationCache.maxAge
siteminder.cache.authenticationCache.maxAge.validation.type=integer
siteminder.cache.authenticationCache.maxAge.validation.min=0

siteminder.cache.authorizationCache.size.description=The number of entries to cache in the Authorization Cache, 0 for no caching (Integer).Default is 10 entries.
siteminder.cache.authorizationCache.size.default=10
siteminder.cache.authorizationCache.size.clusterProperty=siteminder.cache.authorizationCache.size
siteminder.cache.authorizationCache.size.validation.type=integer
siteminder.cache.authorizationCache.size.validation.min=0

siteminder.cache.authorizationCache.maxAge.description=Maximum age of entries in the Authorization Cache (Milliseconds).Default is 3600000.
siteminder.cache.authorizationCache.maxAge.default=3600000
siteminder.cache.authorizationCache.maxAge.clusterProperty=siteminder.cache.authorizationCache.maxAge
siteminder.cache.authorizationCache.maxAge.validation.type=integer
siteminder.cache.authorizationCache.maxAge.validation.min=0

io.httpAllowBackslash.description=Allow backslashes in the URI of incoming requests. Requires gateway restart.
io.httpAllowBackslash.default=false
io.httpAllowBackslash.clusterProperty=io.httpAllowBackslash
io.httpAllowBackslash.validation.regex = ${regex.boolean}

io.httpConcurrencyWarning.repeatDelay.description=Time between repeated warnings of exceeded concurrency for HTTP(S) listen ports configured to audit concurrency warnings (seconds, default=60)
io.httpConcurrencyWarning.repeatDelay.default=60
io.httpConcurrencyWarning.repeatDelay.clusterProperty=io.httpConcurrencyWarning.repeatDelay
io.httpConcurrencyWarning.repeatDelay.validation.type = integer
io.httpConcurrencyWarning.repeatDelay.validation.min = 1

bootstrap.folder=${ssg.etc}${fs}bootstrap
bootstrap.folder.license.description = Directory bootstrap license folder
bootstrap.folder.license= ${bootstrap.folder}${fs}license
bootstrap.folder.license.systemProperty = com.l7tech.bootstrap.folder.license
bootstrap.folder.services.description = Directory for boostrap services folder
bootstrap.folder.services.default = ${bootstrap.folder}${fs}services
bootstrap.folder.services.systemProperty = com.l7tech.bootstrap.folder.services
bootstrap.folder.bundle.description = Directory bootstrap bundle folder - contains SKAR file multipart bodies or migration bundle files
bootstrap.folder.bundle= ${bootstrap.folder}${fs}bundle
bootstrap.folder.bundle.systemProperty = com.l7tech.bootstrap.folder.bundle

bootstrap.env.license.enable.description = Enable bootstrap license from environment variable (default = false)
bootstrap.env.license.enable.default = false
bootstrap.env.license.enable.systemProperty = com.l7tech.bootstrap.env.license.enable

bootstrap.env.license.variable.description = Name of environment variable containing Gateway license to install (default = SSG_LICENSE)
bootstrap.env.license.variable.default = SSG_LICENSE
bootstrap.env.license.variable.systemProperty = com.l7tech.bootstrap.env.license.variable

bootstrap.license.require.description = Gateway will fail to boot if no license is loaded.
bootstrap.license.require.default = false
bootstrap.license.require.systemProperty = com.l7tech.bootstrap.license.require

cassandra.maxrecords.upperbound.description = The upper bound of maximum number of records to be returned. Default is 10000
cassandra.maxrecords.upperbound.default = 10000
cassandra.maxrecords.upperbound.systemProperty = com.l7tech.cassandraquery.maxrecords.upperbound

#Cassandra connection manager properties
cassandra.maxSimultaneousRequestsPerHostThreshold.description=The maximum number of requests per host.This option is only used with ProtocolVersion #V3 or above.Default is 8192
cassandra.maxSimultaneousRequestsPerHostThreshold.default=8192
cassandra.maxSimultaneousRequestsPerHostThreshold.clusterProperty=cassandra.maxSimultaneousRequestsPerHostThreshold
cassandra.maxSimultaneousRequestsPerHostThreshold.validation.type=integer
cassandra.maxSimultaneousRequestsPerHostThreshold.validation.min=1
cassandra.maxSimultaneousRequestsPerHostThreshold.validation.max=32768

cassandra.hostDistance.description=Determines the distance to the specified Cassandra host. The values are IGNORED, LOCAL, and REMOTE.
cassandra.hostDistance.default=LOCAL
cassandra.hostDistance.clusterProperty=cassandra.hostDistance
cassandra.hostDistance.validation.regex = LOCAL|REMOTE|IGNORED

cassandra.keepAlive.description=Sets java.net.SocketOptions.SO_KEEPALIVE for Cassandra connection. Default value set to true
cassandra.keepAlive.default=true
cassandra.keepAlive.clusterProperty=cassandra.keepAlive
cassandra.keepAlive.validation.regex = ${regex.boolean}

cassandra.maxConnectionCacheAge.description = The maximum age of cached Cassandra connections. Value is a time unit. Enter '0' for no limit. Default is 0.
cassandra.maxConnectionCacheAge.default = 0
cassandra.maxConnectionCacheAge.clusterProperty = cassandra.maxConnectionCacheAge
cassandra.maxConnectionCacheAge.validation.type = timeUnit
cassandra.maxConnectionCacheAge.validation.min = 0

cassandra.maxConnectionCacheIdleTime.description = The maximum time a cached Cassandra connection can remain idle before being purged. Value is a time unit. Enter '0' for no limit. Default is 30m.
cassandra.maxConnectionCacheIdleTime.default = 30m
cassandra.maxConnectionCacheIdleTime.clusterProperty = cassandra.maxConnectionCacheIdleTime
cassandra.maxConnectionCacheIdleTime.validation.type = timeUnit
cassandra.maxConnectionCacheIdleTime.validation.min = 0


cassandra.maxConnectionCacheSize.description = The maximum number of cached Cassandra connections. Enter '0' for no caching. Default is 20.
cassandra.maxConnectionCacheSize.default = 20
cassandra.maxConnectionCacheSize.clusterProperty = cassandra.maxConnectionCacheSize
cassandra.maxConnectionCacheSize.validation.type=integer
cassandra.maxConnectionCacheSize.validation.min=0

cassandra.fetchSize.defaultValue.description=Default fetch size for the queries that don't explicitly set a fetch size. The fetch size determine the number of records retrieved via a single round trip to the Cassandra server. Minimum number is 1 maximum is 2147483647 (default 5000). To disable paging the fetch size must be set to 2147483647.
cassandra.fetchSize.defaultValue.default=5000
cassandra.fetchSize.defaultValue.clusterProperty=cassandra.fetchSize
cassandra.fetchSize.defaultValue.validation.type=integer
cassandra.fetchSize.defaultValue.validation.min=1
cassandra.fetchSize.defaultValue.validation.max=2147483647

cassandra.maxRecords.defaultValue.description=Default maximum number of records allowed to return from querying Cassandra server (default 10).
cassandra.maxRecords.defaultValue.default=10
cassandra.maxRecords.defaultValue.clusterProperty=cassandra.maxRecords
cassandra.maxRecords.defaultValue.validation.type=integer
cassandra.maxRecords.defaultValue.validation.min=1
cassandra.maxRecords.defaultValue.validation.max=${cassandra.maxrecords.upperbound}

cassandra.connectTimeoutMillis.description=The connect timeout in milliseconds for the underlying Netty channel (default 5000).
cassandra.connectTimeoutMillis.default=5000
cassandra.connectTimeoutMillis.clusterProperty=cassandra.connectTimeoutMillis
cassandra.connectTimeoutMillis.validation.type=integer
cassandra.connectTimeoutMillis.validation.min=0
cassandra.connectTimeoutMillis.validation.max=2147483647

cassandra.readTimeoutMillis.description=The read timeout in milliseconds. This defines how long the driver will wait for a given Cassandra node to answer a query. default is 12000
cassandra.readTimeoutMillis.default=12000
cassandra.readTimeoutMillis.clusterProperty=cassandra.readTimeoutMillis
cassandra.readTimeoutMillis.validation.type=integer
cassandra.readTimeoutMillis.validation.min=0

cassandra.reuseAddress.description=Whether to allow the same port to be bound to multiple times. Corresponds to java.net.SocketOptions.SO_REUSEADDR.
cassandra.reuseAddress.clusterProperty=cassandra.reuseAddress
cassandra.reuseAddress.validation.regex = ${regex.boolean}

cassandra.receiveBufferSize.description=A hint on the size of the buffer used to receive data. Corresponds to java.net.SocketOptions.SO_RCVBUF
cassandra.receiveBufferSize.clusterProperty=cassandra.receiveBufferSize
cassandra.receiveBufferSize.validation.type=integer
cassandra.receiveBufferSize.validation.min=0

cassandra.sendBufferSize.description=A hint on the size of the buffer used to send data. Corresponds to java.net.SocketOptions.SO_SNDBUF
cassandra.sendBufferSize.clusterProperty=cassandra.sendBufferSize
cassandra.sendBufferSize.validation.type=integer
cassandra.sendBufferSize.validation.min=0

cassandra.soLinger.description=When specified, disables the immediate return from a call to close() on a TCP socket. Corresponds to java.net.SocketOptions.SO_LINGER
cassandra.soLinger.clusterProperty=cassandra.soLinger
cassandra.soLinger.validation.type=integer
cassandra.soLinger.validation.min=-1

cassandra.tcpNoDelay.description=Disables Nagle's algorithm on the underlying socket. Corresponds to java.net.SocketOptions.TCPNODELAY. Default value is false
cassandra.tcpNoDelay.default=false
cassandra.tcpNoDelay.clusterProperty=cassandra.tcpNoDelay
cassandra.tcpNoDelay.validation.regex = ${regex.boolean}

# Scheduled Task
scheduledTask.maxThreads.description=Number of worker threads for the scheduler. Requires gateway restart.
scheduledTask.maxThreads.default=10
scheduledTask.maxThreads.systemProperty = ${propertyPrefix}.scheduledTask.maxThreads
scheduledTask.maxThreads.clusterProperty = scheduledTask.maxThreads
scheduledTask.maxThreads.validation.type=integer
scheduledTask.maxThreads.validation.min=1

# server-module-file manager staging folder
serverModuleFile.staging.folder.description = Root staging directory where Server Module File Manager will save uploaded modules.
serverModuleFile.staging.folder.default = ${ssg.var}${fs}modstaging
serverModuleFile.staging.folder.systemProperty = ${propertyPrefix}.serverModuleFile.staging.folder
serverModuleFile.staging.folder.visible = false

# server-module-file upload enable
# Enabled by default.
serverModuleFile.upload.enable.description = Enable or Disable Manage Server Module Files functionality via Policy Manager.
serverModuleFile.upload.enable.default = true
serverModuleFile.upload.enable.systemProperty = ${propertyPrefix}.serverModuleFile.upload.enable
serverModuleFile.upload.enable.clusterProperty = serverModuleFile.upload.enable
serverModuleFile.upload.enable.validation.regex = ${regex.boolean}
serverModuleFile.upload.enable.visible = true

# Set the Server Module file-size limit
# Warning: The value must be smaller than the DB packet-size limit (e.g. for MySql max_allowed_packet inside my.cnf or my.ini)
# In addition large value might cause Database replication issue.
serverModuleFile.upload.maxSize.description = The maximum Server Module File Size permitted to be uploaded (in bytes). \
                                              Default is 20MB. A value of "0" (zero) indicates unlimited size. \
                                              \nNotes: (1) This value should be less than the DB packet size limit. \
                                              For example for MySQL, this is the max_allowed_packet value within my.cnf or my.ini. \
                                              (2) Increasing the default value may cause database replication issues in a clustered environment.
serverModuleFile.upload.maxSize.default = 20971520
serverModuleFile.upload.maxSize.clusterProperty = serverModuleFile.upload.maxSize
serverModuleFile.upload.maxSize.validation.type = long
serverModuleFile.upload.maxSize.validation.min = 0
serverModuleFile.upload.maxSize.visible = false

# Set the RestMan request message size limit. This cluster property is used in the Limit Message Size Assertion in the
# Rest Management service. See SSG-10893 for more info
restman.request.message.maxSize.description = Set the REST Management Service maximum request message size limit in kilobytes. This \
                                              cluster property is used in the Limit Message Size Assertion in the Rest Management Service. The Default is 51200KB (50MB)
restman.request.message.maxSize.default = 51200
restman.request.message.maxSize.clusterProperty = restman.request.message.maxSize
restman.request.message.maxSize.validation.type = long
restman.request.message.maxSize.validation.min = 1

# validation regex to restrict only urls that follow the http(s) protocol.  Forces the wiki to be on a web server
# otherwise we have a potential security risk if we allow the user to point to any file on the file system.
help.url.description = Location of the online help for the Policy Manager. A blank entry means the default online \
                       location is used. Modify this property only if using an offline help package. Enter the URL \
                       of a web server accessible by http(s). Restart the Policy Manager for new location to take effect.
help.url.default =
help.url.clusterProperty = help.url
help.url.validation.regex = ^https?://.*$


# Solution Kits ProtectedEntityTracker
# Enabled by default.
protectedEntityTracker.enable.description = Enable or Disable Solution Kits Protected Entity Tracker.
protectedEntityTracker.enable.default = true
protectedEntityTracker.enable.systemProperty = ${propertyPrefix}.protectedEntityTracker.enable
protectedEntityTracker.enable.validation.regex = ${regex.boolean}
protectedEntityTracker.enable.visible = false


# Assertion latency and Gateway performance metrics
# Enabled by default.
relayGatewayMetrics.enable.description = Controls whether the Gateway publishes performance metrics events for use by third party applications or modular assertions provided by CA Technologies. Currently, assertion metrics such as start/end time and latency are available.
relayGatewayMetrics.enable.default = true
relayGatewayMetrics.enable.clusterProperty = relayGatewayMetrics.enable
relayGatewayMetrics.enable.systemProperty = ${propertyPrefix}.relayGatewayMetrics.enable
relayGatewayMetrics.enable.validation.regex = ${regex.boolean}
relayGatewayMetrics.enable.visible = true

# CORS Assertion
cors.useMultiValuedHeaders.description = True to allow using multi-valued headers by CORS assertion.
cors.useMultiValuedHeaders.default = false
cors.useMultiValuedHeaders.clusterProperty = cors.useMultiValuedHeaders
cors.useMultiValuedHeaders.systemProperty = cors.useMultiValuedHeaders
cors.useMultiValuedHeaders.validation.regex = ${regex.boolean}
cors.useMultiValuedHeaders.visible = true

# Evaluate JSON Path Assertion
json.evalJsonPathWithCompression.description = True to use compression style for the evaluated JSON results.
json.evalJsonPathWithCompression.default = false
json.evalJsonPathWithCompression.clusterProperty = json.evalJsonPathWithCompression
json.evalJsonPathWithCompression.systemProperty = json.evalJsonPathWithCompression
json.evalJsonPathWithCompression.validation.regex = ${regex.boolean}
json.evalJsonPathWithCompression.visible = true

# Evaluate JSON Path Assertion V2
json.systemDefaultEvaluator.description = Set value to JsonPathWithCompression for compressed style evaluated JSON results, default value : JsonPath (No Compress)
json.systemDefaultEvaluator.default = JsonPath
json.systemDefaultEvaluator.clusterProperty = json.systemDefaultEvaluator
json.systemDefaultEvaluator.systemProperty = json.systemDefaultEvaluator
json.systemDefaultEvaluator.validation.regex = JsonPath|JsonPathWithCompression
json.systemDefaultEvaluator.visible = true

# Service metrics event listener
serviceMetricsEventListener.maxPoolSize.description = The maximum number of worker threads for the service metrics event listener. Default is 25, minimum is 1.
serviceMetricsEventListener.maxPoolSize.default = 25
serviceMetricsEventListener.maxPoolSize.clusterProperty = serviceMetricsEventListener.maxPoolSize
serviceMetricsEventListener.maxPoolSize.systemProperty = ${propertyPrefix}.serviceMetricsEventListener.maxPoolSize
serviceMetricsEventListener.maxPoolSize.validation.type = integer
serviceMetricsEventListener.maxPoolSize.validation.min = 1
serviceMetricsEventListener.maxPoolSize.visible = true

# The minimum policy manager version supported. See the AdminLoginImpl
policyManager.version.minimum.description = The minimum policy manager version supported
policyManager.version.minimum.default = 9.3.00
policyManager.version.minimum.systemProperty = ${propertyPrefix}.policyManager.version.minimum
policyManager.version.minimum.visible = false

