package com.l7tech.external.assertions.ipm.server.resources;

import com.l7tech.util.Charsets;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.CharacterCodingException;
import java.nio.charset.Charset;
import java.nio.charset.CharsetEncoder;

/**
 * Interface implemented by compiled templates.
 * <p/>
 * The actual compiled template instances are dynamically generated by {@link com.l7tech.external.assertions.ipm.server.TemplateCompiler}.
 * <P/>
 * <B>NOTE:</b> This class must be completely standalone.  It can use standard Java classes but must refer to
 * no Layer 7 classes.  This is because only this class by itself is fed to the runtime Java compiler alongside the
 * dynamically-generated subclass sources.
 * <p/>
 * Instances of this class are not threadsafe.  Users are responsible for any needed synchronization/thread-locality.
 */
public abstract class CompiledTemplate {
    protected char[] in;
    protected int ip;
    protected char[] out;
    protected byte[] bout;
    protected int op;
    private final CharsetEncoder utf8Encoder = Charset.forName("UTF-8").newEncoder();

    /** Exception thrown if the input buffer is too short for this template. */
    public static class InputBufferEmptyException extends Exception {}

    /** Exception thrown if the output buffer is too small to expand the current input with this template. */
    public static class OutputBufferFullException extends Exception {}

    /**
     * Expand the input buffer, expected to be an IPM DATA_BUFF, into the output buffer as XML
     * according to the template implemented by this CompiledTemplate.
     * <p/>
     * <b>Note:</b> Only one thread at a time may call this method on the same CompiledTemplate instance,
     * even if it is using different buffers, because internal state is kept in member fields during
     * the expansion.
     *
     * @param in  the input buffer. Required.
     * @param out  the output buffer.  Required.
     * @return the expanded result String.  Never null.
     * @throws InputBufferEmptyException if the input buffer is too short for this template.
     * @throws OutputBufferFullException if the output buffer is too small to expand the current input with this template.
     * @noinspection AssignmentToCollectionOrArrayFieldFromParameter
     */
    public String expand(char[] in, char[] out) throws InputBufferEmptyException, OutputBufferFullException {
        if (in == null || out == null)
            throw new NullPointerException();

        this.in = in;
        this.out = out;
        this.bout = null;
        this.ip = 0;
        this.op = 0;

        try {
            doExpand();
            return new String(out, 0, op);
        } finally {
            this.in = null;
            this.out = null;
            this.bout = null;
            this.ip = 0;
            this.op = 0;
        }
    }

    protected abstract void doExpand() throws InputBufferEmptyException, OutputBufferFullException;

    /**
     * Expand the input buffer, expected to be an IPM DATA_BUFF, into the output byte buffer as XML
     * according to the template implemented by this CompiledTemplate.
     * <p/>
     *
     * <p/>
     * <b>Note:</b> Only one thread at a time may call this method on the same CompiledTemplate instance,
     * even if it is using different buffers, because internal state is kept in member fields during
     * the expansion.
     *
     * @param in  the input buffer. Required.
     * @param out  the output buffer.  Required.
     * @return the expanded result String.  Never null.
     * @throws InputBufferEmptyException if the input buffer is too short for this template.
     * @throws OutputBufferFullException if the output buffer is too small to expand the current input with this template.
     * @throws IOException if an invalid or unmappable character, or a character outside the basic multilingual plane, is found in the input buffer.
     * @noinspection AssignmentToCollectionOrArrayFieldFromParameter
     */
    public int expandBytes(char[] in, byte[] out) throws InputBufferEmptyException, OutputBufferFullException, IOException {
        if (in == null || out == null)
            throw new NullPointerException();

        this.in = in;
        this.bout = out;
        this.out = null;
        this.ip = 0;
        this.op = 0;

        try {
            doExpandBytes();
            return op;
        } finally {
            this.in = null;
            this.out = null;
            this.bout = null;
            this.ip = 0;
            this.op = 0;
        }
    }

    protected abstract void doExpandBytes() throws InputBufferEmptyException, OutputBufferFullException, IOException;

    private static final char[] ENTAMP = "&amp;".toCharArray();
    private static final char[] ENTLT = "&lt;".toCharArray();
    private static final char[] ENTGT = "&gt;".toCharArray();

    private static final byte[] BENTAMP;
    private static final byte[] BENTLT;
    private static final byte[] BENTGT;
    static {
        BENTAMP = "&amp;".getBytes(Charsets.UTF8);
        BENTLT = "&lt;".getBytes(Charsets.UTF8);
        BENTGT = "&gt;".getBytes(Charsets.UTF8);
    }

    /**
     * Copy count characters from in to out.
     * Input characters ampersand, greater-than and less-than will be replaced by XML entities.
     * Always either succeeds or throws ArrayIndexOutOfBoundsException.
     *
     * @param count  number of characters to copy
     * @throws InputBufferEmptyException if we have fewer than count characters remaining in the input buffer.
     * @throws OutputBufferFullException if we run out of room in the output buffer.
     */
    protected final void copy(int count) throws InputBufferEmptyException, OutputBufferFullException {
        if (ip + count >= in.length)
            throw new InputBufferEmptyException();
        if (op + count >= out.length)
            throw new OutputBufferFullException();

        while (count-- > 0) {
            char c = in[ip++];
            switch (c) {
                case '&':
                    write(ENTAMP);
                    break;
                case '<':
                    write(ENTLT);
                    break;
                case '>':
                    write(ENTGT);
                    break;
                default:
                    out[op++] = c;
            }
        }
    }

    /**
     * Copy count characters from the input buffer to the byte output buffer, converting characters to bytes
     * as we go.
     * Input characters ampersand, greater-than and less-than will be replaced by XML entities.
     * Always either succeeds or throws ArrayIndexOutOfBoundsException.
     *
     * @param count number of characters to copy
     * @throws InputBufferEmptyException if we have fewer than count characters remaining in the input buffer.
     * @throws OutputBufferFullException if we run out of room in the output buffer.
     * @throws IOException if an invalid or unmappable character, or a character outside the basic multilingual plane, is found in the input buffer.
     */
    protected final void cpyb(int count) throws InputBufferEmptyException, OutputBufferFullException, IOException {
        if (ip + count >= in.length)
            throw new InputBufferEmptyException();

        while (count-- > 0) {
            char c = in[ip++];
            switch (c) {
                case '&':
                    writb(BENTAMP);
                    break;
                case '<':
                    writb(BENTLT);
                    break;
                case '>':
                    writb(BENTGT);
                    break;
                default:
                    if (op >= bout.length)
                        throw new OutputBufferFullException();
                    if (c >= 0 && c < 128) {
                        bout[op++] = (byte)(c & 0xff);
                    } else {
                        if (Character.isHighSurrogate(c) || Character.isLowSurrogate(c))
                            throw new IOException("Unable to process input character outside the Basic Multilingual Plane: " + (((int)c) & 0xFFFF));
                        // Fallback to real UTF-8 encoder for this one character
                        // TODO this assumes non-ASCII characters will be rare; otherwise, this will be incredibly slow
                        byte[] bytes = encodeCharacter(c);
                        writb(bytes);
                    }
            }
        }
    }

    /**
     * Encode a single character as UTF-8.  Converting characters one at a time will never be very fast, but the
     * performance of this particular implementation is particularly terrible.
     *
     * @param c char to convert
     * @return a byte array representing this char encoded as UTF-8
     * @throws CharacterCodingException if this char isn't a complete character
     */
    private byte[] encodeCharacter(char c) throws CharacterCodingException {
        ByteBuffer bbuf= utf8Encoder.encode(CharBuffer.wrap(new char[] { c }));
        int num = bbuf.limit();
        byte[] bytes = new byte[num];
        bbuf.get(bytes);
        return bytes;
    }

    /**
     * Copy the specified string into the output buffer.
     * Output characters are NOT XML escaped -- caller is responsible for any needed escaping.
     * Always either succeeds or throws ArrayIndexOutOfBoundsException.
     *
     * @param what the string to emit.  Required.
     * @throws OutputBufferFullException if we run out of room in the output buffer.
     */
    protected final void write(char[] what) throws OutputBufferFullException {
        final int len = what.length;
        if (op + len >= out.length)
            throw new OutputBufferFullException();
        System.arraycopy(what, 0, out, op, len);
        op += len;
    }

    /**
     * Copy the specified byte array into the byte output buffer.
     * Output bytes are not XML escaped or otherwise inspected in any way.
     * Always either succeeds or throws ArrayIndexOutOfBoundsException.
     *
     * @param what the bytes to append to the byte output buffer.  Required.
     * @throws OutputBufferFullException if we run out of room in the output buffer.
     */
    protected final void writb(byte[] what) throws OutputBufferFullException {
        writb(what, 0, what.length);
    }

    private void writb(byte[] what, int start, int count) throws OutputBufferFullException {
        if (op + count >= bout.length)
            throw new OutputBufferFullException();
        System.arraycopy(what, start, bout, op, count);
        op += count;
    }
}
