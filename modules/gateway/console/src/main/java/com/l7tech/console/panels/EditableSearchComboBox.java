package com.l7tech.console.panels;

import com.l7tech.console.MainWindow;

import javax.swing.*;
import javax.swing.event.DocumentListener;
import javax.swing.event.DocumentEvent;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import java.awt.event.*;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.*;
import java.awt.*;
import java.util.List;

/**
 * Editable search combo box. As the user types a dynamic pop up shows all matching items.
 *
 * actionPerformed has been enhanced to only fire ActionEvents when it is known that a user has made a valid selection.
 * This means some ActionEvents are ignored. This is due to the JComboBox being a compound component and can cause multiple
 * events to be fired for a single user action. However in some circumstances an event may be fired more than once.
 *
 * This class is abstract but contains no abstract methods; when creating an instance create an anonymous subclass and
 * override no methods
 * e.g. EditableSearchComboBox<AssertionTreeNode> editSearchBox = new EditableSearchComboBox<AssertionTreeNode>(filter){};
 * This is done so that the type of T can be captured and used at runtime to work with setItem(Object), we only want
 * Object's of the parameter type to be set. If an anonymous class is not created we cannot do this, so the class is
 * marked abstract to ensure this works.
 * 
 * See: http://gafter.blogspot.com/2006/12/super-type-tokens.html
 * 
 * @author dlee
 * @author darmstrong
 */
public abstract class EditableSearchComboBox<T> extends JComboBox {
    private final FilterableComboBoxModel model;
    private final SearchFieldEditor<T> editor;
    private final static int startIndex = -1;
    private int searchResultsIndexer = startIndex;
    private long lastEvent = System.currentTimeMillis();
    private List<ActionListener> actionListeners = new ArrayList<ActionListener>();

    /**
     * Do not fire events is used to ignore all events generated by the JComboBox. This is required when the UI
     * is being reset following a change to the jcombobox background color
     */
    private boolean doNotFireEvents = false;

    /**
     * popUpCancelled informs us to ignore the ActionEvent caused by the pop up menu being cancelled. This happens
     * when the User chooses nothing by clicking out side of the menu pop up. In this case take no action
     * note: the selectedItem will be what ever the last element the mouse went over was
     */
    private boolean popUpCancelled = false;

    /**
     * ignoreWhen is used to know when to ignore the built in delay of 1 second between events. This is set when the
     * user types so that we can support a fast typer typing a search term and pressing enter.
     */
    private boolean ignoreWhen = false;

    /**
     * The captured type of T which is available at runtime to determine which Objects from setItem should be accepted
     */
    private final Class paramaterizedType;

    /**
     * Default constructor which will provide no list of search items.
     * @param filter Filter contains the filtering logic 
     */
    public EditableSearchComboBox(final Filter filter) {
        Type superclass = getClass().getGenericSuperclass();
        if (superclass instanceof Class) {
            //caller did not supply a type parameter
            paramaterizedType = Object.class;
        }else{
            Type type = ((ParameterizedType) superclass).getActualTypeArguments()[0];
            paramaterizedType = (type instanceof Class)? (Class)type: Object.class;
        }

        model = new FilterableComboBoxModel(filter);
        editor = new SearchFieldEditor<T>();

        setModel(model);
        setEditor(editor);
        setEditable(true);

        super.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(final ActionEvent e) {
                if(doNotFireEvents) {
                    return;
                }
                
                if ((e.getActionCommand().equals("comboBoxChanged") && e.getModifiers() > 0) ||
                        (e.getActionCommand().equals("comboBoxEdited") && e.getModifiers() == 0)) {

                    final boolean actionFromFocusEvent = e.getActionCommand().equals("comboBoxChanged") &&
                            EditableSearchComboBox.this.getSelectedItem() == null;

                    //A JComboBox is a compound component and a single user action may cause several actionPerformed events
                    //as a result we will ignore any events which occur with 1 second of the previous event
                    final long eventTime = e.getWhen();

                    //the line below: ( !editor.isEditorShowingNoResults() || editor.getAndClearIsEnterLastKeyPressed() ))
                    //makes sure that when there are no results and the user clicks out of the editor, that the
                    //'No Search Results' dialog does not pop up. This should only be shown when enter is pressed (or f3 / shift f3)
                    final long difference = eventTime - lastEvent;
                    if (!actionFromFocusEvent &&
                            (difference > 1000 || ignoreWhen) &&
                            (!"".equals(filter.getFilterText()) || filter.isShowAllOnEmptyFilterText()) &&
                            !popUpCancelled &&
                            ( !editor.isEditorShowingNoResults() || editor.getAndClearIsEnterLastKeyPressed() )) {
                        // The action events may cause the scrollpane to scroll, which can caues the pop up menu to
                        // scroll also; which can 'disconnect' it from the combo box. Avoid this by invoking the
                        // action events later; to ensure the UI has had time to redraw itself following the dismissing
                        // of the pop up menu, which is currently in the process of happening.
                        SwingUtilities.invokeLater(new Runnable() {
                            @Override
                            public void run() {
                                fireActionPerformed(e);
                            }
                        });
                    }

                    lastEvent = eventTime;
                    popUpCancelled = false;
                    ignoreWhen = false;
                }
            }
        });

        editor.addKeyListener(new KeyAdapter() {
            @Override
            public void keyPressed(KeyEvent e) {
                if(e.getKeyCode() == KeyEvent.VK_ENTER && "".equals(editor.getText())){
                    fireActionPerformed(new ActionEvent(editor, ActionEvent.ACTION_PERFORMED, MainWindow.L7_F3));
                }
                else if(e.getKeyCode() == KeyEvent.VK_ENTER ){
                    fireActionPerformed(new ActionEvent(editor, ActionEvent.ACTION_PERFORMED,  "enter-key" ));
                }
            }
        });
        
        this.addPopupMenuListener(new PopupMenuListener() {
            @Override
            public void popupMenuWillBecomeVisible(PopupMenuEvent e) {}

            @Override
            public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {}

            @Override
            public void popupMenuCanceled(PopupMenuEvent e) {
                popUpCancelled = true;
            }
        });
    }

    private void fireActionPerformed(ActionEvent e) {
        for (ActionListener actList : actionListeners) {
            actList.actionPerformed(e);
        }
    }

    /**
     * Get the actual object which the user selected via it's textual representation in the combo box
     * @return T the selected object
     */
    public T getSelectedObject() {
        return editor.selectedObject;
    }

    /**
     * Constructor which will construct the combo box with a list of searchable items.
     * @param searchableItems   The default list of searchable items
     * @param filter Filter contains the filtering logic
     */
    public EditableSearchComboBox(final Collection<T> searchableItems, final Filter filter) {
        this(filter);
        updateSearchableItems(searchableItems);
    }

    public void addTextFieldKeyListener(KeyListener listener){
        editor.addKeyListener(listener);
    }

    /**
     * Overridden to manage it's own set of listeners which will get notified of higher level events than the
     * ActionPerformed events. This allows clients of this class to not have to work out which events it should ignore.
     *
     * @param l ActionListener to add
     */
    @Override
    public void addActionListener(ActionListener l) {
        actionListeners.add(l);
    }

    /**
     * Overrides setEnabled method to reset popupCancelled state
     * @param enabled  a boolean value, where true enables the component and
     *          false disables it
     */
    @Override
    public void setEnabled(boolean enabled){
        super.setEnabled(enabled);
        this.popUpCancelled = false;
    }

    /**
     * Both okToLoopForward and okToLoopBack allow for the behaviour where the first time results are exhausted
     * in a direction, the user can be shown a message (via returning null), but the subsequent time an attempt is made
     * to move in that direction, the index will loop back to the correct index (either the start or the end)
     */
    private boolean okToLoopForward = false;
    private boolean okToLoopBack = false;

    /**
     * Get the first search result.
     * @return T the first search result. Null when no more results
     */
    public T getFirstSearchResult() {
        resetSearchResultIndex();
        return getNextSearchResult();
    }

    /**
     * Get the next search result.
     * @return T the next search result. Null when no more results
     */
    public T getNextSearchResult(){
        if(model.getSize() < 1) return null;

        okToLoopBack = false;
        
        if (searchResultsIndexer == model.getSize() - 1 && okToLoopForward){
            searchResultsIndexer = startIndex;//reset
            okToLoopForward = false;
        }

        if (searchResultsIndexer < model.getSize() - 1) searchResultsIndexer++;
        else {
            okToLoopForward = true;
            return null;//no more results
        }

        return (T) model.getElementAt(searchResultsIndexer);
    }

    /**
     * Get the previous search result.
     * @return T the previous search result. Null when no more results 
     */
    public T getPreviousSearchResult(){
        if(model.getSize() < 1) return null;

        okToLoopForward = false;

        if(searchResultsIndexer <= 0 && okToLoopBack){
            searchResultsIndexer = model.getSize();//reset
            okToLoopBack = false;
        }

        if(searchResultsIndexer > 0) searchResultsIndexer--;
        else {
            okToLoopBack = true;
            return null;//no previous results
        }

        return (T) model.getElementAt(searchResultsIndexer);
    }

    public boolean hasResults(){
        return model.getSize() > 0;
    }

    public void resetSearchResultIndex(){
        searchResultsIndexer = startIndex;
    }

    /**
     * Updates the list of searchable items with this one. 
     * @param searchableItems   The list of searchable items to be used as part of the look up list.
     */
    public void updateSearchableItems(Collection<T> searchableItems) {
        model.updateSearchableItems(searchableItems);
    }

    public void refresh(){
        editor.filterItems(false);
        model.refresh();
    }

    /**
     * Sets the comparator that will be used to sort the filtered items.
     * @param comparator    The comparator used for sorting
     */
    public void setComparator(Comparator<T> comparator) {
        model.setComparator(comparator);
    }

    /**
     * Sets the comparator that will be used to sort the searchable items prior to be filtered.
     * Use this comparator for better performance if the model items are never changed outside of it.
     * @param comparator    The comparator used for sorting
     */
    public void setPreFilterComparator(Comparator<T> comparator) {
        model.setPreFilterComparator(comparator);
    }

    /**
     * Clear search text and background colour accordingly.
     */
    public void clearSearch() {
        setSelectedItem(null);
        editor.clearSearch();

        SwingUtilities.invokeLater(new Runnable() {
            @Override
            public void run() {
                hidePopup();
            }
        });
    }

    /**
     * The model implementation that will model the editable search combo box.
     */
    public class FilterableComboBoxModel extends AbstractListModel implements MutableComboBoxModel {
        private List<T> items;
        private List<T> filteredItems;
        private Object selectedItem;
        private final Filter filter;
        private Comparator<T> comparator;
        private Comparator<T> preFilterComparator;

        public FilterableComboBoxModel(final Filter filter) {
            items = new ArrayList<T>();
            filteredItems = new ArrayList<T>();
            this.filter = filter;
        }

        @Override
        public void addElement(Object obj) {
            if(obj == null) return;
            
            items.add((T) obj);
            updateFilteredItems();
        }

        @SuppressWarnings({"SuspiciousMethodCalls"})
        @Override
        public void removeElement(Object obj) {
            items.remove(obj);
            updateFilteredItems();
        }

        @Override
        public void removeElementAt(int obj) {
            items.remove(obj);
            updateFilteredItems();
        }

        @Override
        public void insertElementAt(Object obj, int index) {
            throw new UnsupportedOperationException("insertElementAt is not supported");
        }

        @Override
        public int getSize() {
            //returned the size of the filtered items because we want this to be actual display list size
            return filteredItems.size();
        }

        @Override
        public Object getElementAt(int index) {
            return filteredItems.get(index);
        }

        @Override
        public Object getSelectedItem() {
            return selectedItem;
        }

        @Override
        public void setSelectedItem(Object anItem) {
            if (selectedItem != null && anItem != null){
                if(selectedItem.equals(anItem)) return;
            }
            
            if (anItem != null) {
                //anItem may be a String if the user typed something which matched nothing in the list
                if(!paramaterizedType.isAssignableFrom(anItem.getClass())){
                    return;
                }
            }

            selectedItem = anItem;
            fireContentsChanged(this, -1, -1);  //notify of new selected item
        }

        /**
         * Update the list of searchable items
         * @param searchableItems   The new updated searchable item list
         */
        public void updateSearchableItems(Collection<T> searchableItems) {
            items.clear();
            items.addAll(searchableItems);

            if (preFilterComparator != null) {
                Collections.sort(items, preFilterComparator);
            }

            updateFilteredItems();
        }

        public void setSearchText(final String text){
            filter.setFilterText(text);
            updateFilteredItems();
        }

        public void setSearchType(final FilterBy filterBy) {
            filter.setFilterBy(filterBy);
            updateFilteredItems();
        }

        public void setSearchShowAllOnEmptyFilterText(boolean flag) {
            filter.setShowAllOnEmptyFilterText(flag);
        }

        public void refresh(){
            updateFilteredItems();
        }
        
        /**
         * Updates the searchable items into the filter items list.
         */
        private void updateFilteredItems() {
            //this fire will cause the action listener on the text field to fire
            fireIntervalRemoved(this, 0, filteredItems.size()); //notify clearing of the previous list
            filteredItems.clear();  //remove old filterItems items

            //if there is no filter, then there are no search results
            if (!"".equals(filter.getFilterText())) {
                for (T obj : items) {
                    if (filter.accept(obj)) {
                        filteredItems.add(obj);
                    }
                }
            } else if (filter.isShowAllOnEmptyFilterText()) {
                filteredItems.addAll(items);
            }

            if (!filteredItems.isEmpty()) {
                //sort based on the comparator
                if (comparator != null) {
                    Collections.sort(filteredItems, comparator);
                }

                fireIntervalAdded(this, 0, filteredItems.size());   //notify new list of filtered items
            }
        }

        public void setComparator(Comparator<T> comparator) {
            this.comparator = comparator;
        }

        public void setPreFilterComparator(Comparator<T> comparator) {
            this.preFilterComparator = comparator;
        }

    }

    /**
     *  The text editor field which will be listened for search characters to filter the items.
     */
    public class SearchFieldEditor<T> extends JTextField implements ComboBoxEditor, DocumentListener {
        private T selectedObject;
        private volatile boolean isFiltering = false;
        private volatile boolean isSetting = false;
        private Color normalBgColor;
        private final Color yellowBgColor = new Color(0xFF, 0xFF, 0xe1);
        private boolean enterLastKeyPressed = false;

        Runnable updateFilter = new Runnable() {
            @Override
            public void run() {
                filterItems(true);
                ignoreWhen = true;
            }
        };

        public SearchFieldEditor() {
            getDocument().addDocumentListener(this);
            addFocusListener(new FocusListener() {
                @Override
                public void focusGained(FocusEvent e) {
                    //don't filter with no filter text entered
                    if (!"".equals(getText()) && !EditableSearchComboBox.this.doNotFireEvents){
                        filterItems(true);
                        SearchFieldEditor.this.setSelectionStart(0);
                        SearchFieldEditor.this.setSelectionEnd(SearchFieldEditor.this.getText().length());
                    }else if (!"".equals(getText())){
                        filterItems(true);
                    }

                    //When doNotFireEvents is set to true, focus will be requested. Reset this flag here
                    if(doNotFireEvents){
                        EditableSearchComboBox.this.doNotFireEvents = false;
                    }
                }

                @Override
                public void focusLost(FocusEvent e) {
                    //nothing to do
                }
            });
            addKeyListener(new KeyAdapter() {
                @Override
                public void keyPressed(KeyEvent e) {
                    if(e.getKeyCode() == KeyEvent.VK_ENTER){
                        enterLastKeyPressed = true;
                    }else{
                        enterLastKeyPressed = false;
                    }
                }
            });
        }

        /**
         * Find out if the enter key was the last key entered.
         * This will reset enterLastKeyPressed, as once checked, this value should not persist for a second call
         *
         * @return true if enter was the last key pressed
         */
        public boolean getAndClearIsEnterLastKeyPressed(){
            final boolean result = enterLastKeyPressed;
            enterLastKeyPressed = false;
            return result;
        }

        @Override
        public Component getEditorComponent() {
            return this;
        }

        /**
         * setItem is called every time the user uses either the mouse keys to move through the drop down list or
         * if an item is clicked on with the mouse
         *
         * @param anObject
         */
        @Override
        public void setItem(Object anObject) {
            if(isFiltering) return;

            isSetting = true;
            //anObject comes directly from 'getSelectedItem' on the combo box. anObject is null, when nothing
            //is selected. Therefore we do not want to set "" as the text when anObject is null. We simply will do
            //nothing, which will leave any text previously entered in the text field.
            if (anObject != null) {
                //do not set the text of the text field. This overwrites what the user has typed
                //and causes various bugs where going back into the text field populates it with a previous selection
                if(paramaterizedType.isAssignableFrom(anObject.getClass())){
                    selectedObject = (T) anObject;
                }
            }
            isSetting = false;
        }

        @Override
        public Object getItem() {
            return getText();
        }

        @Override
        public void changedUpdate(DocumentEvent e) {}

        @Override
        public void insertUpdate(DocumentEvent e) {
            SwingUtilities.invokeLater(updateFilter);
        }

        @Override
        public void removeUpdate(DocumentEvent e) {
            SwingUtilities.invokeLater(updateFilter);
        }

        /**
         *  The core of the filtering to display the new items in the drop down list based on the filtering
         * @param showPopUp boolean if there are search results and true, then the pop up menu will be shown
         */
        protected void filterItems(final boolean showPopUp) {
            if (isSetting) return;

            isFiltering = true;
            //reset the selected node, as if we are filtering it no longer applies
            selectedObject = null;
            
            model.setSearchText(getText());

            //refresh the drop down list
            setPopupVisible(false);

            //only show drop down list when there are filtered items available to be displayed

            if(normalBgColor == null){
                normalBgColor = new Color(getBackground().getRGB());
            }

            if(model.getSize() > 0 || "".equals(getText())){
                setPopupVisible(showPopUp);
                if(getBackground().equals(yellowBgColor)){
                    setBackground(normalBgColor);
                    EditableSearchComboBox.this.doNotFireEvents = true;
                    SwingUtilities.invokeLater(new Runnable() {
                        @Override
                        public void run() {
                            EditableSearchComboBox.this.updateUI();
                            requestFocusInWindow();
                        }
                    });
                }
            } else {
                final Color oldColor = getBackground();
                if(!oldColor.equals(yellowBgColor)){
                    setBackground(yellowBgColor);
                    EditableSearchComboBox.this.doNotFireEvents = true;
                    SwingUtilities.invokeLater(new Runnable() {
                        @Override
                        public void run() {
                            EditableSearchComboBox.this.updateUI();
                            requestFocusInWindow();
                        }
                    });
                }
            }

            isFiltering = false;
        }

        /**
         * Use to stop an actionPerformed event when the editor loses focus and there are no search results
         * This is different than just checking model.getSize() > 0 as it means that the user has typed in search text
         *
         * @return true if the UI is in a state to indicate that there are no search results
         */
        public boolean isEditorShowingNoResults(){
            return getBackground().equals(yellowBgColor);
        }

        /**
         * Clear the text field. Note: this will cause the document listener to fire which will cause the
         * background color to be reset.
         */
        public void clearSearch() {
            setText("");
        }
    }

    /**
     * Filter-By methods.
     */
    public enum FilterBy {
        STARTS_WITH,
        CONTAINS,
        CUSTOMIZED
    }

    /**
     * Abstract filtering class to filter out the searchable items.
     */
    public static abstract class Filter {

        private boolean showAllOnEmptyFilterText;
        private FilterBy filterBy;
        private String filterText;

        public Filter() {
            filterText = "";
        }

        public Filter(String filterText) {
            this.filterText = filterText;
        }

        /**
         * @param obj   Object to be filtered
         * @return  TRUE if the provide object is accepted as part of the filtering.  Otherwise, FALSE.
         */
        public abstract boolean accept(Object obj);

        public String getFilterText() {
            return filterText;
        }

        public void setFilterText(String filterText) {
            if (filterText == null){
                this.filterText = "";
            } else{
                this.filterText = filterText;    
            }
        }

        public boolean isShowAllOnEmptyFilterText() {
            return showAllOnEmptyFilterText;
        }

        public void setShowAllOnEmptyFilterText(boolean showAllOnEmptyFilterText) {
            this.showAllOnEmptyFilterText = showAllOnEmptyFilterText;
        }

        public FilterBy getFilterBy() {
            return filterBy;
        }

        public void setFilterBy(FilterBy filterBy) {
            this.filterBy = filterBy;
        }
    }

    public static void main(String[] arg) {
        String[] list = {"test", "tetttt", " tesr3", "fdasfds", "tee2"};
        List ha = new ArrayList();
        ha.add("Denis");
        ha.add("yo");
        ha.add("Deeee");
        ha.add("denneejk");
        final EditableSearchComboBox combo = new EditableSearchComboBox(ha, new Filter() {
            @Override
            public boolean accept(Object obj) {
                return true;
            }
        }){};

        combo.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                System.out.println(e.getActionCommand() + " " + e.getModifiers());
                if (e.getActionCommand().equals("comboBoxEdited") && e.getModifiers() == 0) {
                    System.out.println("Key board selected -->" + combo.getSelectedItem() + " " + combo.getSelectedIndex());
                }

                if (e.getActionCommand().equals("comboBoxChanged") && e.getModifiers() > 0) {
                    System.out.println("mouse selected -->" + combo.getSelectedItem());
                }

            }

        });

        JFrame f = new JFrame();
        JPanel p = new JPanel(new BorderLayout());
        p.add(combo, BorderLayout.CENTER);
        f.add(p);
        f.pack();
        f.setVisible(true);
    }
}
