package com.l7tech.common.security.xml;

import com.l7tech.common.util.HexUtils;
import com.l7tech.common.util.SoapUtil;
import com.l7tech.common.util.XmlUtil;
import com.l7tech.common.xml.TestDocuments;
import junit.framework.Test;
import junit.framework.TestCase;
import junit.framework.TestSuite;
import org.w3c.dom.Document;
import org.w3c.dom.Element;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.util.Arrays;

/**
 * Test xml digital signature and encryption interoperability with messages
 * generated by a .net client using WSE 2.0
 * <p/>
 * <br/><br/>
 * LAYER 7 TECHNOLOGIES, INC<br/>
 * User: flascell<br/>
 * Date: Jun 15, 2004<br/>
 * $Id$<br/>
 */
public class DotNetInteropTest extends TestCase {

    public static void main(String[] args) throws Throwable {
        junit.textui.TestRunner.run(suite());
    }

    public static Test suite() {
        TestSuite suite = new TestSuite(DotNetInteropTest.class);
        return suite;
    }

    public void testValidateSignatureFromdotNetRequest() throws Exception {
        Document signedDoc = getSignedRequest();
        Element bodyEl = SoapUtil.getBody(signedDoc);
        X509Certificate[] clientCert = SoapMsgSigner.validateSignature(signedDoc, bodyEl);
        assertTrue(clientCert.length > 0);
        assertTrue(clientCert[0].getSubjectDN().toString().equals("CN=WSE2QuickStartClient"));
        System.out.println("Signature verified successfully for subject: " + clientCert[0].getSubjectDN() + ".");
    }

    public void testInValidateSignatureFromBaddotNetSignature() throws Exception {
        Document signedDoc = getInvalidSignedRequest();
        Element bodyEl = SoapUtil.getBody(signedDoc);
        boolean signatureFailed = false;
        try {
            SoapMsgSigner.validateSignature(signedDoc, bodyEl);
        } catch (InvalidSignatureException e) {
            signatureFailed = true;
        }
        assertTrue(signatureFailed);
    }

    public void testGetEncryptedKey() throws Exception {
        Document encryptedDoc = getEncryptedDoc();
        X509Certificate servercert = getRikerCert();
        PrivateKey privateServerKey = getRikerPrivateKey();
        XmlMangler.ProcessedEncryptedKey[] encryptionKeys = XmlMangler.getEncryptedKeyFromMessage(encryptedDoc,
                                                                                                  privateServerKey,                                                                                                  servercert.getExtensionValue("2.5.29.14"));
        assertTrue(encryptionKeys.length == 1);
        assertTrue(Arrays.equals(DECRYPTED_KEY, encryptionKeys[0].decryptedKey.getEncoded()));
    }

    public void testDecryptdotNetRequest() throws Exception {
        Document encryptedDoc = getEncryptedDoc();
        X509Certificate servercert = getRikerCert();

        PrivateKey privateServerKey = getRikerPrivateKey();
        XmlMangler.ProcessedEncryptedKey[] encryptionKeys = XmlMangler.getEncryptedKeyFromMessage(encryptedDoc,
                                                                                                  privateServerKey,
                                                                                                  servercert.getExtensionValue("2.5.29.14"));

        Element body = SoapUtil.getBody(encryptedDoc);
        XmlMangler.decryptElement(body, encryptionKeys[0].decryptedKey, encryptionKeys[0].referenceList);
        String result = XmlUtil.documentToString(encryptedDoc);
        System.out.println(result);
    }

    private PrivateKey getRikerPrivateKey() throws Exception {
        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
        InputStream fis = TestDocuments.getInputStream(TestDocuments.SSL_KS);
        //fis = FileUtils.loadFileSafely(sslkeystorepath);
        keyStore.load(fis, "blahblah".toCharArray());
        fis.close();
        PrivateKey output = (PrivateKey)keyStore.getKey("tomcat", "blahblah".toCharArray());
        return output;
    }

    private X509Certificate getRikerCert() throws Exception {
        InputStream fis = TestDocuments.getInputStream(TestDocuments.SSL_CER);
        byte[] certbytes;
        try {
            certbytes = HexUtils.slurpStream(fis, 16384);
        } finally {
            fis.close();
        }
        // construct the x509 based on the bytes
        return (X509Certificate)(CertificateFactory.getInstance("X.509").
                                 generateCertificate(new ByteArrayInputStream(certbytes)));
    }

    private Document getEncryptedDoc() throws Exception {
        return TestDocuments.getTestDocument(TestDocuments.DOTNET_ENCRYPTED_REQUEST);
    }

    private Document getSignedRequest() throws Exception {
        return TestDocuments.getTestDocument(TestDocuments.DOTNET_SIGNED_REQUEST);
    }

    private Document getInvalidSignedRequest() throws Exception {
        return TestDocuments.getTestDocument(TestDocuments.DOTNET_SIGNED_TAMPERED_REQUEST);
    }
    public static final byte[] DECRYPTED_KEY = {-54, 33,-19, 87, -46, 31, -86, 44, -10, 3, -37, 111, 125, -94, -64, 24};
}
